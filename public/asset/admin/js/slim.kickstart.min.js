/*
 * Slim v5.1.1 - Image Cropping Made Easy
 * Copyright (c) 2019 Rik Schennink - https://pqina.nl/slim
 */
!function(t,e){function i(){t.Slim.parse(document)}if(t)if(t.Slim=function(){function t(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e,i,n){if(!(e>=1)){for(var o=t.width,a=t.height,r=Math.max(n.width,Math.min(i.width,Math.round(t.width*e))),s=Math.max(n.height,Math.min(i.height,Math.round(t.height*e))),h=t,u=null;o>r&&a>s;){var l=document.createElement("canvas");o=Math.round(.5*h.width),a=Math.round(.5*h.height),o<r&&(o=r),a<s&&(a=s),l.width=o,l.height=a,u=l.getContext("2d"),u.drawImage(h,0,0,o,a),h=l,l=null}t.width=r,t.height=s,u=t.getContext("2d"),u.drawImage(h,0,0,r,s)}}!function(){function t(t,i){i=i||{bubbles:!1,cancelable:!1,detail:e};var n=document.createEvent("CustomEvent");return n.initCustomEvent(t,i.bubbles,i.cancelable,i.detail),n}return"function"!=typeof window.CustomEvent&&(t.prototype=window.Event.prototype,void(window.CustomEvent=t))}();var n=function(t,e,i){var o,a,r=document.createElement("img");if(r.onerror=e,r.onload=function(){!a||i&&i.noRevoke||n.revokeObjectURL(a),e&&e(n.scale(r,i))},n.isInstanceOf("Blob",t)||n.isInstanceOf("File",t))o=a=n.createObjectURL(t),r._type=t.type;else{if("string"!=typeof t)return!1;o=t,i&&i.crossOrigin&&(r.crossOrigin=i.crossOrigin)}return o?(r.src=o,r):n.readFile(t,function(t){var i=t.target;i&&i.result?r.src=i.result:e&&e(t)})},o=window.createObjectURL&&window||window.URL&&URL.revokeObjectURL&&URL||window.webkitURL&&webkitURL;n.isInstanceOf=function(t,e){return Object.prototype.toString.call(e)==="[object "+t+"]"},n.transformCoordinates=function(){},n.getTransformedOptions=function(t,e){var i,n,o,a,r=e.aspectRatio;if(!r)return e;i={};for(n in e)e.hasOwnProperty(n)&&(i[n]=e[n]);return i.crop=!0,o=t.naturalWidth||t.width,a=t.naturalHeight||t.height,o/a>r?(i.maxWidth=a*r,i.maxHeight=a):(i.maxWidth=o,i.maxHeight=o/r),i},n.renderImageToCanvas=function(t,e,i,n,o,a,r,s,h,u){return t.getContext("2d").drawImage(e,i,n,o,a,r,s,h,u),t},n.hasCanvasOption=function(t){return t.canvas||t.crop||!!t.aspectRatio},n.scale=function(t,i){function o(){var t=Math.max((h||b)/b,(u||k)/k);t>1&&(b*=t,k*=t)}function a(){var t=Math.min((r||b)/b,(s||k)/k);t<1&&(b*=t,k*=t)}i=i||{};var r,s,h,u,l,p,c,d,f,_,m,g=document.createElement("canvas"),v=t.getContext||n.hasCanvasOption(i)&&g.getContext,y=t.naturalWidth||t.width,w=t.naturalHeight||t.height,b=y,k=w;if(v&&(i=n.getTransformedOptions(t,i),c=i.left||0,d=i.top||0,i.sourceWidth?(l=i.sourceWidth,i.right!==e&&i.left===e&&(c=y-l-i.right)):l=y-c-(i.right||0),i.sourceHeight?(p=i.sourceHeight,i.bottom!==e&&i.top===e&&(d=w-p-i.bottom)):p=w-d-(i.bottom||0),b=l,k=p),r=i.maxWidth,s=i.maxHeight,h=i.minWidth,u=i.minHeight,v&&r&&s&&i.crop?(b=r,k=s,m=l/p-r/s,m<0?(p=s*l/r,i.top===e&&i.bottom===e&&(d=(w-p)/2)):m>0&&(l=r*p/s,i.left===e&&i.right===e&&(c=(y-l)/2))):((i.contain||i.cover)&&(h=r=r||h,u=s=s||u),i.cover?(a(),o()):(o(),a())),v){if(f=i.pixelRatio,f>1&&(g.style.width=b+"px",g.style.height=k+"px",b*=f,k*=f,g.getContext("2d").scale(f,f)),_=i.downsamplingRatio,_>0&&_<1&&b<l&&k<p)for(;l*_>b;)g.width=l*_,g.height=p*_,n.renderImageToCanvas(g,t,c,d,l,p,0,0,g.width,g.height),l=g.width,p=g.height,t=document.createElement("canvas"),t.width=l,t.height=p,n.renderImageToCanvas(t,g,0,0,l,p,0,0,l,p);return g.width=b,g.height=k,n.transformCoordinates(g,i),n.renderImageToCanvas(g,t,c,d,l,p,0,0,b,k)}return t.width=b,t.height=k,t},n.createObjectURL=function(t){return!!o&&o.createObjectURL(t)},n.revokeObjectURL=function(t){return!!o&&o.revokeObjectURL(t)},n.readFile=function(t,e,i){if(window.FileReader){var n=new FileReader;if(n.onload=n.onerror=e,i=i||"readAsDataURL",n[i])return n[i](t),n}return!1};var a=n.hasCanvasOption,r=n.transformCoordinates,s=n.getTransformedOptions;n.hasCanvasOption=function(t){return!!t.orientation||a.call(n,t)},n.transformCoordinates=function(t,e){r.call(n,t,e);var i=t.getContext("2d"),o=t.width,a=t.height,s=t.style.width,h=t.style.height,u=e.orientation;if(u&&!(u>8))switch(u>4&&(t.width=a,t.height=o,t.style.width=h,t.style.height=s),u){case 2:i.translate(o,0),i.scale(-1,1);break;case 3:i.translate(o,a),i.rotate(Math.PI);break;case 4:i.translate(0,a),i.scale(1,-1);break;case 5:i.rotate(.5*Math.PI),i.scale(1,-1);break;case 6:i.rotate(.5*Math.PI),i.translate(0,-a);break;case 7:i.rotate(.5*Math.PI),i.translate(o,-a),i.scale(-1,1);break;case 8:i.rotate(-.5*Math.PI),i.translate(-o,0)}},n.getTransformedOptions=function(t,e){var i,o,a=s.call(n,t,e),r=a.orientation;if(!r||r>8||1===r)return a;i={};for(o in a)a.hasOwnProperty(o)&&(i[o]=a[o]);switch(a.orientation){case 2:i.left=a.right,i.right=a.left;break;case 3:i.left=a.right,i.top=a.bottom,i.right=a.left,i.bottom=a.top;break;case 4:i.top=a.bottom,i.bottom=a.top;break;case 5:i.left=a.top,i.top=a.left,i.right=a.bottom,i.bottom=a.right;break;case 6:i.left=a.top,i.top=a.right,i.right=a.bottom,i.bottom=a.left;break;case 7:i.left=a.bottom,i.top=a.right,i.right=a.top,i.bottom=a.left;break;case 8:i.left=a.bottom,i.top=a.left,i.right=a.top,i.bottom=a.right}return a.orientation>4&&(i.maxWidth=a.maxHeight,i.maxHeight=a.maxWidth,i.minWidth=a.minHeight,i.minHeight=a.minWidth,i.sourceWidth=a.sourceHeight,i.sourceHeight=a.sourceWidth),i};var h=window.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice);n.blobSlice=h&&function(){var t=this.slice||this.webkitSlice||this.mozSlice;return t.apply(this,arguments)},n.metaDataParsers={jpeg:{65505:[]}},n.parseMetaData=function(t,e,i){i=i||{};var o=this,a=i.maxMetaDataSize||262144,r={},s=!(window.DataView&&t&&t.size>=12&&"image/jpeg"===t.type&&n.blobSlice);!s&&n.readFile(n.blobSlice.call(t,0,a),function(t){if(t.target.error)return void e(r);var a,s,h,u,l=t.target.result,p=new DataView(l),c=2,d=p.byteLength-4,f=c;if(65496===p.getUint16(0)){for(;c<d&&(a=p.getUint16(c),a>=65504&&a<=65519||65534===a)&&(s=p.getUint16(c+2)+2,!(c+s>p.byteLength));){if(h=n.metaDataParsers.jpeg[a])for(u=0;u<h.length;u+=1)h[u].call(o,p,c,s,r,i);c+=s,f=c}!i.disableImageHead&&f>6&&(l.slice?r.imageHead=l.slice(0,f):r.imageHead=new Uint8Array(l).subarray(0,f))}e(r)},"readAsArrayBuffer")||e(r)},n.ExifMap=function(){return this},n.ExifMap.prototype.map={Orientation:274},n.ExifMap.prototype.get=function(t){return this[t]||this[this.map[t]]},n.getExifThumbnail=function(t,e,i){var n,o,a;if(i&&!(e+i>t.byteLength)){for(n=[],o=0;o<i;o+=1)a=t.getUint8(e+o),n.push((a<16?"0":"")+a.toString(16));return"data:image/jpeg,%"+n.join("%")}},n.exifTagTypes={1:{getValue:function(t,e){return t.getUint8(e)},size:1},2:{getValue:function(t,e){return String.fromCharCode(t.getUint8(e))},size:1,ascii:!0},3:{getValue:function(t,e,i){return t.getUint16(e,i)},size:2},4:{getValue:function(t,e,i){return t.getUint32(e,i)},size:4},5:{getValue:function(t,e,i){return t.getUint32(e,i)/t.getUint32(e+4,i)},size:8},9:{getValue:function(t,e,i){return t.getInt32(e,i)},size:4},10:{getValue:function(t,e,i){return t.getInt32(e,i)/t.getInt32(e+4,i)},size:8}},n.exifTagTypes[7]=n.exifTagTypes[1],n.getExifValue=function(t,e,i,o,a,r){var s,h,u,l,p,c,d=n.exifTagTypes[o];if(d&&(s=d.size*a,h=s>4?e+t.getUint32(i+8,r):i+8,!(h+s>t.byteLength))){if(1===a)return d.getValue(t,h,r);for(u=[],l=0;l<a;l+=1)u[l]=d.getValue(t,h+l*d.size,r);if(d.ascii){for(p="",l=0;l<u.length&&(c=u[l],"\0"!==c);l+=1)p+=c;return p}return u}},n.parseExifTag=function(t,e,i,o,a){var r=t.getUint16(i,o);a.exif[r]=n.getExifValue(t,e,i,t.getUint16(i+2,o),t.getUint32(i+4,o),o)},n.parseExifTags=function(t,e,i,n,o){var a,r,s;if(!(i+6>t.byteLength||(a=t.getUint16(i,n),r=i+2+12*a,r+4>t.byteLength))){for(s=0;s<a;s+=1)this.parseExifTag(t,e,i+2+12*s,n,o);return t.getUint32(r,n)}},n.parseExifData=function(t,e,i,o,a){if(!a.disableExif){var r,s,h,u=e+10;if(1165519206===t.getUint32(e+4)&&!(u+8>t.byteLength)&&0===t.getUint16(e+8)){switch(t.getUint16(u)){case 18761:r=!0;break;case 19789:r=!1;break;default:return}42===t.getUint16(u+2,r)&&(s=t.getUint32(u+4,r),o.exif=new n.ExifMap,s=n.parseExifTags(t,u,u+s,r,o),s&&!a.disableExifThumbnail&&(h={exif:{}},s=n.parseExifTags(t,u,u+s,r,h),h.exif[513]&&(o.exif.Thumbnail=n.getExifThumbnail(t,u+h.exif[513],h.exif[514]))),o.exif[34665]&&!a.disableExifSub&&n.parseExifTags(t,u,u+o.exif[34665],r,o),o.exif[34853]&&!a.disableExifGps&&n.parseExifTags(t,u,u+o.exif[34853],r,o))}}},n.metaDataParsers.jpeg[65505].push(n.parseExifData);var u=function(){var t=[],i=[],n=[],o="transform",a=window.getComputedStyle(document.documentElement,""),r=(Array.prototype.slice.call(a).join("").match(/-(moz|webkit|ms)-/)||""===a.OLink&&["","o"])[1];"webkit"===r&&(o="webkitTransform");var s=function(t,i,n){var o=t;if(o.length!==e){for(var a={chainers:[],then:function(t){return this.snabbt(t)},snabbt:function(t){var e=this.chainers.length;return this.chainers.forEach(function(i,n){i.snabbt(h(t,n,e))}),a},setValue:function(t){return this.chainers.forEach(function(e){e.setValue(t)}),a},finish:function(){return this.chainers.forEach(function(t){t.finish()}),a},rollback:function(){return this.chainers.forEach(function(t){t.rollback()}),a}},r=0,s=o.length;r<s;++r)"string"==typeof i?a.chainers.push(u(o[r],i,h(n,r,s))):a.chainers.push(u(o[r],h(i,r,s),n));return a}return"string"==typeof i?u(o,i,h(n,0,1)):u(o,h(i,0,1),n)},h=function(t,e,i){if(!t)return t;var n=$(t);J(t.delay)&&(n.delay=t.delay(e,i)),J(t.callback)&&(n.complete=function(){t.callback.call(this,e,i)});var o=J(t.allDone),a=J(t.complete);(a||o)&&(n.complete=function(){a&&t.complete.call(this,e,i),o&&e==i-1&&t.allDone()}),J(t.valueFeeder)&&(n.valueFeeder=function(n,o){return t.valueFeeder(n,o,e,i)}),J(t.easing)&&(n.easing=function(n){return t.easing(n,e,i)});var r=["position","rotation","skew","rotationPost","scale","width","height","opacity","fromPosition","fromRotation","fromSkew","fromRotationPost","fromScale","fromWidth","fromHeight","fromOpacity","transformOrigin","duration","delay"];return r.forEach(function(o){J(t[o])&&(n[o]=t[o](e,i))}),n},u=function(t,e,n){function o(e){if(f.tick(e),f.updateElement(t),!f.isStopped())return f.completed()?void(a.loop>1&&!f.isStopped()?(a.loop-=1,f.restart(),k(o)):(a.complete&&a.complete.call(t),_.length&&(a=_.pop(),s=y(a,u,!0),u=y(a,$(u)),a=w(s,u,a),f=S(a),i.push([t,f]),f.tick(e),k(o)))):k(o)}if("attention"===e)return l(t,n);if("stop"===e)return p(t);if("detach"===e)return d(t);var a=e;m();var r=v(t),s=r;s=y(a,s,!0);var u=$(r);u=y(a,u);var c=w(s,u,a),f=S(c);i.push([t,f]),f.updateElement(t,!0);var _=[],g={snabbt:function(t){return _.unshift(h(t,0,1)),g},then:function(t){return this.snabbt(t)}};return k(o),a.manual?f:g},l=function(t,e){function n(i){a.tick(i),a.updateElement(t),a.completed()?(e.callback&&e.callback(t),e.loop&&e.loop>1&&(e.loop--,a.restart(),k(n))):k(n)}var o=y(e,q({}));e.movement=o;var a=C(e);i.push([t,a]),k(n)},p=function(t){for(var e=0,n=i.length;e<n;++e){var o=i[e],a=o[0],r=o[1];a===t&&r.stop()}},c=function(t,e){for(var i=0,n=t.length;i<n;++i)if(t[i][0]===e)return i;return-1},d=function(t){var e,o,a=[],r=i.concat(n),s=r.length;for(o=0;o<s;++o)e=r[o][0],(t.contains(e)||t===e)&&a.push(e);for(s=a.length,o=0;o<s;++o)f(a[o])},f=function(t){p(t);var e=c(i,t);e>=0&&i.splice(e,1),e=c(n,t),e>=0&&n.splice(e,1)},_=function(t,e){for(var i=0,n=t.length;i<n;++i){var o=t[i],a=o[0],r=o[1];if(a===e){var s=r.getCurrentState();return r.stop(),s}}},m=function(){n=n.filter(function(t){return g(t[0]).body})},g=function(t){for(var e=t;e.parentNode;)e=e.parentNode;return e},v=function(t){var e=_(i,t);return e?e:_(n,t)},y=function(t,e,i){e||(e=q({position:[0,0,0],rotation:[0,0,0],rotationPost:[0,0,0],scale:[1,1],skew:[0,0]}));var n="position",o="rotation",a="skew",r="rotationPost",s="scale",h="scalePost",u="width",l="height",p="opacity";return i&&(n="fromPosition",o="fromRotation",a="fromSkew",r="fromRotationPost",s="fromScale",h="fromScalePost",u="fromWidth",l="fromHeight",p="fromOpacity"),e.position=G(t[n],e.position),e.rotation=G(t[o],e.rotation),e.rotationPost=G(t[r],e.rotationPost),e.skew=G(t[a],e.skew),e.scale=G(t[s],e.scale),e.scalePost=G(t[h],e.scalePost),e.opacity=t[p],e.width=t[u],e.height=t[l],e},w=function(t,e,i){return i.startState=t,i.endState=e,i},b=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return setTimeout(t,1e3/60)},k=function(e){0===t.length&&b(x),t.push(e)},x=function(e){for(var o=t.length,a=0;a<o;++a)t[a](e);t.splice(0,o);var r=i.filter(function(t){return t[1].completed()});n=n.filter(function(t){for(var e=0,i=r.length;e<i;++e)if(t[0]===r[e][0])return!1;return!0}),n=n.concat(r),i=i.filter(function(t){return!t[1].completed()}),0!==t.length&&b(x)},S=function(t){var i=t.startState,n=t.endState,o=G(t.duration,500),a=G(t.delay,0),r=t.perspective,s=L(G(t.easing,"linear"),t),h=0===o?n.clone():i.clone();t.transformOrigin;h.transformOrigin=t.transformOrigin;var u,l,p=0,c=0,d=!1,f=!1,_=t.manual,m=0,g=a/o;return l=t.valueFeeder?V(t.valueFeeder,i,n,h):j(i,n,h),{stop:function(){d=!0},isStopped:function(){return d},finish:function(t){_=!1;var e=o*m;p=c-e,u=t,s.resetFrom=m},rollback:function(t){_=!1,l.setReverse();var e=o*(1-m);p=c-e,u=t,s.resetFrom=m},restart:function(){p=e,s.resetFrom(0)},tick:function(t){if(!d){if(_)return c=t,void this.updateCurrentTransform();if(p||(p=t),t-p>a){f=!0,c=t-a;var e=Math.min(Math.max(0,c-p),o);s.tick(e/o),this.updateCurrentTransform(),this.completed()&&u&&u()}}},getCurrentState:function(){return h},setValue:function(t){f=!0,m=Math.min(Math.max(t,1e-4),1+g)},updateCurrentTransform:function(){var t=s.getValue();if(_){var e=Math.max(1e-5,m-g);s.tick(e),t=s.getValue()}l.tween(t)},completed:function(){return!!d||0!==p&&s.completed()},updateElement:function(t,e){if(f||e){var i=l.asMatrix(),n=l.getProperties();X(t,i,r),Y(t,n)}}}},C=function(t){var i=t.movement;t.initialVelocity=.1,t.equilibriumPosition=0;var n=T(t),o=!1,a=i.position,r=i.rotation,s=i.rotationPost,h=i.scale,u=i.skew,l=q({position:a?[0,0,0]:e,rotation:r?[0,0,0]:e,rotationPost:s?[0,0,0]:e,scale:h?[0,0]:e,skew:u?[0,0]:e});return{stop:function(){o=!0},isStopped:function(t){return o},tick:function(t){o||n.equilibrium||(n.tick(),this.updateMovement())},updateMovement:function(){var t=n.getValue();a&&(l.position[0]=i.position[0]*t,l.position[1]=i.position[1]*t,l.position[2]=i.position[2]*t),r&&(l.rotation[0]=i.rotation[0]*t,l.rotation[1]=i.rotation[1]*t,l.rotation[2]=i.rotation[2]*t),s&&(l.rotationPost[0]=i.rotationPost[0]*t,l.rotationPost[1]=i.rotationPost[1]*t,l.rotationPost[2]=i.rotationPost[2]*t),h&&(l.scale[0]=1+i.scale[0]*t,l.scale[1]=1+i.scale[1]*t),u&&(l.skew[0]=i.skew[0]*t,l.skew[1]=i.skew[1]*t)},updateElement:function(t){X(t,l.asMatrix()),Y(t,l.getProperties())},getCurrentState:function(){return l},completed:function(){return n.equilibrium||o},restart:function(){n=T(t)}}},E=function(t){return t},P=function(t){return(Math.cos(t*Math.PI+Math.PI)+1)/2},M=function(t){return t*t},R=function(t){return-Math.pow(t-1,2)+1},T=function(t){var e=G(t.startPosition,0),i=G(t.equilibriumPosition,1),n=G(t.initialVelocity,0),o=G(t.springConstant,.8),a=G(t.springDeceleration,.9),r=G(t.springMass,10),s=!1;return{tick:function(t){if(0!==t&&!s){var h=-(e-i)*o,u=h/r;n+=u,e+=n,n*=a,Math.abs(e-i)<.001&&Math.abs(n)<.001&&(s=!0)}},resetFrom:function(t){e=t,n=0},getValue:function(){return s?i:e},completed:function(){return s}}},I={linear:E,ease:P,easeIn:M,easeOut:R},L=function(t,e){if("spring"==t)return T(e);var i=t;J(t)||(i=I[t]);var n,o=i,a=0;return{tick:function(t){a=o(t),n=t},resetFrom:function(t){n=0},getValue:function(){return a},completed:function(){return n>=1&&n}}},O=function(t,e,i,n){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e,t[13]=i,t[14]=n,t[15]=1},z=function(t,e){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=Math.cos(e),t[6]=-Math.sin(e),t[7]=0,t[8]=0,t[9]=Math.sin(e),t[10]=Math.cos(e),t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},D=function(t,e){t[0]=Math.cos(e),t[1]=0,t[2]=Math.sin(e),t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=-Math.sin(e),t[9]=0,t[10]=Math.cos(e),t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},A=function(t,e){t[0]=Math.cos(e),t[1]=-Math.sin(e),t[2]=0,t[3]=0,t[4]=Math.sin(e),t[5]=Math.cos(e),t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},U=function(t,e,i){t[0]=1,t[1]=Math.tan(e),t[2]=0,t[3]=0,t[4]=Math.tan(i),t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},H=function(t,e,i){t[0]=e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},N=function(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1},B=function(t,e){e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]},F=function(){var t=new Float32Array(16),e=new Float32Array(16),i=new Float32Array(16);return N(t),{data:t,asCSS:function(){for(var e="matrix3d(",i=0;i<15;++i)e+=Math.abs(t[i])<1e-4?"0,":t[i].toFixed(10)+",";return e+=Math.abs(t[15])<1e-4?"0)":t[15].toFixed(10)+")"},clear:function(){N(t)},translate:function(n,o,a){return B(t,e),O(i,n,o,a),W(e,i,t),this},rotateX:function(n){return B(t,e),z(i,n),W(e,i,t),this},rotateY:function(n){return B(t,e),D(i,n),W(e,i,t),this},rotateZ:function(n){return B(t,e),A(i,n),W(e,i,t),this},scale:function(n,o){return B(t,e),H(i,n,o),W(e,i,t),this},skew:function(n,o){return B(t,e),U(i,n,o),W(e,i,t),this}}},W=function(t,e,i){return i[0]=t[0]*e[0]+t[1]*e[4]+t[2]*e[8]+t[3]*e[12],i[1]=t[0]*e[1]+t[1]*e[5]+t[2]*e[9]+t[3]*e[13],i[2]=t[0]*e[2]+t[1]*e[6]+t[2]*e[10]+t[3]*e[14],i[3]=t[0]*e[3]+t[1]*e[7]+t[2]*e[11]+t[3]*e[15],i[4]=t[4]*e[0]+t[5]*e[4]+t[6]*e[8]+t[7]*e[12],i[5]=t[4]*e[1]+t[5]*e[5]+t[6]*e[9]+t[7]*e[13],i[6]=t[4]*e[2]+t[5]*e[6]+t[6]*e[10]+t[7]*e[14],i[7]=t[4]*e[3]+t[5]*e[7]+t[6]*e[11]+t[7]*e[15],i[8]=t[8]*e[0]+t[9]*e[4]+t[10]*e[8]+t[11]*e[12],i[9]=t[8]*e[1]+t[9]*e[5]+t[10]*e[9]+t[11]*e[13],i[10]=t[8]*e[2]+t[9]*e[6]+t[10]*e[10]+t[11]*e[14],i[11]=t[8]*e[3]+t[9]*e[7]+t[10]*e[11]+t[11]*e[15],i[12]=t[12]*e[0]+t[13]*e[4]+t[14]*e[8]+t[15]*e[12],i[13]=t[12]*e[1]+t[13]*e[5]+t[14]*e[9]+t[15]*e[13],i[14]=t[12]*e[2]+t[13]*e[6]+t[14]*e[10]+t[15]*e[14],i[15]=t[12]*e[3]+t[13]*e[7]+t[14]*e[11]+t[15]*e[15],i},q=function(t){var i=F(),n={opacity:e,width:e,height:e};return{position:t.position,rotation:t.rotation,rotationPost:t.rotationPost,skew:t.skew,scale:t.scale,scalePost:t.scalePost,opacity:t.opacity,width:t.width,height:t.height,clone:function(){return q({position:this.position?this.position.slice(0):e,rotation:this.rotation?this.rotation.slice(0):e,rotationPost:this.rotationPost?this.rotationPost.slice(0):e,skew:this.skew?this.skew.slice(0):e,scale:this.scale?this.scale.slice(0):e,scalePost:this.scalePost?this.scalePost.slice(0):e,height:this.height,width:this.width,opacity:this.opacity})},asMatrix:function(){var t=i;return t.clear(),this.transformOrigin&&t.translate(-this.transformOrigin[0],-this.transformOrigin[1],-this.transformOrigin[2]),this.scale&&t.scale(this.scale[0],this.scale[1]),this.skew&&t.skew(this.skew[0],this.skew[1]),this.rotation&&(t.rotateX(this.rotation[0]),t.rotateY(this.rotation[1]),t.rotateZ(this.rotation[2])),this.position&&t.translate(this.position[0],this.position[1],this.position[2]),this.rotationPost&&(t.rotateX(this.rotationPost[0]),t.rotateY(this.rotationPost[1]),t.rotateZ(this.rotationPost[2])),this.scalePost&&t.scale(this.scalePost[0],this.scalePost[1]),this.transformOrigin&&t.translate(this.transformOrigin[0],this.transformOrigin[1],this.transformOrigin[2]),t},getProperties:function(){return n.opacity=this.opacity,n.width=this.width+"px",n.height=this.height+"px",n}}},j=function(t,i,n){var o=t,a=i,r=n,s=a.position!==e,h=a.rotation!==e,u=a.rotationPost!==e,l=a.scale!==e,p=a.skew!==e,c=a.width!==e,d=a.height!==e,f=a.opacity!==e;return{tween:function(t){if(s){var e=a.position[0]-o.position[0],i=a.position[1]-o.position[1],n=a.position[2]-o.position[2];r.position[0]=o.position[0]+t*e,r.position[1]=o.position[1]+t*i,r.position[2]=o.position[2]+t*n}if(h){var _=a.rotation[0]-o.rotation[0],m=a.rotation[1]-o.rotation[1],g=a.rotation[2]-o.rotation[2];r.rotation[0]=o.rotation[0]+t*_,r.rotation[1]=o.rotation[1]+t*m,r.rotation[2]=o.rotation[2]+t*g}if(u){var v=a.rotationPost[0]-o.rotationPost[0],y=a.rotationPost[1]-o.rotationPost[1],w=a.rotationPost[2]-o.rotationPost[2];r.rotationPost[0]=o.rotationPost[0]+t*v,r.rotationPost[1]=o.rotationPost[1]+t*y,r.rotationPost[2]=o.rotationPost[2]+t*w}if(p){var b=a.scale[0]-o.scale[0],k=a.scale[1]-o.scale[1];r.scale[0]=o.scale[0]+t*b,r.scale[1]=o.scale[1]+t*k}if(l){var x=a.skew[0]-o.skew[0],S=a.skew[1]-o.skew[1];r.skew[0]=o.skew[0]+t*x,r.skew[1]=o.skew[1]+t*S}if(c){var C=a.width-o.width;r.width=o.width+t*C}if(d){var E=a.height-o.height;r.height=o.height+t*E}if(f){var P=a.opacity-o.opacity;r.opacity=o.opacity+t*P}},asMatrix:function(){return r.asMatrix()},getProperties:function(){return r.getProperties()},setReverse:function(){var t=o;o=a,a=t}}},V=function(t,i,n,o){var a=t(0,F()),r=i,s=n,h=o,u=!1;return{tween:function(i){u&&(i=1-i),a.clear(),a=t(i,a);var n=s.width-r.width,o=s.height-r.height,l=s.opacity-r.opacity;s.width!==e&&(h.width=r.width+i*n),s.height!==e&&(h.height=r.height+i*o),s.opacity!==e&&(h.opacity=r.opacity+i*l)},asMatrix:function(){return a},getProperties:function(){return h.getProperties()},setReverse:function(){u=!0}}},G=function(t,e){return"undefined"==typeof t?e:t},X=function(t,e,i){var n="";i&&(n="perspective("+i+"px) ");var a=e.asCSS();t.style[o]=n+a},Y=function(t,e){for(var i in e)t.style[i]=e[i]},J=function(t){return"function"==typeof t},$=function(t){if(!t)return t;var e={};for(var i in t)e[i]=t[i];return e};return s.createMatrix=F,s.setElementTransform=X,s}(),l=function(){function t(t,e,i,n,o){if("string"==typeof t)t=document.getElementById(t);else if(!t instanceof HTMLCanvasElement)return;var a,r=t.getContext("2d");try{try{a=r.getImageData(e,i,n,o)}catch(s){throw new Error("unable to access local image data: "+s)}}catch(s){throw new Error("unable to access image data: "+s)}return a}function e(e,n,o,a,r,s){if(!(isNaN(s)||s<1)){s|=0;var h=t(e,n,o,a,r);h=i(h,n,o,a,r,s),e.getContext("2d").putImageData(h,n,o)}}function i(t,e,i,r,s,h){var u,l,p,c,d,f,_,m,g,v,y,w,b,k,x,S,C,E,P,M,R,T,I,L,O=t.data,z=h+h+1,D=r-1,A=s-1,U=h+1,H=U*(U+1)/2,N=new n,B=N;for(p=1;p<z;p++)if(B=B.next=new n,p==U)var F=B;B.next=N;var W=null,q=null;_=f=0;var j=o[h],V=a[h];for(l=0;l<s;l++){for(S=C=E=P=m=g=v=y=0,w=U*(M=O[f]),b=U*(R=O[f+1]),k=U*(T=O[f+2]),x=U*(I=O[f+3]),m+=H*M,g+=H*R,v+=H*T,y+=H*I,B=N,p=0;p<U;p++)B.r=M,B.g=R,B.b=T,B.a=I,B=B.next;for(p=1;p<U;p++)c=f+((D<p?D:p)<<2),m+=(B.r=M=O[c])*(L=U-p),g+=(B.g=R=O[c+1])*L,v+=(B.b=T=O[c+2])*L,y+=(B.a=I=O[c+3])*L,S+=M,C+=R,E+=T,P+=I,B=B.next;for(W=N,q=F,u=0;u<r;u++)O[f+3]=I=y*j>>V,0!=I?(I=255/I,O[f]=(m*j>>V)*I,O[f+1]=(g*j>>V)*I,O[f+2]=(v*j>>V)*I):O[f]=O[f+1]=O[f+2]=0,m-=w,g-=b,v-=k,y-=x,w-=W.r,b-=W.g,k-=W.b,x-=W.a,c=_+((c=u+h+1)<D?c:D)<<2,S+=W.r=O[c],C+=W.g=O[c+1],E+=W.b=O[c+2],P+=W.a=O[c+3],m+=S,g+=C,v+=E,y+=P,W=W.next,w+=M=q.r,b+=R=q.g,k+=T=q.b,x+=I=q.a,S-=M,C-=R,E-=T,P-=I,q=q.next,f+=4;_+=r}for(u=0;u<r;u++){for(C=E=P=S=g=v=y=m=0,f=u<<2,w=U*(M=O[f]),b=U*(R=O[f+1]),k=U*(T=O[f+2]),x=U*(I=O[f+3]),m+=H*M,g+=H*R,v+=H*T,y+=H*I,B=N,p=0;p<U;p++)B.r=M,B.g=R,B.b=T,B.a=I,B=B.next;for(d=r,p=1;p<=h;p++)f=d+u<<2,m+=(B.r=M=O[f])*(L=U-p),g+=(B.g=R=O[f+1])*L,v+=(B.b=T=O[f+2])*L,y+=(B.a=I=O[f+3])*L,S+=M,C+=R,E+=T,P+=I,B=B.next,p<A&&(d+=r);for(f=u,W=N,q=F,l=0;l<s;l++)c=f<<2,O[c+3]=I=y*j>>V,I>0?(I=255/I,O[c]=(m*j>>V)*I,O[c+1]=(g*j>>V)*I,O[c+2]=(v*j>>V)*I):O[c]=O[c+1]=O[c+2]=0,m-=w,g-=b,v-=k,y-=x,w-=W.r,b-=W.g,k-=W.b,x-=W.a,c=u+((c=l+U)<A?c:A)*r<<2,m+=S+=W.r=O[c],g+=C+=W.g=O[c+1],v+=E+=W.b=O[c+2],y+=P+=W.a=O[c+3],W=W.next,w+=M=q.r,b+=R=q.g,k+=T=q.b,x+=I=q.a,S-=M,C-=R,E-=T,P-=I,q=q.next,f+=r}return t}function n(){this.r=0,this.g=0,this.b=0,this.a=0,this.next=null}var o=[512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],a=[9,11,12,13,13,14,14,15,15,15,15,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24];return e}();HTMLCanvasElement.prototype.toBlob||Object.defineProperty(HTMLCanvasElement.prototype,"toBlob",{value:function(t,e,i){for(var n=atob(this.toDataURL(e,i).split(",")[1]),o=n.length,a=new Uint8Array(o),r=0;r<o;r++)a[r]=n.charCodeAt(r);t(new Blob([a],{type:e||"image/png"}))}});var p=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},d=null,f=function(){return null===d&&(d=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream),d},_=function(t){if("undefined"==typeof t.dataset){var e,i,n={},o=t.attributes;for(e in o)o.hasOwnProperty(e)&&o[e].name&&/^data-[a-z_\-\d]*$/i.test(o[e].name)&&(i=m(o[e].name.substr(5)),n[i]=o[e].value);return n}return t.dataset},m=function(t){return t.replace(/\-./g,function(t){return t.charAt(1).toUpperCase()})},g=function(t){for(var e=[],i=Array.prototype.slice.call(t.attributes),n=i.length,o=0;o<n;o++)e.push({name:i[o].name,value:i[o].value});return e},v=function(t){return{x:"undefined"==typeof t.offsetX?t.layerX:t.offsetX,y:"undefined"==typeof t.offsetY?t.layerY:t.offsetY}},y=function(t,e){var i,n={},o=e||{};for(i in t)t.hasOwnProperty(i)&&(n[i]="undefined"==typeof o[i]?t[i]:o[i]);return n},w={ESC:27,RETURN:13},b={DOWN:["touchstart","pointerdown","mousedown"],MOVE:["touchmove","pointermove","mousemove"],UP:["touchend","touchcancel","pointerup","mouseup"]},k={jpeg:"image/jpeg",jpg:"image/jpeg",jpe:"image/jpeg",png:"image/png",gif:"image/gif",bmp:"image/bmp"},x=/(\.png|\.bmp|\.gif|\.jpg|\.jpe|\.jpg|\.jpeg)$/,S=function(t,e){var i=document.createElement(t);return e&&(i.className=e),i},C=function(t,e,i){e.forEach(function(e){t.addEventListener(e,i,!1)})},E=function(t,e,i){e.forEach(function(e){t.removeEventListener(e,i,!1)})},P=function(t){var e=t.changedTouches?t.changedTouches[0]:t;if(e)return{x:e.pageX,y:e.pageY}},M=function(t,e){var i=.5,n=.5,o=Math.PI/180*e,a=Math.cos(o),r=Math.sin(o),s=t.x,h=t.y,u=t.x+t.width,l=t.y+t.height,p=a*(s-i)+r*(h-n)+i,c=a*(h-n)-r*(s-i)+n,d=a*(u-i)+r*(l-n)+i,f=a*(l-n)-r*(u-i)+n;p<=d?(t.x=p,t.width=d-p):(t.x=d,t.width=p-d),c<=f?(t.y=c,t.height=f-c):(t.y=f,t.height=c-f)},R=function(t){var e=P(t);return e.x-=window.pageXOffset||document.documentElement.scrollLeft,e.y-=window.pageYOffset||document.documentElement.scrollTop,e},T=function(t){return t.charAt(0).toLowerCase()+t.slice(1)},I=function(t){return t.charAt(0).toUpperCase()+t.slice(1)},L=function(t){return t[t.length-1]},O=function(t,e,i){return Math.max(e,Math.min(i,t))},z=function(t,e){if(!e)return!1;for(var i=0;i<e.length;i++)if(e[i]===t)return!0;return!1},D=function(t){var i=arguments.length>1&&arguments[1]!==e?arguments[1]:"POST",n=arguments[2],o=arguments[3],a=arguments[4],r=arguments[5],s=arguments[6],h=new XMLHttpRequest;a&&h.upload.addEventListener("progress",function(t){a(t.loaded,t.total)}),h.open(i,t,!0),o&&o(h,n),h.onreadystatechange=function(){if(4===h.readyState&&h.status>=200&&h.status<300){var t=h.responseText;if(!t.length)return void r();if(t.indexOf("Content-Length")!==-1)return void s("file-too-big");var e=void 0;try{e=JSON.parse(h.responseText)}catch(i){}if("object"===("undefined"==typeof e?"undefined":c(e))&&"failure"===e.status)return void s(e.message);r(e||t)}else if(4===h.readyState){var n=void 0;try{n=JSON.parse(h.responseText)}catch(i){}if("object"===("undefined"==typeof n?"undefined":c(n))&&"failure"===n.status)return void s(n.message);s("fail")}},h.send(n)},A=function(t){t&&(t.style.webkitTransform="",t.style.transform="")},U=function(t){return t/1e6},H=function(){var t=[],e=void 0,i=void 0;for(e in k)k.hasOwnProperty(e)&&(i=k[e],t.indexOf(i)==-1&&t.push(i));return t},N=function(t){return"image/jpeg"===t},B=function(t){var e=void 0;for(e in k)if(k.hasOwnProperty(e)&&k[e]===t)return e;return t},F=function(t){var e=void 0;for(e in k)if(k.hasOwnProperty(e)&&t.indexOf(k[e])!==-1)return k[e];return null},W=function(t){return t.split("/").pop().split("?").shift()},q=function(t){var i=arguments.length>1&&arguments[1]!==e?arguments[1]:"";return(i+t).slice(-i.length)},j=function(t){return t.getFullYear()+"-"+q(t.getMonth()+1,"00")+"-"+q(t.getDate(),"00")+"_"+q(t.getHours(),"00")+"-"+q(t.getMinutes(),"00")+"-"+q(t.getSeconds(),"00")},V=function(t){return"undefined"==typeof t.name?j(new Date)+"."+B(G(t)):t.name},G=function(t){return t.type||"image/jpeg"},X=function(t){if("string"!=typeof t)return j(new Date);var e=W(t);return e.split(".").shift()},Y=function(t,e){try{var i=new File([t],e,{type:t.type,lastModified:Date.now()});if(i.size>0)return i}catch(n){}return t.lastModifiedDate=new Date,t.lastModified=new Date,t.name=e,t},J=function(t){return/^data:image/.test(t)},$=function(t,e,i,n,o,a){t=""+t+(t.indexOf("?")!==-1?"&":"?")+"url="+n;var r=new XMLHttpRequest;r.open("GET",t,!0),e(r),r.responseType="json",r.onload=function(){return"failure"===this.response.status?void o(this.response.message):void Z(this.response.body,i,a)},r.send()},Z=function(t,e,i,n){var o=new XMLHttpRequest;o.open("GET",t,!0),e(o),o.responseType="blob",o.onload=function(e){if(o.status>=200&&o.status<300||0===o.status&&this.response instanceof Blob){var a=W(t),r=F(this.response.type);x.test(a)||(a+="."+B(r));var s=Y(this.response,a);i(vt(s,r))}else n(o.status+": "+o.statusText)},o.onerror=function(){n()},o.send()},K=function(t){var e=t.split(",")[1],i=e.replace(/\s/g,"");return atob(i)},Q=function(t,e){for(var i=K(t),n=new ArrayBuffer(i.length),o=new Uint8Array(n),a=0;a<i.length;a++)o[a]=i.charCodeAt(a);var r=bt(t);return"undefined"==typeof e&&(e=j(new Date)+"."+B(r)),Y(tt(n,r),e)},tt=function(t,e){var i=window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder;if(i){var n=new i;return n.append(t),n.getBlob(e)}return new Blob([t],{type:e})},et=function(t,e,i){var o="string"!=typeof t||0!==t.indexOf("data:image");n.parseMetaData(t,function(a){var r={canvas:!0,crossOrigin:o};e&&(r.maxWidth=e.width,r.maxHeight=e.height),a.exif&&(r.orientation=a.exif.get("Orientation")),
n(t,function(t){return"error"===t.type?void i():void i(t,a)},r)})},it=function(t,e,i){var n,o,a,r,s=e/t;return s<i?(r=e,a=r/i,n=.5*(t-a),o=0):(a=t,r=a*i,n=0,o=.5*(e-r)),{x:n,y:o,height:r,width:a}},nt=function(t){var n=arguments.length>1&&arguments[1]!==e?arguments[1]:{},o=arguments[2],a=S("canvas"),r=n.rotation,s=n.crop,h=n.size,u=n.filters,l=n.minSize;if(s){var p=r%180!==0,c={width:p?t.height:t.width,height:p?t.width:t.height};s.x<0&&(s.x=0),s.y<0&&(s.y=0),s.width>c.width&&(s.width=c.width),s.height>c.height&&(s.height=c.height),s.y+s.height>c.height&&(s.y=Math.max(0,c.height-s.height)),s.x+s.width>c.width&&(s.x=Math.max(0,c.width-s.width));var d=s.x/c.width,f=s.y/c.height,_=s.width/c.width,m=s.height/c.height;a.width=Math.round(s.width),a.height=Math.round(s.height);var g=a.getContext("2d");90===r?(g.translate(.5*a.width,.5*a.height),g.rotate(-90*Math.PI/180),g.drawImage(t,(1-f)*t.width-t.width*m,s.x,s.height,s.width,.5*-a.height,.5*-a.width,a.height,a.width)):180===r?(g.translate(.5*a.width,.5*a.height),g.rotate(-180*Math.PI/180),g.drawImage(t,(1-(d+_))*c.width,(1-(f+m))*c.height,_*c.width,m*c.height,.5*-a.width,.5*-a.height,a.width,a.height)):270===r?(g.translate(.5*a.width,.5*a.height),g.rotate(-270*Math.PI/180),g.drawImage(t,s.y,(1-d)*t.height-t.height*_,s.height,s.width,.5*-a.height,.5*-a.width,a.height,a.width)):g.drawImage(t,s.x,s.y,s.width,s.height,0,0,a.width,a.height)}if(h){var v=h.width/a.width,y=h.height/a.height,w=Math.min(v,y);i(a,w,h,l),u.sharpen>0&&at(a,st(u.sharpen))}o(a)},ot=function(t){var e=t.getContext("2d");return e.getImageData(0,0,t.width,t.height)},at=function(t,e){var i=t.getContext("2d");i.putImageData(e(ot(t),t.width,t.height),0,0)},rt=function(t,e,i){var n=document.createElement("canvas");n.width=t,n.height=e;var o=n.getContext("2d"),a=o.createImageData(n.width,n.height);return i&&a.set(i.data),a},st=function(t){return function(e,i,n){for(var o=[0,-1,0,-1,5,-1,0,-1,0],a=Math.round(Math.sqrt(o.length)),r=.5*a|0,s=rt(i,n),h=s.data,u=e.data,l=n,p=void 0;l--;)for(p=i;p--;){for(var c=l,d=p,f=4*(l*i+p),_=0,m=0,g=0,v=0,y=0;y<a;y++)for(var w=0;w<a;w++){var b=c+y-r,k=d+w-r;if(b>=0&&b<n&&k>=0&&k<i){var x=4*(b*i+k),S=o[y*a+w];_+=u[x]*S,m+=u[x+1]*S,g+=u[x+2]*S,v+=u[x+3]*S}}h[f]=_*t+u[f]*(1-t),h[f+1]=m*t+u[f+1]*(1-t),h[f+2]=g*t+u[f+2]*(1-t),h[f+3]=u[f+3]}return s}},ht=function(t,e){var i=Math.abs(t.width-e.width),n=Math.abs(t.height-e.height);return Math.max(i,n)},ut=function(t,e){if(!t)return null;var n=document.createElement("canvas"),o=n.getContext("2d");return n.width=t.width,n.height=t.height,o.drawImage(t,0,0),e>0&&1!==e&&i(n,e,{width:Math.round(t.width*e),height:Math.round(t.height*e)},{width:0,height:0}),n},lt=function(t){return t.width&&t.height},pt=function(t,e){var i=e.getContext("2d");lt(e)?i.drawImage(t,0,0,e.width,e.height):(e.width=t.width,e.height=t.height,i.drawImage(t,0,0))},ct=function(t){l(t,0,0,t.width,t.height,3)},dt=function(t,e){return parseInt(t.width,10)>=e.width&&parseInt(t.height,10)>=e.height},ft=function(t,e,i){return{x:t.x*e,y:t.y*i,width:t.width*e,height:t.height*i}},_t=function(t,e,i){return{x:t.x/e,y:t.y/i,width:t.width/e,height:t.height/i}},mt=function(t){if(t&&""!==t.value){try{t.value=""}catch(e){}if(t.value){var i=document.createElement("form"),n=t.parentNode,o=t.nextSibling;i.appendChild(t),i.reset(),o?n.insertBefore(t,o):n.appendChild(t)}}},gt=function(t){return"object"===("undefined"==typeof value?"undefined":c(value))&&null!==value?JSON.parse(JSON.stringify(t)):t},vt=function(t){var i=arguments.length>1&&arguments[1]!==e?arguments[1]:null;if(!t)return null;var n=t.slice(0,t.size,i||t.type);return n.name=t.name,n.lastModified=new Date(t.lastModified),n},yt=function(t){var e=gt(t);return e.input.file=vt(t.input.file),e.output.image=t.output.image,e},wt=function(t,i,n){if(!t||!i)return null;var o=t;return"IMG"===t.nodeName&&(o=document.createElement("canvas"),o.width=t.width,o.height=t.height,o.getContext("2d").drawImage(t,0,0)),o.toDataURL(i,N(i)&&"number"==typeof n?n/100:e)},bt=function(t){if(!t)return null;var e=t.substr(0,16).match(/^.+;/);return e.length?e[0].substring(5,e[0].length-1):null},kt=function(t){var i=arguments.length>1&&arguments[1]!==e?arguments[1]:[],n=arguments[2],o=arguments[3],a=arguments[4],r={server:gt(t.server),meta:gt(t.meta),input:{name:t.input.name,type:t.input.type,size:t.input.size,width:t.input.width,height:t.input.height,field:t.input.field}};return z("input",i)&&!a&&(r.input.image=wt(t.input.image,t.input.type)),z("output",i)&&(r.output={name:o?X(t.input.name)+"."+o:t.input.name,type:k[o]||t.input.type,width:t.output.width,height:t.output.height},r.output.image=wt(t.output.image,r.output.type,n),r.output.type=bt(r.output.image),"image/png"===r.output.type&&(r.output.name=X(r.input.name)+".png")),z("actions",i)&&(r.actions=gt(t.actions)),r},xt=function(t,i,n){var o=t.output.image,a=n?X(t.input.name)+"."+n:t.input.name,r=k[n]||t.input.type;"image/png"===r&&(a=X(t.input.name)+".png"),o.toBlob(function(t){if("msSaveBlob"in window.navigator)return void window.navigator.msSaveBlob(t,a);var e=(window.URL||window.webkitURL).createObjectURL(t),i=S("a");i.style.display="none",i.download=a,i.href=e,document.body.appendChild(i),i.click(),setTimeout(function(){document.body.removeChild(i),(window.URL||window.webkitURL).revokeObjectURL(e)},0)},r,"number"==typeof i?i/100:e)},St=function(t,e,i){var n=i.querySelector(t);n&&(n.style.display=e?"":"none")},Ct=function(t){return Array.prototype.slice.call(t)},Et=function(t){t.parentNode.removeChild(t)},Pt=function(t){var e=S("div");return t.parentNode&&(t.nextSibling?t.parentNode.insertBefore(e,t.nextSibling):t.parentNode.appendChild(e)),e.appendChild(t),e},Mt=function(t,e,i,n){var o=(n-90)*Math.PI/180;return{x:t+i*Math.cos(o),y:e+i*Math.sin(o)}},Rt=function(t,e,i,n,o){var a=Mt(t,e,i,o),r=Mt(t,e,i,n),s=o-n<=180?"0":"1",h=["M",a.x,a.y,"A",i,i,0,s,0,r.x,r.y].join(" ");return h},Tt=function(t,e,i,n){return Rt(t,e,i,0,360*n)},It=function(){var i={n:function(t,e,i,n){var o,a,r,s,h,u,l,p;return r=t.y+t.height,o=O(e.y,0,r),r-o<i.min.height&&(o=r-i.min.height),h=n?(r-o)/n:t.width,h<i.min.width&&(h=i.min.width,o=r-h*n),l=.5*(h-t.width),s=t.x-l,a=t.x+t.width+l,(s<0||Math.round(a)>Math.round(i.width))&&(p=Math.min(t.x,i.width-(t.x+t.width)),s=t.x-p,a=t.x+t.width+p,h=a-s,u=h*n,o=r-u),{x:s,y:o,width:a-s,height:r-o}},s:function(t,e,i,n){var o,a,r,s,h,u,l,p;return o=t.y,r=O(e.y,o,i.height),r-o<i.min.height&&(r=o+i.min.height),h=n?(r-o)/n:t.width,h<i.min.width&&(h=i.min.width,r=o+h*n),l=.5*(h-t.width),s=t.x-l,a=t.x+t.width+l,(s<0||Math.round(a)>Math.round(i.width))&&(p=Math.min(t.x,i.width-(t.x+t.width)),s=t.x-p,a=t.x+t.width+p,h=a-s,u=h*n,r=o+u),{x:s,y:o,width:a-s,height:r-o}},e:function(t,e,i,n){var o,a,r,s,h,u,l,p;return s=t.x,a=O(e.x,s,i.width),a-s<i.min.width&&(a=s+i.min.width),u=n?(a-s)*n:t.height,u<i.min.height&&(u=i.min.height,a=s+u/n),l=.5*(u-t.height),o=t.y-l,r=t.y+t.height+l,(o<0||Math.round(r)>Math.round(i.height))&&(p=Math.min(t.y,i.height-(t.y+t.height)),o=t.y-p,r=t.y+t.height+p,u=r-o,h=u/n,a=s+h),{x:s,y:o,width:a-s,height:r-o}},w:function n(t,e,i,o){var a,r,s,h,n,u,l,p;return r=t.x+t.width,h=O(e.x,0,r),r-h<i.min.width&&(h=r-i.min.width),u=o?(r-h)*o:t.height,u<i.min.height&&(u=i.min.height,h=r-u/o),l=.5*(u-t.height),a=t.y-l,s=t.y+t.height+l,(a<0||Math.round(s)>Math.round(i.height))&&(p=Math.min(t.y,i.height-(t.y+t.height)),a=t.y-p,s=t.y+t.height+p,u=s-a,n=u/o,h=r-n),{x:h,y:a,width:r-h,height:s-a}},ne:function(t,e,i,n){var o,a,r,s,h,u,l;return s=t.x,r=t.y+t.height,a=O(e.x,s,i.width),a-s<i.min.width&&(a=s+i.min.width),u=n?(a-s)*n:O(r-e.y,i.min.height,r),u<i.min.height&&(u=i.min.height,a=s+u/n),o=t.y-(u-t.height),(o<0||Math.round(r)>Math.round(i.height))&&(l=Math.min(t.y,i.height-(t.y+t.height)),o=t.y-l,u=r-o,h=u/n,a=s+h),{x:s,y:o,width:a-s,height:r-o}},se:function(t,e,i,n){var o,a,r,s,h,u,l;return s=t.x,o=t.y,a=O(e.x,s,i.width),a-s<i.min.width&&(a=s+i.min.width),u=n?(a-s)*n:O(e.y-t.y,i.min.height,i.height-o),u<i.min.height&&(u=i.min.height,a=s+u/n),r=t.y+t.height+(u-t.height),(o<0||Math.round(r)>Math.round(i.height))&&(l=Math.min(t.y,i.height-(t.y+t.height)),r=t.y+t.height+l,u=r-o,h=u/n,a=s+h),{x:s,y:o,width:a-s,height:r-o}},sw:function(t,e,i,n){var o,a,r,s,h,u,l;return a=t.x+t.width,o=t.y,s=O(e.x,0,a),a-s<i.min.width&&(s=a-i.min.width),u=n?(a-s)*n:O(e.y-t.y,i.min.height,i.height-o),u<i.min.height&&(u=i.min.height,s=a-u/n),r=t.y+t.height+(u-t.height),(o<0||Math.round(r)>Math.round(i.height))&&(l=Math.min(t.y,i.height-(t.y+t.height)),r=t.y+t.height+l,u=r-o,h=u/n,s=a-h),{x:s,y:o,width:a-s,height:r-o}},nw:function(t,e,i,n){var o,a,r,s,h,u,l;return a=t.x+t.width,r=t.y+t.height,s=O(e.x,0,a),a-s<i.min.width&&(s=a-i.min.width),u=n?(a-s)*n:O(r-e.y,i.min.height,r),u<i.min.height&&(u=i.min.height,s=a-u/n),o=t.y-(u-t.height),(o<0||Math.round(r)>Math.round(i.height))&&(l=Math.min(t.y,i.height-(t.y+t.height)),o=t.y-l,u=r-o,h=u/n,s=a-h),{x:s,y:o,width:a-s,height:r-o}}};return function(){function n(){var i=arguments.length>0&&arguments[0]!==e?arguments[0]:document.createElement("div");t(this,n),this._element=i,this._interaction=null,this._minWidth=1,this._minHeight=1,this._ratio=null,this._rect={x:0,y:0,width:0,height:0},this._space={width:0,height:0},this._rectChanged=!1,this._init()}return p(n,[{key:"_init",value:function(){this._element.className="slim-crop-area";var t=S("div","grid");this._element.appendChild(t);for(var e in i)if(i.hasOwnProperty(e)){var n=S("button",e);this._element.appendChild(n)}var o=S("button","c");this._element.appendChild(o),C(document,b.DOWN,this)}},{key:"reset",value:function(){this._interaction=null,this._rect={x:0,y:0,width:0,height:0},this._rectChanged=!0,this._redraw(),this._element.dispatchEvent(new CustomEvent("change"))}},{key:"rescale",value:function(t){1!==t&&(this._interaction=null,this._rectChanged=!0,this._rect.x*=t,this._rect.y*=t,this._rect.width*=t,this._rect.height*=t,this._redraw(),this._element.dispatchEvent(new CustomEvent("change")))}},{key:"limit",value:function(t,e){this._space.width=t,this._space.height=e}},{key:"offset",value:function(t,e){this._space.x=t,this._space.y=e}},{key:"resize",value:function(t,e,i,n){this._interaction=null,this._rect={x:O(t,0,this._space.width-this._minWidth),y:O(e,0,this._space.height-this._minHeight),width:O(i,this._minWidth,this._space.width),height:O(n,this._minHeight,this._space.height)},this._rectChanged=!0,this._redraw(),this._element.dispatchEvent(new CustomEvent("change"))}},{key:"handleEvent",value:function(t){switch(t.type){case"touchstart":case"pointerdown":case"mousedown":this._onStartDrag(t);break;case"touchmove":case"pointermove":case"mousemove":this._onDrag(t);break;case"touchend":case"touchcancel":case"pointerup":case"mouseup":this._onStopDrag(t)}}},{key:"_onStartDrag",value:function(t){this._element.contains(t.target)&&(t.preventDefault(),C(document,b.MOVE,this),C(document,b.UP,this),this._interaction={type:t.target.className,offset:R(t)},this._interaction.offset.x-=this._rect.x,this._interaction.offset.y-=this._rect.y,this._element.setAttribute("data-dragging","true"),this._redraw())}},{key:"_onDrag",value:function(t){t.preventDefault();var e=R(t),n=this._interaction.type;"c"===n?(this._rect.x=O(e.x-this._interaction.offset.x,0,this._space.width-this._rect.width),this._rect.y=O(e.y-this._interaction.offset.y,0,this._space.height-this._rect.height)):i[n]&&(this._rect=i[n](this._rect,{x:e.x-this._space.x,y:e.y-this._space.y},{x:0,y:0,width:this._space.width,height:this._space.height,min:{width:this._minWidth,height:this._minHeight}},this._ratio)),this._rectChanged=!0,this._element.dispatchEvent(new CustomEvent("input"))}},{key:"_onStopDrag",value:function(t){t.preventDefault(),E(document,b.MOVE,this),E(document,b.UP,this),this._interaction=null,this._element.setAttribute("data-dragging","false"),this._element.dispatchEvent(new CustomEvent("change"))}},{key:"_redraw",value:function(){var t=this;if(this._rectChanged){var e="translate("+this._rect.x+"px,"+this._rect.y+"px);";this._element.style.cssText="\n\t\t\t\t\t-webkit-transform: "+e+";\n\t\t\t\t\ttransform: "+e+";\n\t\t\t\t\twidth:"+this._rect.width+"px;\n\t\t\t\t\theight:"+this._rect.height+"px;\n\t\t\t\t",this._rectChanged=!1}this._interaction&&requestAnimationFrame(function(){return t._redraw()})}},{key:"destroy",value:function(){this._interaction=!1,this._rectChanged=!1,E(document,b.DOWN,this),E(document,b.MOVE,this),E(document,b.UP,this),Et(this._element)}},{key:"element",get:function(){return this._element}},{key:"space",get:function(){return this._space}},{key:"area",get:function(){var t=this._rect.x/this._space.width,e=this._rect.y/this._space.height,i=this._rect.width/this._space.width,n=this._rect.height/this._space.height;return{x:t,y:e,width:i,height:n}}},{key:"dirty",get:function(){return 0!==this._rect.x||0!==this._rect.y||0!==this._rect.width||0!==this._rect.height}},{key:"minWidth",set:function(t){this._minWidth=Math.max(t,1)}},{key:"minHeight",set:function(t){this._minHeight=Math.max(t,1)}},{key:"ratio",set:function(t){this._ratio=t}}]),n}()}(),Lt=function(){var i=["input","change"],n=function(){function n(){var i=arguments.length>0&&arguments[0]!==e?arguments[0]:document.createElement("div"),o=arguments.length>1&&arguments[1]!==e?arguments[1]:{};t(this,n),this._element=i,this._options=y(n.options(),o),this._ratio=null,this._output=null,this._rotating=!1,this._input=null,this._preview=null,this._previewBlurred=null,this._blurredPreview=!1,this._cropper=null,this._straightCrop=null,this._previewWrapper=null,this._currentWindowSize={},this._btnGroup=null,this._maskFrame=null,this._dirty=!1,this._wrapperRotation=0,this._wrapperScale=1,this._init()}return p(n,[{key:"_init",value:function(){var t=this;this._element.className="slim-image-editor",this._container=S("div","slim-container"),this._wrapper=S("div","slim-wrapper"),this._stage=S("div","slim-stage"),this._container.appendChild(this._stage),this._cropper=new It,i.forEach(function(e){t._cropper.element.addEventListener(e,t)}),this._stage.appendChild(this._cropper.element),this._previewWrapper=S("div","slim-image-editor-preview slim-crop-preview"),this._previewBlurred=S("canvas","slim-crop-blur"),this._previewWrapper.appendChild(this._previewBlurred),this._wrapper.appendChild(this._previewWrapper),this._previewMask=S("div","slim-crop-mask"),this._preview=S("img"),this._previewMask.appendChild(this._preview),this._cropper.element.appendChild(this._previewMask),this._btnGroup=S("div","slim-editor-btn-group"),n.Buttons.forEach(function(e){var i=I(e),n=t._options["button"+i+"Label"],o=t._options["button"+i+"Title"],a=t._options["button"+i+"ClassName"],r=S("button","slim-editor-btn slim-btn-"+e+(a?" "+a:""));r.innerHTML=n,r.title=o||n,r.type="button",r.setAttribute("data-action",e),r.addEventListener("click",t),t._btnGroup.appendChild(r)}),this._utilsGroup=S("div","slim-editor-utils-group");var e=S("button","slim-editor-utils-btn slim-btn-rotate"+(this._options.buttonRotateClassName?" "+this._options.buttonRotateClassName:""));e.setAttribute("data-action","rotate"),e.addEventListener("click",this),e.title=this._options.buttonRotateTitle,this._utilsGroup.appendChild(e),this._container.appendChild(this._wrapper),this._element.appendChild(this._container),this._element.appendChild(this._utilsGroup),this._element.appendChild(this._btnGroup)}},{key:"dirty",value:function(){this._dirty=!0}},{key:"handleEvent",value:function(t){switch(t.type){case"click":this._onClick(t);break;case"change":this._onGridChange(t);break;case"input":this._onGridInput(t);break;case"keydown":this._onKeyDown(t);break;case"resize":this._onResize(t)}}},{key:"_onKeyDown",value:function(t){switch(t.keyCode){case w.RETURN:this._confirm();break;case w.ESC:this._cancel()}}},{key:"_onClick",value:function(t){t.target.classList.contains("slim-btn-cancel")&&this._cancel(),t.target.classList.contains("slim-btn-confirm")&&this._confirm(),t.target.classList.contains("slim-btn-rotate")&&this._rotate()}},{key:"_onResize",value:function(){this._currentWindowSize={width:window.innerWidth,height:window.innerHeight},this._redraw(),this._redrawCropper(this._cropper.area),this._updateWrapperScale(),this._redrawWrapper()}},{key:"_redrawWrapper",value:function(){var t=u.createMatrix();t.scale(this._wrapperScale,this._wrapperScale),t.rotateZ(this._wrapperRotation*(Math.PI/180)),u.setElementTransform(this._previewWrapper,t)}},{key:"_onGridInput",value:function(){this._redrawCropMask()}},{key:"_onGridChange",value:function(){this._redrawCropMask()}},{key:"_updateWrapperRotation",value:function(){this._options.minSize.width>this._input.height||this._options.minSize.height>this._input.width?this._wrapperRotation+=180:this._wrapperRotation+=90}},{key:"_updateWrapperScale",value:function(){var t=this._wrapperRotation%180!==0;if(t){var e=this._container.offsetWidth,i=this._container.offsetHeight,n=this._wrapper.offsetHeight,o=this._wrapper.offsetWidth,a=e/n;a*o>i&&(a=i/o),this._wrapperScale=a}else this._wrapperScale=1}},{key:"_cancel",value:function(){this._rotating||this._element.dispatchEvent(new CustomEvent("cancel"))}},{key:"_confirm",value:function(){if(!this._rotating){var t=this._wrapperRotation%180!==0,e=this._cropper.area,i=ft(e,t?this._input.height:this._input.width,t?this._input.width:this._input.height);this._element.dispatchEvent(new CustomEvent("confirm",{detail:{rotation:this._wrapperRotation%360,crop:i}}))}}},{key:"_rotate",value:function(){var t=this;if(!this._rotating){this._rotating=!0,this._updateWrapperRotation();var e=1===this.ratio||null===this._ratio?this._cropper.area:null;e&&M(e,90),this._updateWrapperScale(),this._hideCropper(),u(this._previewWrapper,{rotation:[0,0,this._wrapperRotation*(Math.PI/180)],scale:[this._wrapperScale,this._wrapperScale],easing:"spring",springConstant:.8,springDeceleration:.65,complete:function(){t._redrawCropper(e),t._showCropper(),t._rotating=!1}})}}},{key:"_showCropper",value:function(){u(this._stage,{easing:"ease",duration:250,fromOpacity:0,opacity:1})}},{key:"_hideCropper",value:function(){u(this._stage,{duration:0,fromOpacity:0,opacity:0})}},{key:"_redrawCropMask",value:function(){var t=this,e=this._wrapperRotation%360,i=this._wrapperScale,n={width:this._wrapper.offsetWidth,height:this._wrapper.offsetHeight},o=this._cropper.area,a={x:0,y:0};0===e?(a.x=-o.x,a.y=-o.y):90===e?(a.x=-(1-o.y),a.y=-o.x):180===e?(a.x=-(1-o.x),a.y=-(1-o.y)):270===e&&(a.x=-o.y,a.y=-(1-o.x)),a.x*=n.width,a.y*=n.height,cancelAnimationFrame(this._maskFrame),this._maskFrame=requestAnimationFrame(function(){var n="scale("+i+") rotate("+-e+"deg) translate("+a.x+"px, "+a.y+"px);";t._preview.style.cssText="\n\t\t\t\t\twidth: "+t._previewSize.width+"px;\n\t\t\t\t\theight: "+t._previewSize.height+"px;\n\t\t\t\t\t-webkit-transform: "+n+";\n\t\t\t\t\ttransform: "+n+";\n\t\t\t\t"})}},{key:"open",value:function(t,e,i,n,o){var a=this;if(this._input&&!this._dirty&&this._ratio===e&&this._wrapperRotation===n)return void o();this._currentWindowSize={width:window.innerWidth,height:window.innerHeight},this._dirty=!1,this._wrapperRotation=n||0,this._blurredPreview=!1,this._ratio=e,this._previewSize=null,this._element.style.opacity="0",this._input=t;var r=this._wrapperRotation%180!==0,s=_t(i,r?t.height:t.width,r?t.width:t.height);this._preview.onload=function(){a._preview.onload=null,a._cropper.ratio=a.ratio,a._redraw(),a._redrawCropper(s),o(),a._element.style.opacity=""},this._preview.src="",this._preview.src=ut(this._input,Math.min(this._container.offsetWidth/this._input.width,this._container.offsetHeight/this._input.height)*this._options.devicePixelRatio).toDataURL()}},{key:"_redrawCropper",value:function(t){var e=this._wrapperRotation%180!==0,i=e?this._input.height/this._input.width:this._input.width/this._input.height,n=this._wrapper.offsetWidth,o=this._wrapper.offsetHeight,a=this._container.offsetWidth,r=this._container.offsetHeight;this._updateWrapperScale();var s=this._wrapperScale*(e?o:n),h=this._wrapperScale*(e?n:o),u=e?.5*(a-s):this._wrapper.offsetLeft,l=e?.5*(r-h):this._wrapper.offsetTop;this._stage.style.cssText="\n\t\t\t\tleft:"+u+"px;\n\t\t\t\ttop:"+l+"px;\n\t\t\t\twidth:"+s+"px;\n\t\t\t\theight:"+h+"px;\n\t\t\t",this._cropper.limit(s,s/i),this._cropper.offset(u+this._element.offsetLeft,l+this._element.offsetTop),this._cropper.minWidth=this._wrapperScale*this._options.minSize.width*this.scalar,this._cropper.minHeight=this._wrapperScale*this._options.minSize.height*this.scalar;var p=null;p=t?{x:t.x*s,y:t.y*h,width:t.width*s,height:t.height*h}:it(s,h,this._ratio||h/s),this._cropper.resize(p.x,p.y,p.width,p.height)}},{key:"_redraw",value:function(){var t=this._input.height/this._input.width,e=this._container.clientWidth,i=this._container.clientHeight,n=e,o=n*t;o>i&&(o=i,n=o/t),n=Math.round(n),o=Math.round(o);var a=(e-n)/2,r=(i-o)/2;this._wrapper.style.cssText="\n\t\t\t\tleft:"+a+"px;\n\t\t\t\ttop:"+r+"px;\n\t\t\t\twidth:"+n+"px;\n\t\t\t\theight:"+o+"px;\n\t\t\t",this._previewBlurred.style.cssText="\n\t\t\t\twidth:"+n+"px;\n\t\t\t\theight:"+o+"px;\n\t\t\t",this._preview.style.cssText="\n\t\t\t\twidth:"+n+"px;\n\t\t\t\theight:"+o+"px;\n\t\t\t",this._previewSize={width:n,height:o},this._blurredPreview||(this._previewBlurred.width=300,this._previewBlurred.height=this._previewBlurred.width*t,pt(this._input,this._previewBlurred),ct(this._previewBlurred,3),this._blurredPreview=!0)}},{key:"show",value:function(){var t=arguments.length>0&&arguments[0]!==e?arguments[0]:function(){};this._currentWindowSize.width===window.innerWidth&&this._currentWindowSize.height===window.innerHeight||(this._redraw(),this._redrawCropper(this._cropper.area)),document.addEventListener("keydown",this),window.addEventListener("resize",this);var i=this._wrapperRotation*(Math.PI/180);u(this._previewWrapper,{fromRotation:[0,0,i],rotation:[0,0,i],fromPosition:[0,0,0],position:[0,0,0],fromOpacity:0,opacity:1,fromScale:[this._wrapperScale-.02,this._wrapperScale-.02],scale:[this._wrapperScale,this._wrapperScale],easing:"spring",springConstant:.3,springDeceleration:.85,delay:450,complete:function(){}}),this._cropper.dirty?u(this._stage,{fromPosition:[0,0,0],position:[0,0,0],fromOpacity:0,opacity:1,duration:250,delay:850,complete:function(){A(this),t()}}):u(this._stage,{fromPosition:[0,0,0],position:[0,0,0],fromOpacity:0,opacity:1,duration:250,delay:1e3,complete:function(){A(this)}}),u(this._btnGroup.childNodes,{fromScale:[.9,.9],scale:[1,1],fromOpacity:0,opacity:1,delay:function(t){return 1e3+100*t},easing:"spring",springConstant:.3,springDeceleration:.85,complete:function(){A(this)}}),u(this._utilsGroup.childNodes,{fromScale:[.9,.9],scale:[1,1],fromOpacity:0,opacity:1,easing:"spring",springConstant:.3,springDeceleration:.85,delay:1250,complete:function(){A(this)}})}},{key:"hide",value:function(){var t=arguments.length>0&&arguments[0]!==e?arguments[0]:function(){};document.removeEventListener("keydown",this),window.removeEventListener("resize",this),u(this._utilsGroup.childNodes,{fromOpacity:1,opacity:0,duration:250}),u(this._btnGroup.childNodes,{fromOpacity:1,opacity:0,delay:200,duration:350}),u([this._stage,this._previewWrapper],{fromPosition:[0,0,0],position:[0,-250,0],fromOpacity:1,opacity:0,easing:"spring",springConstant:.3,springDeceleration:.75,delay:250,allDone:function(){t()}})}},{key:"destroy",value:function(){var t=this;Ct(this._btnGroup.children).forEach(function(e){e.removeEventListener("click",t)}),i.forEach(function(e){t._cropper.element.removeEventListener(e,t)}),this._cropper.destroy(),this._element.parentNode&&Et(this._element)}},{key:"showRotateButton",set:function(t){t?this._element.classList.remove("slim-rotation-disabled"):this._element.classList.add("slim-rotation-disabled")}},{key:"element",get:function(){return this._element}},{key:"ratio",get:function(){return"input"===this._ratio?this._input.height/this._input.width:this._ratio}},{key:"offset",get:function(){return this._element.getBoundingClientRect()}},{key:"original",get:function(){return this._input}},{key:"scalar",get:function(){return this._previewSize.width/this._input.width}}],[{key:"options",value:function(){return{buttonCancelClassName:null,buttonConfirmClassName:null,buttonCancelLabel:"Cancel",buttonConfirmLabel:"Confirm",buttonCancelTitle:null,buttonConfirmTitle:null,buttonRotateTitle:"Rotate",buttonRotateClassName:null,devicePixelRatio:null,minSize:{width:0,height:0}}}}]),n}();return n.Buttons=["cancel","confirm"],n}(It),Ot=function(){var i=["dragenter","dragover","dragleave","drop"];return function(){function n(){var i=arguments.length>0&&arguments[0]!==e?arguments[0]:document.createElement("div");t(this,n),this._element=i,this._accept=[],this._allowURLs=!1,this._dragPath=null,this._init()}return p(n,[{key:"isValidDataTransfer",value:function(t){return t.files&&t.files.length?this.areValidDataTransferFiles(t.files):t.items&&t.items.length?this.areValidDataTransferItems(t.items):null}},{key:"areValidDataTransferFiles",value:function(t){return!this._accept.length||!t||this._accept.indexOf(t[0].type)!==-1}},{key:"areValidDataTransferItems",value:function(t){return!this._accept.length||!t||(this._allowURLs&&"string"===t[0].kind?null:t[0].type&&0===t[0].type.indexOf("application")?null:this._accept.indexOf(t[0].type)!==-1)}},{key:"reset",value:function(){this._element.files=null}},{key:"_init",value:function(){var t=this;this._element.className="slim-file-hopper",i.forEach(function(e){t._element.addEventListener(e,t)})}},{key:"handleEvent",value:function(t){switch(t.type){case"dragenter":case"dragover":this._onDragOver(t);break;case"dragleave":this._onDragLeave(t);break;case"drop":this._onDrop(t)}}},{key:"_onDrop",value:function(t){t.preventDefault();var e=null;if(this._allowURLs){var i=void 0,n=void 0;try{i=t.dataTransfer.getData("url"),n=t.dataTransfer.getData("text/html")}catch(t){}if(n&&n.length){var o=n.match(/src\s*=\s*"(.+?)"/);o&&(e=o[1])}else i&&i.length&&(e=i)}if(e)this._element.files=[{remote:e}];else{var a=this.isValidDataTransfer(t.dataTransfer);if(!a)return this._element.dispatchEvent(new CustomEvent("file-invalid-drop")),void(this._dragPath=null);this._element.files=t.dataTransfer.files}this._element.dispatchEvent(new CustomEvent("file-drop",{detail:v(t)})),this._element.dispatchEvent(new CustomEvent("change")),this._dragPath=null}},{key:"_onDragOver",value:function(t){t.preventDefault(),t.dataTransfer.dropEffect="copy";var e=this.isValidDataTransfer(t.dataTransfer);return null===e||e?(this._dragPath||(this._dragPath=[]),this._dragPath.push(v(t)),void this._element.dispatchEvent(new CustomEvent("file-over",{detail:{x:L(this._dragPath).x,y:L(this._dragPath).y}}))):(t.dataTransfer.dropEffect="none",void this._element.dispatchEvent(new CustomEvent("file-invalid")))}},{key:"_onDragLeave",value:function(t){this._element.dispatchEvent(new CustomEvent("file-out",{detail:v(t)})),this._dragPath=null}},{key:"destroy",value:function(){var t=this;i.forEach(function(e){t._element.removeEventListener(e,t)}),Et(this._element),this._element=null,this._dragPath=null,this._accept=null}},{key:"element",get:function(){return this._element}},{key:"dragPath",get:function(){return this._dragPath}},{key:"enabled",get:function(){return""===this._element.style.display},set:function(t){this._element.style.display=t?"":"none"}},{key:"allowURLs",set:function(t){this._allowURLs=t}},{key:"accept",set:function(t){this._accept=t},get:function(){return this._accept}}]),n}()}(),zt=function(){return function(){function i(){t(this,i),this._element=null,this._inner=null,this._init()}return p(i,[{key:"_init",value:function(){this._element=S("div","slim-popover"),this._element.setAttribute("data-state","off"),document.body.appendChild(this._element),this._element.addEventListener("touchmove",function(t){t.preventDefault()},!0)}},{key:"show",value:function(){var t=this,i=arguments.length>0&&arguments[0]!==e?arguments[0]:function(){};this._element.setAttribute("data-state","on"),u(this._element,{fromOpacity:0,opacity:1,duration:350,complete:function(){A(t._element),i()}})}},{key:"hide",value:function(){var t=this,i=arguments.length>0&&arguments[0]!==e?arguments[0]:function(){};u(this._element,{fromOpacity:1,opacity:0,duration:500,complete:function(){A(t._element),t._element.setAttribute("data-state","off"),i()}})}},{key:"destroy",value:function(){this._element.parentNode&&(this._element.parentNode.removeChild(this._element),this._element=null,this._inner=null)}},{key:"inner",set:function(t){this._inner=t,this._element.firstChild&&this._element.removeChild(this._element.firstChild),this._element.appendChild(this._inner)}},{key:"className",set:function(t){this._element.className="slim-popover"+(null===t?"":" "+t)}}]),i}()}(),Dt=function(t,e){return t.split(e).map(function(t){return parseInt(t,10)})},At=function(t){return"DIV"===t.nodeName||"SPAN"===t.nodeName},Ut={AUTO:"auto",INITIAL:"initial",MANUAL:"manual"},Ht=["x","y","width","height"],Nt=["file-invalid-drop","file-invalid","file-drop","file-over","file-out","click"],Bt=["cancel","confirm"],Ft=["remove","edit","download","upload"],Wt=null,qt=0,jt='\n<div class="slim-loader">\n\t<svg>\n\t\t<path class="slim-loader-background" fill="none" stroke-width="3" />\n\t\t<path class="slim-loader-foreground" fill="none" stroke-width="3" />\n\t</svg>\n</div>\n',Vt='\n<div class="slim-upload-status"></div>\n',Gt=function(t){var e=t.split(",");return{width:parseInt(e[0],10),height:parseInt(e[1],10)}},Xt=function(t,e){var i=t.indexOf(e);t.splice(i,1)},Yt=function(){function i(n){var o=arguments.length>1&&arguments[1]!==e?arguments[1]:{};t(this,i),Wt||(Wt=new zt),this._uid=qt++,this._options=y(i.options(),o),this._options.forceSize&&("string"==typeof this._options.forceSize&&(this._options.forceSize=Gt(this._options.forceSize)),this._options.ratio=this._options.forceSize.width+":"+this._options.forceSize.height,this._options.size=gt(this._options.forceSize)),"string"==typeof this._options.size&&(this._options.size=Gt(this._options.size)),"string"==typeof this._options.minSize&&(this._options.minSize=Gt(this._options.minSize)),"string"==typeof this._options.post&&(this._options.post=this._options.post.split(",").map(function(t){return t.trim()})),this._originalElement=n,this._originalElementInner=n.innerHTML,this._originalElementAttributes=g(n),At(n)?this._element=n:(this._element=Pt(n),this._element.className=n.className,n.className="",this._element.setAttribute("data-ratio",this._options.ratio)),this._element.classList.add("slim"),this._element.setAttribute("data-state","init"),this._state=[],this._timers=[],this._input=null,this._inputReference=null,this._output=null,this._ratio=null,this._isRequired=!1,this._imageHopper=null,this._imageEditor=null,this._progressEnabled=!0,this._data={},this._resetData(),this._drip=null,this._hasInitialImage=!1,this._initialCrop=this._options.crop,this._initialRotation=this._options.rotation&&this._options.rotation%90===0?this._options.rotation:null,this._isBeingDestroyed=!1,i.supported?this._init():this._fallback()}return p(i,[{key:"setRotation",value:function(t,e){if("number"==typeof t||t%90===0){this._data.actions.rotation=t;var i=this._data.actions.rotation%180!==0;if(this._data.input.image){var n=i?this._data.input.image.height:this._data.input.image.width,o=i?this._data.input.image.width:this._data.input.image.height;this._data.actions.crop=it(n,o,this._ratio),this._data.actions.crop.type=Ut.AUTO}this._data.input.image&&e&&this._manualTransform(e)}}},{key:"setSize",value:function(t,e){"string"==typeof t&&(t=Gt(t)),t&&t.width&&t.height&&(this._options.size=gt(t),this._data.actions.size=gt(t),this._data.input.image&&e&&this._manualTransform(e))}},{key:"setForceSize",value:function(t,e){"string"==typeof t&&(t=Gt(t)),t&&t.width&&t.height&&(this._options.size=gt(t),this._options.forceSize=gt(t),this._data.actions.size=gt(t),this.setRatio(this._options.forceSize.width+":"+this._options.forceSize.height,e))}},{key:"setRatio",value:function(t,e){var i=this;if(t&&"string"==typeof t&&(this._options.ratio=t,this._isFixedRatio())){
var n=Dt(this._options.ratio,":");this._ratio=n[1]/n[0],this._data.input.image&&e?this._cropAuto(function(t){i._scaleDropArea(i._ratio),e&&e(t)}):(this._data.input.image&&(this._data.actions.crop=it(this._data.input.image.width,this._data.input.image.height,this._ratio),this._data.actions.crop.type=Ut.AUTO),this._scaleDropArea(this._ratio),e&&e(null))}}},{key:"isAttachedTo",value:function(t){return this._element===t||this._originalElement===t}},{key:"isDetached",value:function(){return null===this._element.parentNode}},{key:"load",value:function(t){var i=arguments.length>1&&arguments[1]!==e?arguments[1]:{},n=arguments[2];"function"==typeof i?n=i:(this._options.crop=i.crop,this._options.rotation=i.rotation,this._initialRotation=i.rotation&&i.rotation%90===0?i.rotation:null,this._initialCrop=this._options.crop),this._load(t,n,{blockPush:i.blockPush})}},{key:"upload",value:function(t){this._doUpload(t)}},{key:"download",value:function(){this._doDownload()}},{key:"remove",value:function(){return this._doRemove()}},{key:"destroy",value:function(){this._doDestroy()}},{key:"edit",value:function(){this._doEdit()}},{key:"crop",value:function(t,e){this._crop(t.x,t.y,t.width,t.height,e)}},{key:"containsImage",value:function(){return null!==this._data.input.name}},{key:"_canInstantEdit",value:function(){return this._options.instantEdit&&!this._isInitialising}},{key:"_getFileInput",value:function(){return this._element.querySelector("input[type=file]")}},{key:"_getInitialImage",value:function(){return this._element.querySelector("img")}},{key:"_getInputElement",value:function(){return this._getFileInput()||this._getInitialImage()}},{key:"_getRatioSpacerElement",value:function(){return this._element.children[0]}},{key:"_isImageOnly",value:function(){return"INPUT"!==this._input.nodeName}},{key:"_isFixedRatio",value:function(){return this._options.ratio.indexOf(":")!==-1}},{key:"_isAutoCrop",value:function(){return this._data.actions.crop.type===Ut.AUTO}},{key:"_toggleButton",value:function(t,e){St('.slim-btn[data-action="'+t+'"]',e,this._element)}},{key:"_clearState",value:function(){this._state=[],this._updateState()}},{key:"_removeState",value:function(t){this._state=this._state.filter(function(e){return e!==t}),this._updateState()}},{key:"_addState",value:function(t){z(t,this._state)||(this._state.push(t),this._updateState())}},{key:"_updateState",value:function(){this._element&&this._element.setAttribute("data-state",this._state.join(","))}},{key:"_resetData",value:function(){this._data={server:null,meta:gt(this._options.meta),input:{field:this._inputReference,name:null,type:null,width:0,height:0,file:null},output:{image:null,width:0,height:0},actions:{rotation:null,crop:null,size:null}},this._output&&(this._output.value=""),mt(this._getFileInput())}},{key:"_init",value:function(){var t=this;if(this._isInitialising=!0,this._addState("empty"),z("input",this._options.post)&&(this._inputReference="slim_input_"+this._uid),this._input=this._getInputElement(),this._input||(this._input=S("input"),this._input.type="file",this._element.appendChild(this._input)),this._isRequired=this._input.required===!0,this._output=this._element.querySelector("input[type=hidden]"),this._output){var e=null;try{e=JSON.parse(this._output.value)}catch(i){}if(e){var n=new Image;n.src=e.output.image,n.setAttribute("data-filename",e.output.name),this._element.insertBefore(n,this._element.firstChild)}}else this._output=S("input"),this._output.type="hidden",this._output.name=this._input.name||this._options.defaultInputName,this._element.appendChild(this._output);this._input.removeAttribute("name");var o=S("div","slim-area"),a=this._getInitialImage(),r=(a||{}).src,s=a?a.getAttribute("data-filename"):null;r?this._hasInitialImage=!0:(this._initialCrop=null,this._initialRotation=null);var h='\n\t\t<div class="slim-result">\n\t\t\t<img class="in" style="opacity:0" '+(r?'src="'+r+'"':"")+'><img><img style="opacity:0">\n\t\t</div>';if(this._isImageOnly())o.innerHTML="\n\t\t\t\t"+jt+"\n\t\t\t\t"+Vt+"\n\t\t\t\t"+h+'\n\t\t\t\t<div class="slim-status"><div class="slim-label-loading">'+(this._options.labelLoading||"")+"</div></div>\n\t\t\t";else{z("input",this._options.post)&&(this._data.input.field=this._inputReference,this._options.service||(this._input.name=this._inputReference));var u=void 0;this._input.hasAttribute("accept")&&"image/*"!==this._input.getAttribute("accept")?u=this._input.accept.split(",").map(function(t){return t.trim()}).filter(function(t){return t.length>0}):(u=H(),this._input.setAttribute("accept",u.join(","))),this._imageHopper=new Ot,this._imageHopper.accept=u,this._imageHopper.allowURLs="string"==typeof this._options.fetcher,this._element.appendChild(this._imageHopper.element),Nt.forEach(function(e){t._imageHopper.element.addEventListener(e,t)}),o.innerHTML="\n\t\t\t\t"+jt+"\n\t\t\t\t"+Vt+'\n\t\t\t\t<div class="slim-drip"><span><span></span></span></div>\n\t\t\t\t<div class="slim-status"><div class="slim-label">'+(this._options.label||"")+'</div><div class="slim-label-loading">'+(this._options.labelLoading||"")+"</div></div>\n\t\t\t\t"+h+"\n\t\t\t",this._input.addEventListener("change",this)}if(this._element.appendChild(o),this._btnGroup=S("div","slim-btn-group"),this._btnGroup.style.display="none",this._element.appendChild(this._btnGroup),Ft.filter(function(e){return t._isButtonAllowed(e)}).forEach(function(e){var i=I(e),n=t._options["button"+i+"Label"],o=t._options["button"+i+"Title"]||n,a=t._options["button"+i+"ClassName"],r=S("button","slim-btn slim-btn-"+e+(a?" "+a:""));r.innerHTML=n,r.title=o,r.type="button",r.addEventListener("click",t),r.setAttribute("data-action",e),t._btnGroup.appendChild(r)}),this._isFixedRatio()){var l=Dt(this._options.ratio,":");this._ratio=l[1]/l[0],this._scaleDropArea(this._ratio)}this._updateProgress(.5),r?this._load(r,function(){t._onInit()},{name:s}):this._onInit()}},{key:"_onInit",value:function(){var t=this;this._isInitialising=!1;var e=function(){var e=setTimeout(function(){Xt(t._timers,e),t._options.didInit.apply(t,[t.data,t])},0);t._timers.push(e)};this._options.saveInitialImage&&this.containsImage()?this._options.service||this._save(function(){e()},!1):(this._options.service&&this.containsImage()&&this._toggleButton("upload",!1),e())}},{key:"_updateProgress",value:function(t){if(t=Math.min(.99999,t),this._element&&this._progressEnabled){var e=this._element.querySelector(".slim-loader");if(e){var i=e.offsetWidth,n=e.querySelectorAll("path"),o=parseInt(n[0].getAttribute("stroke-width"),10);.5*i<o||(n[0].setAttribute("d",Tt(.5*i,.5*i,.5*i-o,.9999)),n[1].setAttribute("d",Tt(.5*i,.5*i,.5*i-o,t)))}}}},{key:"_startProgress",value:function(t){var e=this;if(this._element){this._progressEnabled=!1;var i=this._element.querySelector(".slim-loader");if(i){var n=i.children[0];this._stopProgressLoop(function(){i.removeAttribute("style"),n.removeAttribute("style"),e._progressEnabled=!0,e._updateProgress(0),e._progressEnabled=!1,u(n,{fromOpacity:0,opacity:1,duration:250,complete:function(){e._progressEnabled=!0,t&&t()}})})}}}},{key:"_stopProgress",value:function(){var t=this;if(this._element){var e=this._element.querySelector(".slim-loader");if(e){var i=e.children[0];this._updateProgress(1),u(i,{fromOpacity:1,opacity:0,duration:250,complete:function(){e.removeAttribute("style"),i.removeAttribute("style"),t._updateProgress(.5),t._progressEnabled=!1}})}}}},{key:"_startProgressLoop",value:function(){if(this._element){var t=this._element.querySelector(".slim-loader");if(t){var e=t.children[0];t.removeAttribute("style"),e.removeAttribute("style"),this._updateProgress(.5);var i=1e3;u(t,"stop"),u(t,{rotation:[0,0,-(2*Math.PI)*i],easing:"linear",duration:1e3*i}),u(e,{fromOpacity:0,opacity:1,duration:250})}}}},{key:"_stopProgressLoop",value:function(t){if(this._element){var e=this._element.querySelector(".slim-loader");if(e){var i=e.children[0];u(i,{fromOpacity:parseFloat(i.style.opacity),opacity:0,duration:250,complete:function(){u(e,"stop"),e.removeAttribute("style"),i.removeAttribute("style"),t&&t()}})}}}},{key:"_isButtonAllowed",value:function(t){return"edit"===t?this._options.edit:"download"===t?this._options.download:"upload"===t?!!this._options.service&&!this._options.push:"remove"!==t||!this._isImageOnly()}},{key:"_fallback",value:function(){var t=S("div","slim-area");t.innerHTML='\n\t\t\t<div class="slim-status"><div class="slim-label">'+(this._options.label||"")+"</div></div>\n\t\t",this._element.appendChild(t),this._throwError(this._options.statusNoSupport)}},{key:"handleEvent",value:function(t){switch(t.type){case"click":this._onClick(t);break;case"change":this._onChange(t);break;case"cancel":this._onCancel(t);break;case"confirm":this._onConfirm(t);break;case"file-over":this._onFileOver(t);break;case"file-out":this._onFileOut(t);break;case"file-drop":this._onDropFile(t);break;case"file-invalid":this._onInvalidFile(t);break;case"file-invalid-drop":this._onInvalidFileDrop(t)}}},{key:"_getIntro",value:function(){return this._element.querySelector(".slim-result .in")}},{key:"_getOutro",value:function(){return this._element.querySelector(".slim-result .out")}},{key:"_getInOut",value:function(){return this._element.querySelectorAll(".slim-result img")}},{key:"_getDrip",value:function(){return this._drip||(this._drip=this._element.querySelector(".slim-drip > span")),this._drip}},{key:"_throwError",value:function(t){this._addState("error"),this._element.querySelector(".slim-label").style.display="none";var e=this._element.querySelector(".slim-error");e||(e=S("div","slim-error"),this._element.querySelector(".slim-status").appendChild(e)),e.innerHTML=t,this._options.didThrowError.apply(this,[t])}},{key:"_removeError",value:function(){this._removeState("error"),this._element.querySelector(".slim-label").style.display="";var t=this._element.querySelector(".slim-error");t&&t.parentNode.removeChild(t)}},{key:"_openFileDialog",value:function(){this._removeError(),this._input.click()}},{key:"_onClick",value:function(t){var e=this,i=t.target.classList,n=t.target;if(i.contains("slim-file-hopper"))return t.preventDefault(),void this._openFileDialog();switch(n.getAttribute("data-action")){case"remove":this._options.willRemove.apply(this,[this.data,function(){e._doRemove()}]);break;case"edit":this._doEdit();break;case"download":this._doDownload();break;case"upload":this._doUpload()}}},{key:"_onInvalidFileDrop",value:function(){this._onInvalidFile(),this._removeState("file-over");var t=this._getDrip();u(t.firstChild,{fromScale:[.5,.5],scale:[0,0],fromOpacity:.5,opacity:0,duration:150,complete:function(){A(t.firstChild)}})}},{key:"_onInvalidFile",value:function(){var t=this._imageHopper.accept.map(B),e=this._options.statusFileType.replace("$0",t.join(", "));this._throwError(e)}},{key:"_onImageTooSmall",value:function(){var t=this._options.statusImageTooSmall.replace("$0",this._options.minSize.width+" × "+this._options.minSize.height);this._throwError(t)}},{key:"_onOverWeightFile",value:function(){var t=this._options.statusFileSize.replace("$0",this._options.maxFileSize);this._throwError(t)}},{key:"_onLocalURLProblem",value:function(t){this._throwError(this._options.statusLocalUrlProblem||t)}},{key:"_onRemoteURLProblem",value:function(t){this._throwError(t)}},{key:"_onFileOver",value:function(t){this._addState("file-over"),this._removeError();var e=this._getDrip(),i=u.createMatrix();i.translate(t.detail.x,t.detail.y,0),u.setElementTransform(e,i),1==this._imageHopper.dragPath.length&&(e.style.opacity=1,u(e.firstChild,{fromOpacity:0,opacity:.5,fromScale:[0,0],scale:[.5,.5],duration:150}))}},{key:"_onFileOut",value:function(t){this._removeState("file-over"),this._removeState("file-invalid"),this._removeError();var e=this._getDrip(),i=u.createMatrix();i.translate(t.detail.x,t.detail.y,0),u.setElementTransform(e,i),u(e.firstChild,{fromScale:[.5,.5],scale:[0,0],fromOpacity:.5,opacity:0,duration:150,complete:function(){A(e.firstChild)}})}},{key:"_onDropFile",value:function(t){var e=this;this._removeState("file-over");var i=this._getDrip(),n=u.createMatrix();n.translate(t.detail.x,t.detail.y,0),u.setElementTransform(i,n);var o=this._imageHopper.dragPath.length,a=this._imageHopper.dragPath[o-Math.min(10,o)],r=t.detail.x-a.x,s=t.detail.y-a.y;u(i,{fromPosition:[t.detail.x,t.detail.y,0],position:[t.detail.x+r,t.detail.y+s,0],duration:200}),u(i.firstChild,{fromScale:[.5,.5],scale:[2,2],fromOpacity:1,opacity:0,duration:200,complete:function(){A(i.firstChild),e._load(t.target.files[0])}})}},{key:"_onChange",value:function(t){t.target.files.length&&this._load(t.target.files[0])}},{key:"_load",value:function(t,i){var n=this,o=arguments.length>2&&arguments[2]!==e?arguments[2]:{};if(!this._isBeingDestroyed){if(this.containsImage())return clearTimeout(this._replaceTimeout),void this._doRemove(function(){n._replaceTimeout=setTimeout(function(){n._load(t,i,o)},100)});this._removeState("empty"),this._addState("busy"),this._startProgressLoop(),this._imageHopper&&(this._imageHopper.enabled=!1),clearTimeout(this._loadTimeout);var a=function(){clearTimeout(n._loadTimeout),n._loadTimeout=setTimeout(function(){n._isBeingDestroyed||(n._addState("loading"),u(n._element.querySelector(".slim-label-loading"),{fromOpacity:0,opacity:1,duration:250}))},500)},r=function(){n._imageHopper&&(n._imageHopper.enabled=!0),n._removeState("loading"),n._removeState("busy"),n._addState("empty"),n._stopProgressLoop()};if("string"==typeof t)return void(J(t)?this._load(Q(t),i,o):(a(),Z(t,this._options.willLoad,function(t){n._load(t,i,o)},function(t){setTimeout(function(){r(),n._onLocalURLProblem("<p>"+t+"</p>"),i&&i.apply(n,["local-url-problem"])},500)})));if("undefined"!=typeof t.remote)return J(t.remote)?void this._load(Q(t.remote),i,o):void(this._options.fetcher&&$(this._options.fetcher,this._options.willFetch,this._options.willLoad,t.remote,function(t){r(),n._onRemoteURLProblem("<p>"+t+"</p>"),i&&i.apply(n,["remote-url-problem"])},function(t){n._load(t,i,o)}));var s=t;if(this._imageHopper&&this._imageHopper.accept.indexOf(s.type)===-1)return r(),this._onInvalidFile(),void(i&&i.apply(this,["file-invalid"]));if(s.size&&this._options.maxFileSize&&U(s.size)>this._options.maxFileSize)return r(),this._onOverWeightFile(),void(i&&i.apply(this,["file-too-big"]));this._imageEditor&&this._imageEditor.dirty(),this._data.input.name=o&&o.name?o.name:V(s),this._data.input.type=G(s),this._data.input.size=s.size,this._data.input.file=s;var h=this._options.internalCanvasSize;f()&&(h=this._options.internalCanvasSizeLowMemory),et(s,h,function(t,e){var a=function(){n._imageHopper&&(n._imageHopper.enabled=!0),n._removeState("loading"),n._removeState("busy"),n._addState("empty"),n._stopProgressLoop(),n._resetData()};if(!t)return a(),void(i&&i.apply(n,["file-not-found"]));if(!dt(t,n._options.minSize))return a(),n._onImageTooSmall(),void(i&&i.apply(n,["image-too-small"]));var r=n._options.didLoad.apply(n,[s,t,e,n]);if(r!==!0)return a(),r!==!1&&n._throwError(r),void(i&&i.apply(n,[r]));n._removeState("loading");var h=function(t){n._imageHopper&&n._options.dropReplace&&(n._imageHopper.enabled=!0);var e=n._getIntro(),i={fromScale:[1.25,1.25],scale:[1,1],fromOpacity:0,opacity:1,complete:function(){A(e),e.style.opacity=1,t()}};n.isDetached()?i.duration=1:(i.easing="spring",i.springConstant=.3,i.springDeceleration=.7),n._canInstantEdit()&&(i.delay=500,i.duration=1,n._doEdit()),u(e,i)};n._options.willLoadCanvas.apply(n,[t,function(t){n._loadCanvas(t,function(t){n._addState("preview"),h(function(){n._canInstantEdit()||t||n._showButtons(),t||(n._stopProgressLoop(),n._removeState("busy")),i&&i.apply(n,[null,n.data])})},function(){n._canInstantEdit()||n._showButtons(),n._removeState("busy")},{blockPush:o.blockPush})},n])})}}},{key:"_loadCanvas",value:function(t,e,i,n){var o=this;if(n||(n={}),!this._isBeingDestroyed){f()?(this._data.input.image=new Image,this._data.input.image.src=t.toDataURL()):this._data.input.image=t,this._data.input.width=t.width,this._data.input.height=t.height,this._initialRotation&&(this._data.actions.rotation=this._initialRotation,this._initialRotation=null);var a=this._data.actions.rotation%180!==0;this._isFixedRatio()||(this._initialCrop?this._ratio=this._initialCrop.height/this._initialCrop.width:this._ratio=a?t.width/t.height:t.height/t.width,this._scaleDropArea(this._ratio));var r=function(){o._options.size&&(o._data.actions.size={width:o._options.size.width,height:o._options.size.height}),o._applyTransforms(t,function(t){var a=o._getIntro(),r=a.offsetWidth/t.width,s=!1;o._options.service&&o._options.push&&!n.blockPush&&(o._hasInitialImage||o._canInstantEdit()||(s=!0,o._stopProgressLoop(function(){o._startProgress(function(){o._updateProgress(.1)})}))),o._canInstantEdit()||o._save(function(){o._isBeingDestroyed||s&&(o._stopProgress(),i())},s);var h="auto"===o._options.devicePixelRatio?window.devicePixelRatio:o._options.devicePixelRatio;a.src="",a.src=ut(t,r*h).toDataURL(),a.onload=function(){a.onload=null,o._isBeingDestroyed||e&&e(s)}})};this._initialCrop?(this._data.actions.crop=gt(this._initialCrop),this._data.actions.crop.type=Ut.INITIAL,this._initialCrop=null,r()):this._options.willCropInitial.apply(this,[this.data,function(e){e?(o._data.actions.crop=e,o._data.actions.crop.type=Ut.INITIAL):(o._data.actions.crop=it(a?t.height:t.width,a?t.width:t.height,o._ratio),o._data.actions.crop.type=Ut.AUTO),r()},this])}}},{key:"_applyTransforms",value:function(t,e){var i=this,n=gt(this._data.actions);n.filters={sharpen:this._options.filterSharpen/100},this._options.forceMinSize?n.minSize=this._options.minSize:n.minSize={width:0,height:0},nt(t,n,function(t){var n=t;if(i._options.forceSize||i._options.size&&1==ht(i._options.size,t)){n=S("canvas"),n.width=i._options.size.width,n.height=i._options.size.height;var o=n.getContext("2d");o.drawImage(t,0,0,i._options.size.width,i._options.size.height)}if(i._options.forceMinSize&&i._options.size&&i._options.minSize.width===i._options.size.width&&i._options.minSize.height===i._options.size.height&&(n.width<i._options.minSize.width||n.height<i._options.minSize.height)){var a=Math.max(n.width,i._options.minSize.width),r=Math.max(n.height,i._options.minSize.height);n=S("canvas"),n.width=a,n.height=r;var s=n.getContext("2d");s.drawImage(t,0,0,a,r)}if(i._options.forceMinSize&&1===i._ratio&&(n.width<i._options.minSize.width||n.height<i._options.minSize.height)){n=S("canvas"),n.width=i._options.minSize.width,n.height=i._options.minSize.height;var h=n.getContext("2d");h.drawImage(t,0,0,n.width,n.height)}i._data.output.width=n.width,i._data.output.height=n.height,i._data.output.image=n,i._onTransformCanvas(function(t){i._data=t,i._options.didTransform.apply(i,[i.data,i]),e(i._data.output.image)})})}},{key:"_onTransformCanvas",value:function(t){this._options.willTransform.apply(this,[this.data,t,this])}},{key:"_appendEditor",value:function(){var t=this;this._imageEditor||(this._imageEditor=new Lt(S("div"),{minSize:this._options.minSize,devicePixelRatio:this._options.devicePixelRatio,buttonConfirmClassName:this._options.buttonConfirmClassName,buttonCancelClassName:this._options.buttonCancelClassName,buttonRotateClassName:this._options.buttonRotateClassName,buttonConfirmLabel:this._options.buttonConfirmLabel,buttonCancelLabel:this._options.buttonCancelLabel,buttonRotateLabel:this._options.buttonRotateLabel,buttonConfirmTitle:this._options.buttonConfirmTitle,buttonCancelTitle:this._options.buttonCancelTitle,buttonRotateTitle:this._options.buttonRotateTitle}),Bt.forEach(function(e){t._imageEditor.element.addEventListener(e,t)}))}},{key:"_scaleDropArea",value:function(t){var e=this._getRatioSpacerElement();e&&this._element&&(e.style.marginBottom=100*t+"%",this._element.setAttribute("data-ratio","1:"+t))}},{key:"_onCancel",value:function(t){this._removeState("editor"),this._options.didCancel.apply(this,[this]),this._showButtons(),this._hideEditor(),this._options.instantEdit&&!this._hasInitialImage&&this._isAutoCrop()&&this._doRemove()}},{key:"_onConfirm",value:function(t){var e=this,i=this._options.service&&this._options.push;i?this._startProgress(function(){e._updateProgress(.1)}):this._startProgressLoop(),this._removeState("editor"),this._addState("busy"),this._output.value="",this._data.actions.rotation=t.detail.rotation,this._data.actions.crop=t.detail.crop,this._data.actions.crop.type=Ut.MANUAL,this._applyTransforms(this._data.input.image,function(t){e._options.didConfirm.apply(e,[e.data,e]);var n=e._getInOut(),o="out"===n[0].className?n[0]:n[1],a=o===n[0]?n[1]:n[0];o.className="in",o.style.opacity="0",o.style.zIndex="2",a.className="out",a.style.zIndex="1";var r="auto"===e._options.devicePixelRatio?window.devicePixelRatio:e._options.devicePixelRatio;o.src="",o.src=ut(t,o.offsetWidth/t.width*r).toDataURL(),o.onload=function(){o.onload=null,"free"===e._options.ratio&&(e._ratio=o.naturalHeight/o.naturalWidth,e._scaleDropArea(e._ratio)),e._hideEditor();var t=setTimeout(function(){Xt(e._timers,t),e._showPreview(o,function(){e._save(function(t,n,o){e._toggleButton("upload",!0),i?e._stopProgress():e._stopProgressLoop(),e._removeState("busy"),e._showButtons()},i)})},250);e._timers.push(t)}})}},{key:"_cropAuto",value:function(){var t=arguments.length>0&&arguments[0]!==e?arguments[0]:function(t){},i=this._data.actions.rotation%180!==0,n=it(i?this._data.input.image.height:this._data.input.image.width,i?this._data.input.image.width:this._data.input.image.height,this._ratio);this._crop(n.x,n.y,n.width,n.height,t,Ut.AUTO)}},{key:"_crop",value:function(t,i,n,o){var a=arguments.length>4&&arguments[4]!==e?arguments[4]:function(t){},r=arguments.length>5&&arguments[5]!==e?arguments[5]:Ut.MANUAL;this._output.value="",this._data.actions.crop={x:t,y:i,width:n,height:o},this._data.actions.crop.type=r,this._manualTransform(a)}},{key:"_manualTransform",value:function(t){var e=this;this._startProgressLoop(),this._addState("busy"),this._applyTransforms(this._data.input.image,function(i){var n=e._getInOut(),o="out"===n[0].className?n[0]:n[1],a=o===n[0]?n[1]:n[0];o.className="in",o.style.opacity="1",o.style.zIndex="2",a.className="out",a.style.zIndex="0";var r="auto"===e._options.devicePixelRatio?window.devicePixelRatio:e._options.devicePixelRatio;o.src="",o.src=ut(i,o.offsetWidth/i.width*r).toDataURL(),o.onload=function(){o.onload=null,"free"===e._options.ratio&&(e._ratio=o.naturalHeight/o.naturalWidth,e._scaleDropArea(e._ratio));var i=e._options.service&&e._options.push,n=function(){e._save(function(n,o,a){i||e._stopProgressLoop(),e._removeState("busy"),t.apply(e,[e.data])},i)};i?e._startProgress(n):n()}})}},{key:"_save",value:function(){var t=this,i=arguments.length>0&&arguments[0]!==e?arguments[0]:function(){},n=!(arguments.length>1&&arguments[1]!==e)||arguments[1];if(!this._isBeingDestroyed){var o=this.dataBase64;this._options.service||this._isInitialising&&!this._isImageOnly()||this._options.willSave.apply(this,[o,function(e){t._store(e),t._options.didSave.apply(t,[e,t])},this]),this._isBeingDestroyed||(this._options.service&&n&&this._options.willSave.apply(this,[o,function(e){t._addState("upload"),t._imageHopper&&t._options.dropReplace&&(t._imageHopper.enabled=!1),t._upload(e,function(n,o){t._imageHopper&&t._options.dropReplace&&(t._imageHopper.enabled=!0),n||t._storeServerResponse(o),t._options.didUpload.apply(t,[n,e,o,t]),t._removeState("upload"),i(n,e,o)})},this]),this._options.service&&n||i())}}},{key:"_storeServerResponse",value:function(t){this._isRequired&&(this._input.required=!1),this._data.server=t,this._output.value="object"===("undefined"==typeof t?"undefined":c(t))?JSON.stringify(this._data.server):t}},{key:"_store",value:function(t){this._isRequired&&(this._input.required=!1),this._output.value=JSON.stringify(t)}},{key:"_upload",value:function(t,e){var i=this;this.requestOutput(function(t,n){var o=i._element.querySelector(".slim-upload-status"),a=i._options.willRequest,r=function(t,e){i._updateProgress(Math.max(.1,t/e))},s=function(t){var n=setTimeout(function(){if(Xt(i._timers,t),!i._isBeingDestroyed){o.innerHTML=i._options.statusUploadSuccess,o.setAttribute("data-state","success"),o.style.opacity=1;var t=setTimeout(function(){Xt(i._timers,t),o.style.opacity=0},2e3);i._timers.push(t)}},250);i._timers.push(n),e(null,t)},h=function(t){var n="";n="file-too-big"===t?i._options.statusContentLength:i._options.didReceiveServerError.apply(i,[t,i._options.statusUnknownResponse,i]);var a=setTimeout(function(){Xt(i._timers,a),o.innerHTML=n,o.setAttribute("data-state","error"),o.style.opacity=1},250);i._timers.push(a),e(t)};"string"==typeof i._options.service?D(i._options.service,i._options.uploadMethod,n,a,r,s,h):"function"==typeof i._options.service&&i._options.service.apply(i,["file"===i._options.serviceFormat?t:n,r,s,h,i])},t)}},{key:"requestOutput",value:function(t,e){var i=this;return this._data.input.file?(e||(e=this.dataBase64),void n.parseMetaData(this._data.input.file,function(o){var a=[],r=new FormData;if(z("input",i._options.post)&&(a.push(i._data.input.file),r.append(i._inputReference,i._data.input.file,i._data.input.file.name)),z("output",i._options.post)&&null!==i._data.output.image&&i._options.uploadBase64===!1){var s=Q(e.output.image,e.output.name);if(o.imageHead&&i._options.copyImageHead)try{s=new Blob([o.imageHead,n.blobSlice.call(s,20)],{type:bt(e.output.image)}),s=Y(s,e.output.name)}catch(h){}a.push(s);var u="slim_output_"+i._uid;e.output.image=null,e.output.field=u,r.append(u,s,e.output.name)}r.append(i._output.name,JSON.stringify(e)),t(a,r)},{maxMetaDataSize:262144,disableImageHead:!1})):void t(null,null)}},{key:"_showEditor",value:function(){Wt.className=this._options.popoverClassName,Wt.show(),this._imageEditor.show()}},{key:"_hideEditor",value:function(){var t=this;this._imageEditor.hide();var e=setTimeout(function(){Xt(t._timers,e),Wt.hide()},250);this._timers.push(e)}},{key:"_showPreview",value:function(t,e){u(t,{fromPosition:[0,50,0],position:[0,0,0],fromScale:[1.5,1.5],scale:[1,1],fromOpacity:0,opacity:1,easing:"spring",springConstant:.3,springDeceleration:.7,complete:function(){A(t),e&&e()}})}},{key:"_hideResult",value:function(t){var e=this._getIntro();e&&u(e,{fromScale:[1,1],scale:[.5,.5],fromOpacity:1,opacity:0,easing:"spring",springConstant:.3,springDeceleration:.75,complete:function(){A(e),t&&t()}})}},{key:"_showButtons",value:function(t){if(this._btnGroup){this._btnGroup.style.display="";var e={fromScale:[.5,.5],scale:[1,1],fromPosition:[0,10,0],position:[0,0,0],fromOpacity:0,opacity:1,complete:function(){A(this)},allDone:function(){t&&t()}};this.isDetached()?e.duration=1:(e.delay=function(t){return 250+50*t},e.easing="spring",e.springConstant=.3,e.springDeceleration=.85),u(this._btnGroup.childNodes,e)}}},{key:"_hideButtons",value:function(t){var e=this;if(this._btnGroup){var i={fromScale:[1,1],scale:[.85,.85],fromOpacity:1,opacity:0,allDone:function(){e._btnGroup.style.display="none",t&&t()}};this.isDetached()?i.duration=1:(i.easing="spring",i.springConstant=.3,i.springDeceleration=.75),u(this._btnGroup.childNodes,i)}}},{key:"_hideStatus",value:function(){var t=this._element.querySelector(".slim-upload-status");t.style.opacity=0}},{key:"_doEdit",value:function(){var t=this;this._data.input.image&&(this._addState("editor"),this._imageEditor||this._appendEditor(),this._imageEditor.showRotateButton=this._options.rotateButton,Wt.inner=this._imageEditor.element,this._imageEditor.open(this._data.input.image,"free"===this._options.ratio?null:this._ratio,this._data.actions.crop,this._data.actions.rotation,function(){t._showEditor(),t._hideButtons(),t._hideStatus()}))}},{key:"_doRemove",value:function(t){var e=this;if(!this._isImageOnly()){this._clearState(),this._addState("empty"),this._hasInitialImage=!1,this._imageHopper&&(this._imageHopper.enabled=!0),this._isRequired&&(this._input.required=!0);var i=this._getOutro();i&&(i.style.opacity="0");var n=this.data;this._resetData();var o=setTimeout(function(){Xt(e._timers,o),e._isBeingDestroyed||(e._hideButtons(function(){e._toggleButton("upload",!0)}),e._hideStatus(),e._hideResult(),e._options.didRemove.apply(e,[n,e]),t&&t())},this.isDetached()?0:250);return this._timers.push(o),n}}},{key:"_doUpload",value:function(t){var e=this;this._data.input.image&&(this._addState("upload"),this._startProgress(),this._hideButtons(function(){e._toggleButton("upload",!1),e._save(function(i,n,o){e._removeState("upload"),e._stopProgress(),t&&t.apply(e,[i,n,o]),i&&e._toggleButton("upload",!0),e._showButtons()})}))}},{key:"_doDownload",value:function(){var t=this._data.output.image;t&&xt(this._data,this._options.jpegCompression,this._options.forceType)}},{key:"_doDestroy",value:function(){function t(t,e){return 0!==e.filter(function(e){return t.name===e.name&&t.value===e.value}).length}var e=this;this._isBeingDestroyed=!0,this._timers.forEach(function(t){clearTimeout(t)}),this._timers=[],u(this._element,"detach"),this._imageHopper&&(Nt.forEach(function(t){e._imageHopper.element.removeEventListener(t,e)}),this._imageHopper.destroy(),this._imageHopper=null),this._imageEditor&&(Bt.forEach(function(t){e._imageEditor.element.removeEventListener(t,e)}),this._imageEditor.destroy(),this._imageEditor=null),Ct(this._btnGroup.children).forEach(function(t){t.removeEventListener("click",e)}),this._input.removeEventListener("change",this),this._element!==this._originalElement&&this._element.parentNode&&this._element.parentNode.replaceChild(this._originalElement,this._element),this._originalElement.innerHTML=this._originalElementInner;var i=g(this._originalElement);i.forEach(function(i){t(i,e._originalElementAttributes)||e._originalElement.removeAttribute(i.name)}),this._originalElementAttributes.forEach(function(n){t(n,i)||e._originalElement.setAttribute(n.name,n.value)}),qt=Math.max(0,qt-1),Wt&&0===qt&&(Wt.destroy(),Wt=null),this._originalElement=null,this._element=null,this._input=null,this._output=null,this._btnGroup=null,this._options=null}},{key:"dataBase64",get:function(){return kt(this._data,this._options.post,this._options.jpegCompression,this._options.forceType,null!==this._options.service)}},{key:"data",get:function(){return yt(this._data)}},{key:"element",get:function(){return this._element}},{key:"service",set:function(t){this._options.service=t}},{key:"size",set:function(t){this.setSize(t,null)}},{key:"rotation",set:function(t){this.setRotation(t,null)}},{key:"forceSize",set:function(t){this.setForceSize(t,null)}},{key:"ratio",set:function(t){this.setRatio(t,null)}}],[{key:"options",value:function(){var t={edit:!0,instantEdit:!1,uploadBase64:!1,meta:{},ratio:"free",devicePixelRatio:1,size:null,rotation:null,crop:null,post:["output","actions"],service:null,serviceFormat:null,filterSharpen:0,push:!1,defaultInputName:"slim[]",minSize:{width:0,height:0},maxFileSize:null,jpegCompression:null,uploadMethod:"POST",download:!1,saveInitialImage:!1,forceType:!1,forceSize:null,forceMinSize:!0,dropReplace:!0,fetcher:null,internalCanvasSize:{width:4096,height:4096},internalCanvasSizeLowMemory:{width:4096,height:4096},copyImageHead:!1,rotateButton:!0,popoverClassName:null,label:"<p>Drop your image here</p>",labelLoading:"<p>Loading image...</p>",statusFileType:"<p>Invalid file type, expects: $0.</p>",statusFileSize:"<p>File is too big, maximum file size: $0 MB.</p>",statusNoSupport:"<p>Your browser does not support image cropping.</p>",statusImageTooSmall:"<p>Image is too small, minimum size is: $0 pixels.</p>",statusContentLength:'<span class="slim-upload-status-icon"></span> The file is probably too big',statusUnknownResponse:'<span class="slim-upload-status-icon"></span> An unknown error occurred',statusUploadSuccess:'<span class="slim-upload-status-icon"></span> Saved',statusLocalUrlProblem:null,didInit:function(t){},didLoad:function(t,e,i){return!0},didSave:function(t){},didUpload:function(t,e,i){},didReceiveServerError:function(t,e){return e},didRemove:function(t){},didTransform:function(t){},didConfirm:function(t){},didCancel:function(){},didThrowError:function(){},willLoadCanvas:function(t,e){e(t)},willCropInitial:function(t,e){
e(null)},willTransform:function(t,e){e(t)},willSave:function(t,e){e(t)},willRemove:function(t,e){e()},willRequest:function(t,e){},willFetch:function(t){},willLoad:function(t){}};return Ft.concat(Lt.Buttons).concat("rotate").forEach(function(e){var i=I(e);t["button"+i+"ClassName"]=null,t["button"+i+"Label"]=i,t["button"+i+"Title"]=i}),t}}]),i}();return function(){function t(t){return t?"<p>"+t+"</p>":null}function e(t){var e=window,i=t.split(".");return i.forEach(function(t,n){e[i[n]]&&(e=e[i[n]])}),e!==window?e:null}var i=[],n=function(t){for(var e=0,n=i.length;e<n;e++)if(i[e].isAttachedTo(t))return e;return-1},o=function(t){return t},a=function(t){return"true"===t},r=function(t){return!t||"true"===t},s=function(e){return t(e)},h=function(t){return t?e(t):null},u=function(t){if(!t)return null;var e=Dt(t,",");return{width:e[0],height:e[1]}},l=function(t){return t?parseFloat(t):null},p=function(t){return t?parseInt(t,10):null},c=function(t){if(!t)return null;var e={};return t.split(",").map(function(t){return parseInt(t,10)}).forEach(function(t,i){e[Ht[i]]=t}),e},d={download:a,edit:r,instantEdit:a,minSize:u,size:u,forceSize:u,forceMinSize:r,internalCanvasSize:u,internalCanvasSizeLowMemory:u,service:function(t){if("undefined"==typeof t)return null;var i=e(t);return i?i:t},serviceFormat:function(t){return"undefined"==typeof t?null:t},fetcher:function(t){return"undefined"==typeof t?null:t},push:a,rotation:function(t){return"undefined"==typeof t?null:parseInt(t,10)},crop:c,post:function(t){return t?t.split(",").map(function(t){return t.trim()}):null},defaultInputName:o,ratio:function(t){return t?t:null},maxFileSize:l,filterSharpen:p,jpegCompression:p,uploadBase64:a,forceType:o,dropReplace:r,saveInitialImage:a,copyImageHead:a,rotateButton:r,label:s,labelLoading:s,popoverClassName:o,devicePixelRatio:o,uploadMethod:o};["FileSize","FileType","NoSupport","ImageTooSmall"].forEach(function(t){d["status"+t]=s}),["ContentLength","UnknownResponse","UploadSuccess","localUrlProblem"].forEach(function(t){d["status"+t]=o}),["Init","Load","Save","Upload","Remove","Transform","ReceiveServerError","Confirm","Cancel","ThrowError"].forEach(function(t){d["did"+t]=h}),["LoadCanvas","CropInitial","Transform","Save","Remove","Request","Load","Fetch"].forEach(function(t){d["will"+t]=h});var f=["ClassName","Label","Title"];Ft.concat(Lt.Buttons).concat("rotate").forEach(function(t){var e=I(t);f.forEach(function(t){d["button"+e+t]=o})}),Yt.supported=function(){return!("[object OperaMini]"===Object.prototype.toString.call(window.operamini)||"undefined"==typeof window.addEventListener||"undefined"==typeof window.FileReader||!("slice"in Blob.prototype)||"undefined"==typeof window.URL||"undefined"==typeof window.URL.createObjectURL)}(),Yt.parse=function(t){var e,i,n,o=[];for(e=t.querySelectorAll(".slim:not([data-state])"),n=e.length;n--;)i=e[n],o.push(Yt.create(i,Yt.getOptionsFromAttributes(i)));return o},Yt.getOptionsFromAttributes=function(t){var e=_(t),i={meta:{}};for(var n in e){var o=d[n],a=e[n];o?(a=o(a),a=null===a?gt(Yt.options()[n]):a,i[n]=a):0===n.indexOf("meta")&&(i.meta[T(n.substr(4))]=a)}return i},Yt.find=function(t){var e=i.filter(function(e){return e.isAttachedTo(t)});return e?e[0]:null},Yt.create=function(t,e){if(!Yt.find(t)){e||(e=Yt.getOptionsFromAttributes(t));var n=new Yt(t,e);return i.push(n),n}},Yt.destroy=function(t){var e=n(t);return!(e<0)&&(i[e].destroy(),i.splice(e,1),!0)}}(),Yt}(),t.Slim.supported)"loading"!==document.readyState?i():document.addEventListener("DOMContentLoaded",i);else{var n=t.getElementsByClassName("slim"),o=0,a=n.length;for(o=0;o<a;o++)n[o].className=""}}(window);

/*
 * Slim v5.1.1 - Image Cropping Made Easy
 * Copyright (c) 2019 Rik Schennink - https://pqina.nl/slim
 */
(function($,undefined){

	'use strict';

	// if no jquery, stop here
	if (!$) {return;}

	// library reference
	var Slim = (function() {

// custom event polyfill for IE10
(function() {
	if ( typeof window.CustomEvent === 'function' ) return false;

	function CustomEvent ( event, params ) {
		params = params || { bubbles: false, cancelable: false, detail: undefined };
		var evt = document.createEvent( 'CustomEvent' );
		evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
		return evt;
	}

	CustomEvent.prototype = window.Event.prototype;

	window.CustomEvent = CustomEvent;
})();
/*
* JavaScript Load Image
* https://github.com/blueimp/JavaScript-Load-Image
*
* Copyright 2011, Sebastian Tschan
* https://blueimp.net
*
* Licensed under the MIT license:
* http://www.opensource.org/licenses/MIT
*/

/*global define, module, window, document, URL, webkitURL, FileReader */

// Loads an image for a given File object.
// Invokes the callback with an img or optional canvas
// element (if supported by the browser) as parameter:
var loadImage = function (file, callback, options) {
    var img = document.createElement('img')
    var url
    var oUrl
    img.onerror = callback
    img.onload = function () {
        if (oUrl && !(options && options.noRevoke)) {
            loadImage.revokeObjectURL(oUrl)
        }
        if (callback) {
            callback(loadImage.scale(img, options))
        }
    }
    if (loadImage.isInstanceOf('Blob', file) ||
        // Files are also Blob instances, but some browsers
        // (Firefox 3.6) support the File API but not Blobs:
        loadImage.isInstanceOf('File', file)) {
        url = oUrl = loadImage.createObjectURL(file)
        // Store the file type for resize processing:
        img._type = file.type
    } else if (typeof file === 'string') {
        url = file
        if (options && options.crossOrigin) {
            img.crossOrigin = options.crossOrigin
        }
    } else {
        return false
    }
    if (url) {
        img.src = url
        return img
    }
    return loadImage.readFile(file, function (e) {
        var target = e.target
        if (target && target.result) {
            img.src = target.result
        } else {
            if (callback) {
                callback(e)
            }
        }
    })
}
// The check for URL.revokeObjectURL fixes an issue with Opera 12,
// which provides URL.createObjectURL but doesn't properly implement it:
var urlAPI = (window.createObjectURL && window) ||
    (window.URL && URL.revokeObjectURL && URL) ||
    (window.webkitURL && webkitURL)

loadImage.isInstanceOf = function (type, obj) {
    // Cross-frame instanceof check
    return Object.prototype.toString.call(obj) === '[object ' + type + ']'
}

// Transform image coordinates, allows to override e.g.
// the canvas orientation based on the orientation option,
// gets canvas, options passed as arguments:
loadImage.transformCoordinates = function () {
    return
}

// Returns transformed options, allows to override e.g.
// maxWidth, maxHeight and crop options based on the aspectRatio.
// gets img, options passed as arguments:
loadImage.getTransformedOptions = function (img, options) {
    var aspectRatio = options.aspectRatio
    var newOptions
    var i
    var width
    var height
    if (!aspectRatio) {
        return options
    }
    newOptions = {}
    for (i in options) {
        if (options.hasOwnProperty(i)) {
            newOptions[i] = options[i]
        }
    }
    newOptions.crop = true
    width = img.naturalWidth || img.width
    height = img.naturalHeight || img.height
    if (width / height > aspectRatio) {
        newOptions.maxWidth = height * aspectRatio
        newOptions.maxHeight = height
    } else {
        newOptions.maxWidth = width
        newOptions.maxHeight = width / aspectRatio
    }
    return newOptions
}

// Canvas render method, allows to implement a different rendering algorithm:
loadImage.renderImageToCanvas = function (
    canvas,
    img,
    sourceX,
    sourceY,
    sourceWidth,
    sourceHeight,
    destX,
    destY,
    destWidth,
    destHeight
) {
    canvas.getContext('2d').drawImage(
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    )
    return canvas
}

// This method is used to determine if the target image
// should be a canvas element:
loadImage.hasCanvasOption = function (options) {
    return options.canvas || options.crop || !!options.aspectRatio
}

// Scales and/or crops the given image (img or canvas HTML element)
// using the given options.
// Returns a canvas object if the browser supports canvas
// and the hasCanvasOption method returns true or a canvas
// object is passed as image, else the scaled image:
loadImage.scale = function (img, options) {
    options = options || {}
    var canvas = document.createElement('canvas')
    var useCanvas = img.getContext ||
        (loadImage.hasCanvasOption(options) && canvas.getContext)
    var width = img.naturalWidth || img.width
    var height = img.naturalHeight || img.height
    var destWidth = width
    var destHeight = height
    var maxWidth
    var maxHeight
    var minWidth
    var minHeight
    var sourceWidth
    var sourceHeight
    var sourceX
    var sourceY
    var pixelRatio
    var downsamplingRatio
    var tmp
    function scaleUp () {
        var scale = Math.max(
            (minWidth || destWidth) / destWidth,
            (minHeight || destHeight) / destHeight
        )
        if (scale > 1) {
            destWidth *= scale
            destHeight *= scale
        }
    }
    function scaleDown () {
        var scale = Math.min(
            (maxWidth || destWidth) / destWidth,
            (maxHeight || destHeight) / destHeight
        )
        if (scale < 1) {
            destWidth *= scale
            destHeight *= scale
        }
    }
    if (useCanvas) {
        options = loadImage.getTransformedOptions(img, options)
        sourceX = options.left || 0
        sourceY = options.top || 0
        if (options.sourceWidth) {
            sourceWidth = options.sourceWidth
            if (options.right !== undefined && options.left === undefined) {
                sourceX = width - sourceWidth - options.right
            }
        } else {
            sourceWidth = width - sourceX - (options.right || 0)
        }
        if (options.sourceHeight) {
            sourceHeight = options.sourceHeight
            if (options.bottom !== undefined && options.top === undefined) {
                sourceY = height - sourceHeight - options.bottom
            }
        } else {
            sourceHeight = height - sourceY - (options.bottom || 0)
        }
        destWidth = sourceWidth
        destHeight = sourceHeight
    }
    maxWidth = options.maxWidth
    maxHeight = options.maxHeight
    minWidth = options.minWidth
    minHeight = options.minHeight
    if (useCanvas && maxWidth && maxHeight && options.crop) {
        destWidth = maxWidth
        destHeight = maxHeight
        tmp = sourceWidth / sourceHeight - maxWidth / maxHeight
        if (tmp < 0) {
            sourceHeight = maxHeight * sourceWidth / maxWidth
            if (options.top === undefined && options.bottom === undefined) {
                sourceY = (height - sourceHeight) / 2
            }
        } else if (tmp > 0) {
            sourceWidth = maxWidth * sourceHeight / maxHeight
            if (options.left === undefined && options.right === undefined) {
                sourceX = (width - sourceWidth) / 2
            }
        }
    } else {
        if (options.contain || options.cover) {
            minWidth = maxWidth = maxWidth || minWidth
            minHeight = maxHeight = maxHeight || minHeight
        }
        if (options.cover) {
            scaleDown()
            scaleUp()
        } else {
            scaleUp()
            scaleDown()
        }
    }
    if (useCanvas) {
        pixelRatio = options.pixelRatio
        if (pixelRatio > 1) {
            canvas.style.width = destWidth + 'px'
            canvas.style.height = destHeight + 'px'
            destWidth *= pixelRatio
            destHeight *= pixelRatio
            canvas.getContext('2d').scale(pixelRatio, pixelRatio)
        }
        downsamplingRatio = options.downsamplingRatio
        if (downsamplingRatio > 0 && downsamplingRatio < 1 &&
            destWidth < sourceWidth && destHeight < sourceHeight) {
            while (sourceWidth * downsamplingRatio > destWidth) {
                canvas.width = sourceWidth * downsamplingRatio
                canvas.height = sourceHeight * downsamplingRatio
                loadImage.renderImageToCanvas(
                    canvas,
                    img,
                    sourceX,
                    sourceY,
                    sourceWidth,
                    sourceHeight,
                    0,
                    0,
                    canvas.width,
                    canvas.height
                )
                sourceWidth = canvas.width
                sourceHeight = canvas.height
                img = document.createElement('canvas')
                img.width = sourceWidth
                img.height = sourceHeight
                loadImage.renderImageToCanvas(
                    img,
                    canvas,
                    0,
                    0,
                    sourceWidth,
                    sourceHeight,
                    0,
                    0,
                    sourceWidth,
                    sourceHeight
                )
            }
        }
        canvas.width = destWidth
        canvas.height = destHeight
        loadImage.transformCoordinates(
            canvas,
            options
        )
        return loadImage.renderImageToCanvas(
            canvas,
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            0,
            0,
            destWidth,
            destHeight
        )
    }
    img.width = destWidth
    img.height = destHeight
    return img
}

loadImage.createObjectURL = function (file) {
    return urlAPI ? urlAPI.createObjectURL(file) : false
}

loadImage.revokeObjectURL = function (url) {
    return urlAPI ? urlAPI.revokeObjectURL(url) : false
}

// Loads a given File object via FileReader interface,
// invokes the callback with the event object (load or error).
// The result can be read via event.target.result:
loadImage.readFile = function (file, callback, method) {
    if (window.FileReader) {
        var fileReader = new FileReader()
        fileReader.onload = fileReader.onerror = callback
        method = method || 'readAsDataURL'
        if (fileReader[method]) {
            fileReader[method](file)
            return fileReader
        }
    }
    return false
}

var originalHasCanvasOption = loadImage.hasCanvasOption
var originalTransformCoordinates = loadImage.transformCoordinates
var originalGetTransformedOptions = loadImage.getTransformedOptions

// This method is used to determine if the target image
// should be a canvas element:
loadImage.hasCanvasOption = function (options) {
    return !!options.orientation ||
        originalHasCanvasOption.call(loadImage, options)
}

// Transform image orientation based on
// the given EXIF orientation option:
loadImage.transformCoordinates = function (canvas, options) {
    originalTransformCoordinates.call(loadImage, canvas, options)
    var ctx = canvas.getContext('2d')
    var width = canvas.width
    var height = canvas.height
    var styleWidth = canvas.style.width
    var styleHeight = canvas.style.height
    var orientation = options.orientation
    if (!orientation || orientation > 8) {
        return
    }
    if (orientation > 4) {
        canvas.width = height
        canvas.height = width
        canvas.style.width = styleHeight
        canvas.style.height = styleWidth
    }
    switch (orientation) {
        case 2:
            // horizontal flip
            ctx.translate(width, 0)
            ctx.scale(-1, 1)
            break
        case 3:
            // 180Â° rotate left
            ctx.translate(width, height)
            ctx.rotate(Math.PI)
            break
        case 4:
            // vertical flip
            ctx.translate(0, height)
            ctx.scale(1, -1)
            break
        case 5:
            // vertical flip + 90 rotate right
            ctx.rotate(0.5 * Math.PI)
            ctx.scale(1, -1)
            break
        case 6:
            // 90Â° rotate right
            ctx.rotate(0.5 * Math.PI)
            ctx.translate(0, -height)
            break
        case 7:
            // horizontal flip + 90 rotate right
            ctx.rotate(0.5 * Math.PI)
            ctx.translate(width, -height)
            ctx.scale(-1, 1)
            break
        case 8:
            // 90Â° rotate left
            ctx.rotate(-0.5 * Math.PI)
            ctx.translate(-width, 0)
            break
    }
}

// Transforms coordinate and dimension options
// based on the given orientation option:
loadImage.getTransformedOptions = function (img, opts) {
    var options = originalGetTransformedOptions.call(loadImage, img, opts)
    var orientation = options.orientation
    var newOptions
    var i
    if (!orientation || orientation > 8 || orientation === 1) {
        return options
    }
    newOptions = {}
    for (i in options) {
        if (options.hasOwnProperty(i)) {
            newOptions[i] = options[i]
        }
    }
    switch (options.orientation) {
        case 2:
            // horizontal flip
            newOptions.left = options.right
            newOptions.right = options.left
            break
        case 3:
            // 180Â° rotate left
            newOptions.left = options.right
            newOptions.top = options.bottom
            newOptions.right = options.left
            newOptions.bottom = options.top
            break
        case 4:
            // vertical flip
            newOptions.top = options.bottom
            newOptions.bottom = options.top
            break
        case 5:
            // vertical flip + 90 rotate right
            newOptions.left = options.top
            newOptions.top = options.left
            newOptions.right = options.bottom
            newOptions.bottom = options.right
            break
        case 6:
            // 90Â° rotate right
            newOptions.left = options.top
            newOptions.top = options.right
            newOptions.right = options.bottom
            newOptions.bottom = options.left
            break
        case 7:
            // horizontal flip + 90 rotate right
            newOptions.left = options.bottom
            newOptions.top = options.right
            newOptions.right = options.top
            newOptions.bottom = options.left
            break
        case 8:
            // 90Â° rotate left
            newOptions.left = options.bottom
            newOptions.top = options.left
            newOptions.right = options.top
            newOptions.bottom = options.right
            break
    }
    if (options.orientation > 4) {
        newOptions.maxWidth = options.maxHeight
        newOptions.maxHeight = options.maxWidth
        newOptions.minWidth = options.minHeight
        newOptions.minHeight = options.minWidth
        newOptions.sourceWidth = options.sourceHeight
        newOptions.sourceHeight = options.sourceWidth
    }
    return newOptions
}

var hasblobSlice = window.Blob && (Blob.prototype.slice ||
    Blob.prototype.webkitSlice || Blob.prototype.mozSlice)

loadImage.blobSlice = hasblobSlice && function () {
        var slice = this.slice || this.webkitSlice || this.mozSlice
        return slice.apply(this, arguments)
    }

loadImage.metaDataParsers = {
    jpeg: {
        0xffe1: [] // APP1 marker
    }
}

// Parses image meta data and calls the callback with an object argument
// with the following properties:
// * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
// The options arguments accepts an object and supports the following properties:
// * maxMetaDataSize: Defines the maximum number of bytes to parse.
// * disableImageHead: Disables creating the imageHead property.
loadImage.parseMetaData = function (file, callback, options) {
    options = options || {}
    var that = this
    // 256 KiB should contain all EXIF/ICC/IPTC segments:
    var maxMetaDataSize = options.maxMetaDataSize || 262144
    var data = {}
    var noMetaData = !(window.DataView && file && file.size >= 12 &&
    file.type === 'image/jpeg' && loadImage.blobSlice)
    if (noMetaData || !loadImage.readFile(
            loadImage.blobSlice.call(file, 0, maxMetaDataSize),
            function (e) {
                if (e.target.error) {
                    // FileReader error
                    //console.log(e.target.error)
                    callback(data)
                    return
                }
                // Note on endianness:
                // Since the marker and length bytes in JPEG files are always
                // stored in big endian order, we can leave the endian parameter
                // of the DataView methods undefined, defaulting to big endian.
                var buffer = e.target.result
                var dataView = new DataView(buffer)
                var offset = 2
                var maxOffset = dataView.byteLength - 4
                var headLength = offset
                var markerBytes
                var markerLength
                var parsers
                var i
                // Check for the JPEG marker (0xffd8):
                if (dataView.getUint16(0) === 0xffd8) {
                    while (offset < maxOffset) {
                        markerBytes = dataView.getUint16(offset)
                        // Search for APPn (0xffeN) and COM (0xfffe) markers,
                        // which contain application-specific meta-data like
                        // Exif, ICC and IPTC data and text comments:
                        if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                            markerBytes === 0xfffe) {
                            // The marker bytes (2) are always followed by
                            // the length bytes (2), indicating the length of the
                            // marker segment, which includes the length bytes,
                            // but not the marker bytes, so we add 2:
                            markerLength = dataView.getUint16(offset + 2) + 2
                            if (offset + markerLength > dataView.byteLength) {
                                //console.log('Invalid meta data: Invalid segment size.')
                                break
                            }
                            parsers = loadImage.metaDataParsers.jpeg[markerBytes]
                            if (parsers) {
                                for (i = 0; i < parsers.length; i += 1) {
                                    parsers[i].call(
                                        that,
                                        dataView,
                                        offset,
                                        markerLength,
                                        data,
                                        options
                                    )
                                }
                            }
                            offset += markerLength
                            headLength = offset
                        } else {
                            // Not an APPn or COM marker, probably safe to
                            // assume that this is the end of the meta data
                            break
                        }
                    }
                    // Meta length must be longer than JPEG marker (2)
                    // plus APPn marker (2), followed by length bytes (2):
                    if (!options.disableImageHead && headLength > 6) {
                        if (buffer.slice) {
                            data.imageHead = buffer.slice(0, headLength)
                        } else {
                            // Workaround for IE10, which does not yet
                            // support ArrayBuffer.slice:
                            data.imageHead = new Uint8Array(buffer)
                                .subarray(0, headLength)
                        }
                    }
                } else {
                    //console.log('Invalid JPEG file: Missing JPEG marker.')
                }
                callback(data)
            },
            'readAsArrayBuffer'
        )) {
        callback(data)
    }
}

loadImage.ExifMap = function () {
    return this
}

loadImage.ExifMap.prototype.map = {
    'Orientation': 0x0112
}

loadImage.ExifMap.prototype.get = function (id) {
    return this[id] || this[this.map[id]]
}

loadImage.getExifThumbnail = function (dataView, offset, length) {
    var hexData,
        i,
        b
    if (!length || offset + length > dataView.byteLength) {
        //console.log('Invalid Exif data: Invalid thumbnail data.')
        return
    }
    hexData = []
    for (i = 0; i < length; i += 1) {
        b = dataView.getUint8(offset + i)
        hexData.push((b < 16 ? '0' : '') + b.toString(16))
    }
    return 'data:image/jpeg,%' + hexData.join('%')
}

loadImage.exifTagTypes = {
    // byte, 8-bit unsigned int:
    1: {
        getValue: function (dataView, dataOffset) {
            return dataView.getUint8(dataOffset)
        },
        size: 1
    },
    // ascii, 8-bit byte:
    2: {
        getValue: function (dataView, dataOffset) {
            return String.fromCharCode(dataView.getUint8(dataOffset))
        },
        size: 1,
        ascii: true
    },
    // short, 16 bit int:
    3: {
        getValue: function (dataView, dataOffset, littleEndian) {
            return dataView.getUint16(dataOffset, littleEndian)
        },
        size: 2
    },
    // long, 32 bit int:
    4: {
        getValue: function (dataView, dataOffset, littleEndian) {
            return dataView.getUint32(dataOffset, littleEndian)
        },
        size: 4
    },
    // rational = two long values, first is numerator, second is denominator:
    5: {
        getValue: function (dataView, dataOffset, littleEndian) {
            return dataView.getUint32(dataOffset, littleEndian) /
                dataView.getUint32(dataOffset + 4, littleEndian)
        },
        size: 8
    },
    // slong, 32 bit signed int:
    9: {
        getValue: function (dataView, dataOffset, littleEndian) {
            return dataView.getInt32(dataOffset, littleEndian)
        },
        size: 4
    },
    // srational, two slongs, first is numerator, second is denominator:
    10: {
        getValue: function (dataView, dataOffset, littleEndian) {
            return dataView.getInt32(dataOffset, littleEndian) /
                dataView.getInt32(dataOffset + 4, littleEndian)
        },
        size: 8
    }
}
// undefined, 8-bit byte, value depending on field:
loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]

loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {
    var tagType = loadImage.exifTagTypes[type]
    var tagSize
    var dataOffset
    var values
    var i
    var str
    var c
    if (!tagType) {
        //console.log('Invalid Exif data: Invalid tag type.')
        return
    }
    tagSize = tagType.size * length
    // Determine if the value is contained in the dataOffset bytes,
    // or if the value at the dataOffset is a pointer to the actual data:
    dataOffset = tagSize > 4
        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)
        : (offset + 8)
    if (dataOffset + tagSize > dataView.byteLength) {
        //console.log('Invalid Exif data: Invalid data offset.')
        return
    }
    if (length === 1) {
        return tagType.getValue(dataView, dataOffset, littleEndian)
    }
    values = []
    for (i = 0; i < length; i += 1) {
        values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian)
    }
    if (tagType.ascii) {
        str = ''
        // Concatenate the chars:
        for (i = 0; i < values.length; i += 1) {
            c = values[i]
            // Ignore the terminating NULL byte(s):
            if (c === '\u0000') {
                break
            }
            str += c
        }
        return str
    }
    return values
}

loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {
    var tag = dataView.getUint16(offset, littleEndian)
    data.exif[tag] = loadImage.getExifValue(
        dataView,
        tiffOffset,
        offset,
        dataView.getUint16(offset + 2, littleEndian), // tag type
        dataView.getUint32(offset + 4, littleEndian), // tag length
        littleEndian
    )
}

loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {
    var tagsNumber,
        dirEndOffset,
        i
    if (dirOffset + 6 > dataView.byteLength) {
        //console.log('Invalid Exif data: Invalid directory offset.')
        return
    }
    tagsNumber = dataView.getUint16(dirOffset, littleEndian)
    dirEndOffset = dirOffset + 2 + 12 * tagsNumber
    if (dirEndOffset + 4 > dataView.byteLength) {
        //console.log('Invalid Exif data: Invalid directory size.')
        return
    }
    for (i = 0; i < tagsNumber; i += 1) {
        this.parseExifTag(
            dataView,
            tiffOffset,
            dirOffset + 2 + 12 * i, // tag offset
            littleEndian,
            data
        )
    }
    // Return the offset to the next directory:
    return dataView.getUint32(dirEndOffset, littleEndian)
}

loadImage.parseExifData = function (dataView, offset, length, data, options) {
    if (options.disableExif) {
        return
    }
    var tiffOffset = offset + 10
    var littleEndian
    var dirOffset
    var thumbnailData
    // Check for the ASCII code for "Exif" (0x45786966):
    if (dataView.getUint32(offset + 4) !== 0x45786966) {
        // No Exif data, might be XMP data instead
        return
    }
    if (tiffOffset + 8 > dataView.byteLength) {
        //console.log('Invalid Exif data: Invalid segment size.')
        return
    }
    // Check for the two null bytes:
    if (dataView.getUint16(offset + 8) !== 0x0000) {
        //console.log('Invalid Exif data: Missing byte alignment offset.')
        return
    }
    // Check the byte alignment:
    switch (dataView.getUint16(tiffOffset)) {
        case 0x4949:
            littleEndian = true
            break
        case 0x4D4D:
            littleEndian = false
            break
        default:
            //console.log('Invalid Exif data: Invalid byte alignment marker.')
            return
    }
    // Check for the TIFF tag marker (0x002A):
    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {
        //console.log('Invalid Exif data: Missing TIFF marker.')
        return
    }
    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)
    // Create the exif object to store the tags:
    data.exif = new loadImage.ExifMap()
    // Parse the tags of the main image directory and retrieve the
    // offset to the next directory, usually the thumbnail directory:
    dirOffset = loadImage.parseExifTags(
        dataView,
        tiffOffset,
        tiffOffset + dirOffset,
        littleEndian,
        data
    )
    if (dirOffset && !options.disableExifThumbnail) {
        thumbnailData = {exif: {}}
        dirOffset = loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + dirOffset,
            littleEndian,
            thumbnailData
        )
        // Check for JPEG Thumbnail offset:
        if (thumbnailData.exif[0x0201]) {
            data.exif.Thumbnail = loadImage.getExifThumbnail(
                dataView,
                tiffOffset + thumbnailData.exif[0x0201],
                thumbnailData.exif[0x0202] // Thumbnail data length
            )
        }
    }
    // Check for Exif Sub IFD Pointer:
    if (data.exif[0x8769] && !options.disableExifSub) {
        loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + data.exif[0x8769], // directory offset
            littleEndian,
            data
        )
    }
    // Check for GPS Info IFD Pointer:
    if (data.exif[0x8825] && !options.disableExifGps) {
        loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + data.exif[0x8825], // directory offset
            littleEndian,
            data
        )
    }
}

// Registers the Exif parser for the APP1 JPEG meta data segment:
loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)
var snabbt = (function() {

var tickRequests = [];
var runningAnimations = [];
var completedAnimations = [];
var transformProperty = 'transform';

// Find which vendor prefix to use
var styles = window.getComputedStyle(document.documentElement, '');
var vendorPrefix = (Array.prototype.slice
  .call(styles)
  .join('') 
  .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
)[1];
if(vendorPrefix === 'webkit')
transformProperty = 'webkitTransform';

/* Entry point, only function to be called by user */
var snabbt = function(arg1, arg2, arg3) {

var elements = arg1;

// If argument is an Array or a NodeList or other list type that can be iterable.
// Loop through and start one animation for each element.
if(elements.length !== undefined) {
  var aggregateChainer = {
    chainers: [],
    then: function(opts) {
      return this.snabbt(opts);
    },
    snabbt: function(opts) {
      var len = this.chainers.length;
      this.chainers.forEach(function(chainer, index) {
        chainer.snabbt(preprocessOptions(opts, index, len));
      });
      return aggregateChainer;
    },
    setValue: function(value) {
      this.chainers.forEach(function(chainer) {
        chainer.setValue(value);
      });
      return aggregateChainer;
    },
    finish: function() {
      this.chainers.forEach(function(chainer) {
        chainer.finish();
      });
      return aggregateChainer;
    },
    rollback: function() {
      this.chainers.forEach(function(chainer) {
        chainer.rollback();
      });
      return aggregateChainer;
    }
  };

  for(var i=0, len=elements.length;i<len;++i) {
    if(typeof arg2 == 'string')
      aggregateChainer.chainers.push(snabbtSingleElement(elements[i], arg2, preprocessOptions(arg3, i, len)));
    else
      aggregateChainer.chainers.push(snabbtSingleElement(elements[i], preprocessOptions(arg2, i, len), arg3));
  }
  return aggregateChainer;
} else {
  if(typeof arg2 == 'string')
    return snabbtSingleElement(elements, arg2, preprocessOptions(arg3, 0, 1));
  else
    return snabbtSingleElement(elements, preprocessOptions(arg2, 0, 1), arg3);
}
};

var preprocessOptions = function(options, index, len) {
if(!options)
  return options;
var clone = cloneObject(options);

if(isFunction(options.delay)) {
  clone.delay = options.delay(index, len);
}

if(isFunction(options.callback)) {
  clone.complete = function() {
    options.callback.call(this, index, len);
  };
}

var hasAllDoneCallback = isFunction(options.allDone);
var hasCompleteCallback = isFunction(options.complete);

if(hasCompleteCallback || hasAllDoneCallback) {
  clone.complete = function() {
    if(hasCompleteCallback) {
      options.complete.call(this, index, len);
    }
    if(hasAllDoneCallback && (index == len - 1)) {
      options.allDone();
    }
  };
}

if(isFunction(options.valueFeeder)) {
  clone.valueFeeder = function(i, matrix) {
    return options.valueFeeder(i, matrix, index, len);
  };
}
if(isFunction(options.easing)) {
  clone.easing = function(i) {
    return options.easing(i, index, len);
  };
}

var properties = [
  'position',
  'rotation',
  'skew',
  'rotationPost',
  'scale',
  'width',
  'height',
  'opacity',
  'fromPosition',
  'fromRotation',
  'fromSkew',
  'fromRotationPost',
  'fromScale',
  'fromWidth',
  'fromHeight',
  'fromOpacity',
  'transformOrigin',
  'duration',
  'delay'
];

properties.forEach(function(property) {
  if(isFunction(options[property])) {
    clone[property] = options[property](index, len);
  }
});

return clone;
};

var snabbtSingleElement = function(element, arg2, arg3) {

if(arg2 === 'attention') {
  return setupAttentionAnimation(element, arg3);
}

if(arg2 === 'stop') {
  return stopAnimation(element);
}

if(arg2 === 'detach') {
  return detachChildren(element);
}

var options = arg2;

// Remove orphaned end states
clearOphanedEndStates();

// If there is a running or past completed animation with element, use that end state as start state
var currentState = currentAnimationState(element);
var start = currentState;
// from has precendance over current animation state
start = stateFromOptions(options, start, true);
var end = cloneObject(currentState);
end = stateFromOptions(options, end);

var animOptions = setupAnimationOptions(start, end, options);
var animation = createAnimation(animOptions);

runningAnimations.push([element, animation]);

animation.updateElement(element, true);
var queue = [];
var chainer = {
  snabbt: function(opts) {
    queue.unshift(preprocessOptions(opts, 0, 1));
    return chainer;
  },
  then: function(opts) {
    return this.snabbt(opts);
  }
};

function tick(time) {
  animation.tick(time);
  animation.updateElement(element);
  if(animation.isStopped())
    return;

  if(!animation.completed())
    return queueTick(tick);

  if(options.loop > 1 && !animation.isStopped()) {
    // Loop current animation
    options.loop -= 1;
    animation.restart();
    queueTick(tick);
  } else {
    if(options.complete) {
      options.complete.call(element);
    }

    // Start next animation in queue
    if(queue.length) {
      options = queue.pop();

      start = stateFromOptions(options, end, true);
      end = stateFromOptions(options, cloneObject(end));
      options = setupAnimationOptions(start, end, options);

      animation = createAnimation(options);
      runningAnimations.push([element, animation]);

      animation.tick(time);
      queueTick(tick);
    }
  }
}

queueTick(tick);
// Manual animations are not chainable, instead an animation controller object is returned
// with setValue, finish and rollback methods
if(options.manual)
  return animation;
return chainer;
};

var setupAttentionAnimation = function(element,  options) {
var movement = stateFromOptions(options, createState({}));
options.movement = movement;
var animation = createAttentionAnimation(options);

runningAnimations.push([element, animation]);
function tick(time) {
  animation.tick(time);
  animation.updateElement(element);
  if(!animation.completed()) {
    queueTick(tick);
  } else {
    if(options.callback) {
      options.callback(element);
    }
    if(options.loop && options.loop > 1) {
      options.loop--;
      animation.restart();
      queueTick(tick);
    }
  }
}
queueTick(tick);
};

var stopAnimation = function(element) {
for(var i= 0,len=runningAnimations.length;i<len;++i) {
  var currentAnimation = runningAnimations[i];
  var animatedElement = currentAnimation[0];
  var animation = currentAnimation[1];

  if(animatedElement === element) {
    animation.stop();
  }
}
};

var indexOfElement = function(arr, element) {
  for(var i=0,len=arr.length;i<len;++i) {
    if (arr[i][0]===element) {
      return i;
    }
  }
  return -1;
};

var detachChildren = function(element) {

  var elements = [];
  var animations = runningAnimations.concat(completedAnimations);
  var el;
  var i;
  var len = animations.length;

  for(i=0;i<len;++i) {
    el = animations[i][0];
    if (element.contains(el) || element === el) {
      elements.push(el);
    }
  }

  len=elements.length;
  for(i=0;i<len;++i) {
    detachElement(elements[i]);
  }

};

var detachElement = function(element) {

  // stop animations
  stopAnimation(element);

  // remove
  var index = indexOfElement(runningAnimations, element);
  if (index >= 0) {
    runningAnimations.splice(index,1);
  }

  index = indexOfElement(completedAnimations, element);
  if (index >= 0) {
    completedAnimations.splice(index,1);
  }

};

var findAnimationState = function(animationList, element) {
for(var i=0,len=animationList.length;i<len;++i) {
  var currentAnimation = animationList[i];
  var animatedElement = currentAnimation[0];
  var animation = currentAnimation[1];

  if(animatedElement === element) {
    var state = animation.getCurrentState();
    animation.stop();
    return state;
  }
}
};

var clearOphanedEndStates = function() {
completedAnimations = completedAnimations.filter(function(animation) {
  return (findUltimateAncestor(animation[0]).body);
});
};

var findUltimateAncestor = function(node) {
var ancestor = node;
while(ancestor.parentNode) {
  ancestor = ancestor.parentNode;
}
return ancestor;
};

/**
* Returns the current state of element if there is an ongoing or previously finished
* animation releated to it. Will also call stop on the animation.
* TODO: The stopping of the animation is better put somewhere else
*/
var currentAnimationState = function(element) {
// Check if a completed animation is stored for this element
var state = findAnimationState(runningAnimations, element);
if(state)
  return state;

return findAnimationState(completedAnimations, element);
};

/**
* Parses an animation configuration object and returns a State instance
*/
var stateFromOptions = function(options, state, useFromPrefix) {
if (!state) {
  state = createState({
    position: [0, 0, 0],
    rotation: [0, 0, 0],
    rotationPost: [0, 0, 0],
    scale: [1, 1],
    skew: [0, 0]
  });
}
var position = 'position';
var rotation = 'rotation';
var skew = 'skew';
var rotationPost = 'rotationPost';
var scale = 'scale';
var scalePost = 'scalePost';
var width = 'width';
var height = 'height';
var opacity = 'opacity';

if(useFromPrefix) {
  position = 'fromPosition';
  rotation = 'fromRotation';
  skew = 'fromSkew';
  rotationPost = 'fromRotationPost';
  scale = 'fromScale';
  scalePost = 'fromScalePost';
  width = 'fromWidth';
  height = 'fromHeight';
  opacity = 'fromOpacity';
}

state.position = optionOrDefault(options[position], state.position);
state.rotation = optionOrDefault(options[rotation], state.rotation);
state.rotationPost = optionOrDefault(options[rotationPost], state.rotationPost);
state.skew = optionOrDefault(options[skew], state.skew);
state.scale = optionOrDefault(options[scale], state.scale);
state.scalePost = optionOrDefault(options[scalePost], state.scalePost);
state.opacity = options[opacity];
state.width = options[width];
state.height = options[height];

return state;
};

var setupAnimationOptions = function(start, end, options) {
options.startState = start;
options.endState = end;
return options;
};

var polyFillrAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { return setTimeout(callback, 1000 / 60); }; 

var queueTick = function(func) {
if(tickRequests.length === 0)
  polyFillrAF(tickAnimations);
tickRequests.push(func);
};

var tickAnimations = function(time) {
var len = tickRequests.length;
for(var i=0;i<len;++i) {
  tickRequests[i](time);
}
tickRequests.splice(0, len);

var finishedAnimations = runningAnimations.filter(function(animation) {
  return animation[1].completed();
});

// See if there are any previously completed animations on the same element, if so, remove it before merging
completedAnimations = completedAnimations.filter(function(animation) {
  for(var i=0,len=finishedAnimations.length;i<len;++i) {
    if(animation[0] === finishedAnimations[i][0]) {
      return false;
    }
  }
  return true;
});

completedAnimations = completedAnimations.concat(finishedAnimations);

runningAnimations = runningAnimations.filter(function(animation) {
  return !animation[1].completed();
});

if(tickRequests.length !== 0)
  polyFillrAF(tickAnimations);
};


// Class for handling animation between two states
var createAnimation = function(options) {
var startState = options.startState;
var endState = options.endState;
var duration = optionOrDefault(options.duration, 500);
var delay = optionOrDefault(options.delay, 0);
var perspective = options.perspective;
var easing = createEaser(optionOrDefault(options.easing, 'linear'), options);
var currentState = duration === 0 ? endState.clone() : startState.clone();
var transformOrigin = options.transformOrigin;
currentState.transformOrigin = options.transformOrigin;

var startTime = 0;
var currentTime = 0;
var stopped = false;
var started = false;

// Manual related
var manual = options.manual;
var manualValue = 0;
var manualDelayFactor = delay / duration;
var manualCallback;

var tweener;
// Setup tweener
if(options.valueFeeder) {
  tweener = createValueFeederTweener(options.valueFeeder,
                                     startState,
                                     endState,
                                     currentState);
} else {
  tweener = createStateTweener(startState, endState, currentState);
}

// Public api
return {
  stop: function() {
    stopped = true;
  },
  isStopped: function() {
    return stopped;
  },

  finish: function(callback) {
    manual = false;
    var manualDuration = duration * manualValue;
    startTime = currentTime - manualDuration;
    manualCallback = callback;
    easing.resetFrom = manualValue;
  },

  rollback: function(callback) {
    manual = false;
    tweener.setReverse();
    var manualDuration = duration * (1 - manualValue);
    startTime = currentTime - manualDuration;
    manualCallback = callback;
    easing.resetFrom = manualValue;
  },

  restart: function() {
    // Restart timer
    startTime = undefined;
    easing.resetFrom(0);
  },

  tick: function(time) {
    if(stopped)
      return;

    if(manual) {
      currentTime = time;
      this.updateCurrentTransform();
      return;
    }

    // If first tick, set startTime
    if(!startTime) {
      startTime = time;
    }
    if(time - startTime > delay) {
      started = true;
      currentTime = time - delay;

      var curr = Math.min(Math.max(0.0, currentTime - startTime), duration);
      easing.tick(curr / duration);
      this.updateCurrentTransform();
      if(this.completed() && manualCallback) {
        manualCallback();
      }
    }
  },

  getCurrentState: function() {
    return currentState;
  },

  setValue: function(_manualValue) {
    started = true;
    manualValue = Math.min(Math.max(_manualValue, 0.0001), 1 + manualDelayFactor);
  },

  updateCurrentTransform: function() {
    var tweenValue = easing.getValue();
    if(manual) {
      var val = Math.max(0.00001, manualValue - manualDelayFactor);
      easing.tick(val);
      tweenValue = easing.getValue();
    }
    tweener.tween(tweenValue);
  },

  completed: function() {
    if(stopped)
      return true;
    if(startTime === 0) {
      return false;
    }
    return easing.completed();
  },

  updateElement: function(element, forceUpdate) {
    if(!started && !forceUpdate)
      return;
    var matrix = tweener.asMatrix();
    var properties = tweener.getProperties();
    updateElementTransform(element, matrix, perspective);
    updateElementProperties(element, properties);
  }
};
};

// ------------------------------
// End Time animation
// ------------------------------

// ------------------------
// -- AttentionAnimation --
// ------------------------

var createAttentionAnimation = function(options) {
var movement = options.movement;
options.initialVelocity = 0.1;
options.equilibriumPosition = 0;
var spring = createSpringEasing(options);
var stopped = false;
var tweenPosition = movement.position;
var tweenRotation = movement.rotation;
var tweenRotationPost = movement.rotationPost;
var tweenScale = movement.scale;
var tweenSkew = movement.skew;

var currentMovement = createState({
  position: tweenPosition ? [0, 0, 0] : undefined,
  rotation: tweenRotation ? [0, 0, 0] : undefined,
  rotationPost: tweenRotationPost ? [0, 0, 0] : undefined,
  scale: tweenScale ? [0, 0] : undefined,
  skew: tweenSkew ? [0, 0] : undefined,
});

// Public API
return {
  stop: function() {
    stopped = true;
  },

  isStopped: function(time) {
    return stopped;
  },

  tick: function(time) {
    if(stopped)
      return;
    if(spring.equilibrium)
      return;
    spring.tick();

    this.updateMovement();
  },

  updateMovement:function() {
    var value = spring.getValue();
    if(tweenPosition) {
      currentMovement.position[0] = movement.position[0] * value;
      currentMovement.position[1] = movement.position[1] * value;
      currentMovement.position[2] = movement.position[2] * value;
    }
    if(tweenRotation) {
      currentMovement.rotation[0] = movement.rotation[0] * value;
      currentMovement.rotation[1] = movement.rotation[1] * value;
      currentMovement.rotation[2] = movement.rotation[2] * value;
    }
    if(tweenRotationPost) {
      currentMovement.rotationPost[0] = movement.rotationPost[0] * value;
      currentMovement.rotationPost[1] = movement.rotationPost[1] * value;
      currentMovement.rotationPost[2] = movement.rotationPost[2] * value;
    }
    if(tweenScale) {
      currentMovement.scale[0] = 1 + movement.scale[0] * value;
      currentMovement.scale[1] = 1 + movement.scale[1] * value;
    }

    if(tweenSkew) {
      currentMovement.skew[0] = movement.skew[0] * value;
      currentMovement.skew[1] = movement.skew[1] * value;
    }
  },

  updateElement: function(element) {
    updateElementTransform(element, currentMovement.asMatrix());
    updateElementProperties(element, currentMovement.getProperties());
  },

  getCurrentState: function() {
    return currentMovement;
  },

  completed: function() {
    return spring.equilibrium || stopped;
  },

  restart: function() {
    // Restart spring
    spring = createSpringEasing(options);
  }
};
};


/**********
* Easings *
***********/

var linearEasing = function(value) {
return value;
};

var ease = function(value) {
return (Math.cos(value*Math.PI + Math.PI) + 1)/2;
};

var easeIn = function(value) {
return value*value;
};

var easeOut = function(value) {
return -Math.pow(value - 1, 2) + 1;
};

var createSpringEasing = function(options) {
var position = optionOrDefault(options.startPosition, 0);
var equilibriumPosition = optionOrDefault(options.equilibriumPosition, 1);
var velocity = optionOrDefault(options.initialVelocity, 0);
var springConstant = optionOrDefault(options.springConstant, 0.8);
var deceleration = optionOrDefault(options.springDeceleration, 0.9);
var mass = optionOrDefault(options.springMass, 10);

var equilibrium = false;

// Public API
return {

  tick: function(value) {
    if(value === 0.0)
      return;
    if(equilibrium)
      return;
    var springForce = -(position - equilibriumPosition) * springConstant;
    // f = m * a
    // a = f / m
    var a = springForce / mass;
    // s = v * t
    // t = 1 ( for now )
    velocity += a;
    position += velocity;

    // Deceleration
    velocity *= deceleration;

    if(Math.abs(position - equilibriumPosition) < 0.001 && Math.abs(velocity) < 0.001) {
      equilibrium = true;
    }
  },

  resetFrom: function(value) {
    position = value;
    velocity = 0;
  },


  getValue: function() {
    if(equilibrium)
      return equilibriumPosition;
    return position;
  },

  completed: function() {
    return equilibrium;
  }
};
};

var EASING_FUNCS = {
'linear': linearEasing,
'ease': ease,
'easeIn': easeIn,
'easeOut': easeOut,
};


var createEaser = function(easerName, options) {
if(easerName == 'spring') {
  return createSpringEasing(options);
}
var easeFunction = easerName;
if(!isFunction(easerName)) {
  easeFunction = EASING_FUNCS[easerName];
}

var easer = easeFunction;
var value = 0;
var lastValue;

// Public API
return {
  tick: function(v) {
    value = easer(v);
    lastValue = v;
  },

  resetFrom: function(value) {
    lastValue = 0;
  },

  getValue: function() {
    return value;
  },

  completed: function() {
    if(lastValue >= 1) {
      return lastValue;
    }
    return false;
  }
};
};

/***
* Matrix related
*/

var assignTranslate = function(matrix, x, y, z) {
matrix[0] = 1;
matrix[1] = 0;
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = 0;
matrix[5] = 1;
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = 0;
matrix[10] = 1;
matrix[11] = 0;
matrix[12] = x;
matrix[13] = y;
matrix[14] = z;
matrix[15] = 1;
};

var assignRotateX = function(matrix, rad) {
matrix[0] = 1;
matrix[1] = 0;
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = 0;
matrix[5] = Math.cos(rad);
matrix[6] = -Math.sin(rad);
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = Math.sin(rad);
matrix[10] = Math.cos(rad);
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};


var assignRotateY = function(matrix, rad) {
matrix[0] = Math.cos(rad);
matrix[1] = 0;
matrix[2] = Math.sin(rad);
matrix[3] = 0;
matrix[4] = 0;
matrix[5] = 1;
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = -Math.sin(rad);
matrix[9] = 0;
matrix[10] = Math.cos(rad);
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};

var assignRotateZ = function(matrix, rad) {
matrix[0] = Math.cos(rad);
matrix[1] = -Math.sin(rad);
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = Math.sin(rad);
matrix[5] = Math.cos(rad);
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = 0;
matrix[10] = 1;
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};

var assignSkew = function(matrix, ax, ay) {
matrix[0] = 1;
matrix[1] = Math.tan(ax);
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = Math.tan(ay);
matrix[5] = 1;
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = 0;
matrix[10] = 1;
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};


var assignScale = function(matrix, x, y) {
matrix[0] = x;
matrix[1] = 0;
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = 0;
matrix[5] = y;
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = 0;
matrix[10] = 1;
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};

var assignIdentity = function(matrix) {
matrix[0] = 1;
matrix[1] = 0;
matrix[2] = 0;
matrix[3] = 0;
matrix[4] = 0;
matrix[5] = 1;
matrix[6] = 0;
matrix[7] = 0;
matrix[8] = 0;
matrix[9] = 0;
matrix[10] = 1;
matrix[11] = 0;
matrix[12] = 0;
matrix[13] = 0;
matrix[14] = 0;
matrix[15] = 1;
};

var copyArray = function(a, b) {
b[0] = a[0];
b[1] = a[1];
b[2] = a[2];
b[3] = a[3];
b[4] = a[4];
b[5] = a[5];
b[6] = a[6];
b[7] = a[7];
b[8] = a[8];
b[9] = a[9];
b[10] = a[10];
b[11] = a[11];
b[12] = a[12];
b[13] = a[13];
b[14] = a[14];
b[15] = a[15];
};

var createMatrix = function() {
var data = new Float32Array(16);
var a = new Float32Array(16);
var b = new Float32Array(16);
assignIdentity(data);

return {
  data: data,

  asCSS: function() {
    var css = 'matrix3d(';
    for(var i=0;i<15;++i) {
      if(Math.abs(data[i]) < 0.0001)
        css += '0,';
      else
        css += data[i].toFixed(10) + ',';
    }
    if(Math.abs(data[15]) < 0.0001)
      css += '0)';
    else
      css += data[15].toFixed(10) + ')';
    return css;
  },

  clear: function() {
    assignIdentity(data);
  },

  translate: function(x, y, z) {
    copyArray(data, a);
    assignTranslate(b, x, y, z);
    assignedMatrixMultiplication(a, b, data);
    return this;
  },

  rotateX: function(radians) {
    copyArray(data, a);
    assignRotateX(b, radians);
    assignedMatrixMultiplication(a, b, data);
    return this;
  },

  rotateY: function(radians) {
    copyArray(data, a);
    assignRotateY(b, radians);
    assignedMatrixMultiplication(a, b, data);
    return this;
  },

  rotateZ: function(radians) {
    copyArray(data, a);
    assignRotateZ(b, radians);
    assignedMatrixMultiplication(a, b, data);
    return this;
  },

  scale: function(x, y) {
    copyArray(data, a);
    assignScale(b, x, y);
    assignedMatrixMultiplication(a, b, data);
    return this;
  },

  skew: function(ax, ay) {
    copyArray(data, a);
    assignSkew(b, ax, ay);
    assignedMatrixMultiplication(a, b, data);
    return this;
  }
};
};

var assignedMatrixMultiplication = function(a, b, res) {
// Unrolled loop
res[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
res[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
res[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
res[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

res[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
res[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
res[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
res[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

res[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
res[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
res[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
res[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

res[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
res[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
res[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
res[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

return res;
};

var createState = function(config) {
// Caching of matrix and properties so we don't have to create new ones everytime they are needed
var matrix = createMatrix();
var properties = {
  opacity: undefined,
  width: undefined,
  height: undefined
};

// Public API
return {
  position: config.position,
  rotation: config.rotation,
  rotationPost: config.rotationPost,
  skew: config.skew,
  scale: config.scale,
  scalePost: config.scalePost,
  opacity: config.opacity,
  width: config.width,
  height: config.height,


  clone: function() {
    return createState({
      position: this.position ? this.position.slice(0) : undefined,
      rotation: this.rotation ? this.rotation.slice(0) : undefined,
      rotationPost: this.rotationPost ? this.rotationPost.slice(0) : undefined,
      skew: this.skew ? this.skew.slice(0) : undefined,
      scale: this.scale ? this.scale.slice(0) : undefined,
      scalePost: this.scalePost ? this.scalePost.slice(0) : undefined,
      height: this.height,
      width: this.width,
      opacity: this.opacity
    });
  },

  asMatrix: function() {
    var m = matrix;
    m.clear();

    if(this.transformOrigin)
      m.translate(-this.transformOrigin[0], -this.transformOrigin[1], -this.transformOrigin[2]);

    if(this.scale) {
      m.scale(this.scale[0], this.scale[1]);
    }

    if(this.skew) {
      m.skew(this.skew[0], this.skew[1]);
    }

    if(this.rotation) {
      m.rotateX(this.rotation[0]);
      m.rotateY(this.rotation[1]);
      m.rotateZ(this.rotation[2]);
    }

    if(this.position) {
      m.translate(this.position[0], this.position[1], this.position[2]);
    }

    if(this.rotationPost) {
      m.rotateX(this.rotationPost[0]);
      m.rotateY(this.rotationPost[1]);
      m.rotateZ(this.rotationPost[2]);
    }

    if(this.scalePost) {
      m.scale(this.scalePost[0], this.scalePost[1]);
    }

    if(this.transformOrigin)
      m.translate(this.transformOrigin[0], this.transformOrigin[1], this.transformOrigin[2]);
    return m;
  },

  getProperties: function() {
    properties.opacity = this.opacity;
    properties.width = this.width + 'px';
    properties.height = this.height + 'px';
    return properties;
  }
};
};
// ------------------
// -- StateTweener -- 
// -------------------

var createStateTweener = function(startState, endState, resultState) {
var start = startState;
var end = endState;
var result = resultState;

var tweenPosition = end.position !== undefined;
var tweenRotation = end.rotation !== undefined;
var tweenRotationPost = end.rotationPost !== undefined;
var tweenScale = end.scale !== undefined;
var tweenSkew = end.skew !== undefined;
var tweenWidth = end.width !== undefined;
var tweenHeight = end.height !== undefined;
var tweenOpacity = end.opacity !== undefined;

// Public API
return {

  tween: function(tweenValue) {

    if(tweenPosition) {
      var dX = (end.position[0] - start.position[0]);
      var dY = (end.position[1] - start.position[1]);
      var dZ = (end.position[2] - start.position[2]);
      result.position[0] = start.position[0] + tweenValue*dX;
      result.position[1] = start.position[1] + tweenValue*dY;
      result.position[2] = start.position[2] + tweenValue*dZ;
    }

    if(tweenRotation) {
      var dAX = (end.rotation[0] - start.rotation[0]);
      var dAY = (end.rotation[1] - start.rotation[1]);
      var dAZ = (end.rotation[2] - start.rotation[2]);
      result.rotation[0] = start.rotation[0] + tweenValue*dAX;
      result.rotation[1] = start.rotation[1] + tweenValue*dAY;
      result.rotation[2] = start.rotation[2] + tweenValue*dAZ;
    }

    if(tweenRotationPost) {
      var dBX = (end.rotationPost[0] - start.rotationPost[0]);
      var dBY = (end.rotationPost[1] - start.rotationPost[1]);
      var dBZ = (end.rotationPost[2] - start.rotationPost[2]);
      result.rotationPost[0] = start.rotationPost[0] + tweenValue*dBX;
      result.rotationPost[1] = start.rotationPost[1] + tweenValue*dBY;
      result.rotationPost[2] = start.rotationPost[2] + tweenValue*dBZ;
    }

    if(tweenSkew) {
      var dSX = (end.scale[0] - start.scale[0]);
      var dSY = (end.scale[1] - start.scale[1]);

      result.scale[0] = start.scale[0] + tweenValue*dSX;
      result.scale[1] = start.scale[1] + tweenValue*dSY;
    }

    if(tweenScale) {
      var dSkewX = (end.skew[0] - start.skew[0]);
      var dSkewY = (end.skew[1] - start.skew[1]);

      result.skew[0] = start.skew[0] + tweenValue*dSkewX;
      result.skew[1] = start.skew[1] + tweenValue*dSkewY;
    }

    if(tweenWidth) {
      var dWidth = (end.width - start.width);
      result.width = start.width + tweenValue*dWidth;
    }


    if(tweenHeight) {
      var dHeight = (end.height - start.height);
      result.height = start.height + tweenValue*dHeight;
    }

    if(tweenOpacity) {
      var dOpacity = (end.opacity - start.opacity);
      result.opacity = start.opacity + tweenValue*dOpacity;
    }

  },

  asMatrix: function() {
    return result.asMatrix();
  },

  getProperties: function() {
    return result.getProperties();
  },

  setReverse: function() {
    var oldStart = start;
    start = end;
    end = oldStart;
  }
};
};

// ------------------------
// -- ValueFeederTweener -- 
// ------------------------

var createValueFeederTweener = function(valueFeeder, startState, endState, resultState) {
var currentMatrix = valueFeeder(0, createMatrix());
var start = startState;
var end = endState;
var result = resultState;
var reverse = false;


// Public API
return {

  tween: function(tweenValue) {
    if(reverse)
      tweenValue = 1 - tweenValue;
    currentMatrix.clear();
    currentMatrix = valueFeeder(tweenValue, currentMatrix);

    var dWidth = (end.width - start.width);
    var dHeight = (end.height - start.height);
    var dOpacity = (end.opacity - start.opacity);

    if(end.width !== undefined)
      result.width = start.width + tweenValue*dWidth;
    if(end.height !== undefined)
      result.height = start.height + tweenValue*dHeight;
    if(end.opacity !== undefined)
      result.opacity = start.opacity + tweenValue*dOpacity;
  },

  asMatrix: function() {
    return currentMatrix;
  },

  getProperties: function() {
    return result.getProperties();
  },

  setReverse: function() {
    reverse = true;
  }

};
};

var optionOrDefault = function(option, def) {
if(typeof option == 'undefined') {
  return def;
}
return option;
};

var updateElementTransform = function(element, matrix, perspective) {
var cssPerspective = '';
if(perspective) {
  cssPerspective = 'perspective(' + perspective + 'px) ';
}
var cssMatrix = matrix.asCSS();
element.style[transformProperty] = cssPerspective + cssMatrix;
};

var updateElementProperties = function(element, properties) {
for(var key in properties) {
  element.style[key] = properties[key];
}
};

var isFunction = function(object) {
return (typeof object === "function");
};

var cloneObject = function(object) {
if(!object)
  return object;
var clone = {};
for(var key in object) {
  clone[key] = object[key];
}
return clone;
};

snabbt.createMatrix = createMatrix;
snabbt.setElementTransform = updateElementTransform;
return snabbt;
}());
var stackBlur = (function(){

var mul_table = [
    512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
    454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
    482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
    437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
    497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
    320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
    446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
    329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
    505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
    399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
    324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
    268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
    451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
    385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
    332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
    289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];


var shg_table = [
    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
    17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function getImageDataFromCanvas(canvas, top_x, top_y, width, height)
{
    if (typeof(canvas) == 'string')
        canvas  = document.getElementById(canvas);
    else if (!canvas instanceof HTMLCanvasElement)
        return;

    var context = canvas.getContext('2d');
    var imageData;

    try {
        try {
            imageData = context.getImageData(top_x, top_y, width, height);
        } catch(e) {
            throw new Error("unable to access local image data: " + e);
            return;
        }
    } catch(e) {
        throw new Error("unable to access image data: " + e);
    }

    return imageData;
}

function processCanvasRGBA(canvas, top_x, top_y, width, height, radius)
{
    if (isNaN(radius) || radius < 1) return;
    radius |= 0;

    var imageData = getImageDataFromCanvas(canvas, top_x, top_y, width, height);

    imageData = processImageDataRGBA(imageData, top_x, top_y, width, height, radius);

    canvas.getContext('2d').putImageData(imageData, top_x, top_y);
}

function processImageDataRGBA(imageData, top_x, top_y, width, height, radius)
{
    var pixels = imageData.data;

    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
        r_out_sum, g_out_sum, b_out_sum, a_out_sum,
        r_in_sum, g_in_sum, b_in_sum, a_in_sum,
        pr, pg, pb, pa, rbs;

    var div = radius + radius + 1;
    var w4 = width << 2;
    var widthMinus1  = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1  = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

    var stackStart = new BlurStack();
    var stack = stackStart;
    for (i = 1; i < div; i++)
    {
        stack = stack.next = new BlurStack();
        if (i == radiusPlus1) var stackEnd = stack;
    }
    stack.next = stackStart;
    var stackIn = null;
    var stackOut = null;

    yw = yi = 0;

    var mul_sum = mul_table[radius];
    var shg_sum = shg_table[radius];

    for (y = 0; y < height; y++)
    {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);

        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;

        stack = stackStart;

        for (i = 0; i < radiusPlus1; i++)
        {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }

        for (i = 1; i < radiusPlus1; i++)
        {
            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = (pg = pixels[p+1])) * rbs;
            b_sum += (stack.b = (pb = pixels[p+2])) * rbs;
            a_sum += (stack.a = (pa = pixels[p+3])) * rbs;

            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;

            stack = stack.next;
        }


        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++)
        {
            pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa != 0)
            {
                pa = 255 / pa;
                pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            } else {
                pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
            }

            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;

            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;

            p =  (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

            r_in_sum += (stackIn.r = pixels[p]);
            g_in_sum += (stackIn.g = pixels[p+1]);
            b_in_sum += (stackIn.b = pixels[p+2]);
            a_in_sum += (stackIn.a = pixels[p+3]);

            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            a_sum += a_in_sum;

            stackIn = stackIn.next;

            r_out_sum += (pr = stackOut.r);
            g_out_sum += (pg = stackOut.g);
            b_out_sum += (pb = stackOut.b);
            a_out_sum += (pa = stackOut.a);

            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;

            stackOut = stackOut.next;

            yi += 4;
        }
        yw += width;
    }


    for (x = 0; x < width; x++)
    {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);

        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;

        stack = stackStart;

        for (i = 0; i < radiusPlus1; i++)
        {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }

        yp = width;

        for (i = 1; i <= radius; i++)
        {
            yi = (yp + x) << 2;

            r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = (pg = pixels[yi+1])) * rbs;
            b_sum += (stack.b = (pb = pixels[yi+2])) * rbs;
            a_sum += (stack.a = (pa = pixels[yi+3])) * rbs;

            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;

            stack = stack.next;

            if(i < heightMinus1)
            {
                yp += width;
            }
        }

        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++)
        {
            p = yi << 2;
            pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa > 0)
            {
                pa = 255 / pa;
                pixels[p]   = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[p+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[p+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            } else {
                pixels[p] = pixels[p+1] = pixels[p+2] = 0;
            }

            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;

            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;

            p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;

            r_sum += (r_in_sum += (stackIn.r = pixels[p]));
            g_sum += (g_in_sum += (stackIn.g = pixels[p+1]));
            b_sum += (b_in_sum += (stackIn.b = pixels[p+2]));
            a_sum += (a_in_sum += (stackIn.a = pixels[p+3]));

            stackIn = stackIn.next;

            r_out_sum += (pr = stackOut.r);
            g_out_sum += (pg = stackOut.g);
            b_out_sum += (pb = stackOut.b);
            a_out_sum += (pa = stackOut.a);

            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;

            stackOut = stackOut.next;

            yi += width;
        }
    }
    return imageData;
}

function BlurStack()
{
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
}

return processCanvasRGBA;

}());
// canvas to blob polyfill
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob#Polyfill
if (!HTMLCanvasElement.prototype.toBlob) {
	Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
		value: function (callback, type, quality) {

			var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
				len = binStr.length,
				arr = new Uint8Array(len);

			for (var i=0; i<len; i++ ) {
				arr[i] = binStr.charCodeAt(i);
			}

			callback( new Blob( [arr], {type: type || 'image/png'} ) );
		}
	});
}
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _arguments = arguments;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lowMemory = null;
var isLowMemoryDevice = function isLowMemoryDevice() {
    if (lowMemory === null) {
        lowMemory = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }
    return lowMemory;
};

var copyString = function copyString(str) {
    return str + '';
};

var getDataset = function getDataset(el) {
    if (typeof el.dataset === 'undefined') {
        var res = {};
        var attr;
        var attrName;
        var attrs = el.attributes;
        for (attr in attrs) {
            if (attrs.hasOwnProperty(attr) && attrs[attr].name && /^data-[a-z_\-\d]*$/i.test(attrs[attr].name)) {
                attrName = toCamelCase(attrs[attr].name.substr(5));
                res[attrName] = attrs[attr].value;
            }
        }
        return res;
    }
    return el.dataset;
};

var toCamelCase = function toCamelCase(str) {
    return str.replace(/\-./g, function (substr) {
        return substr.charAt(1).toUpperCase();
    });
};

var getElementAttributes = function getElementAttributes(el) {
    // is a for loop on purpose as this should still function when Slim not supported
    var result = [];
    var attributes = Array.prototype.slice.call(el.attributes);
    var l = attributes.length;
    for (var i = 0; i < l; i++) {
        result.push({
            name: attributes[i].name,
            value: attributes[i].value
        });
    }
    return result;
};

// helper method
var getOffsetByEvent = function getOffsetByEvent(e) {
    return {
        x: typeof e.offsetX === 'undefined' ? e.layerX : e.offsetX,
        y: typeof e.offsetY === 'undefined' ? e.layerY : e.offsetY
    };
};

// merge two objects together
var mergeOptions = function mergeOptions(base, additives) {
    var key;
    var options = {};
    var optionsToMerge = additives || {};

    for (key in base) {
        if (!base.hasOwnProperty(key)) {
            continue;
        }
        options[key] = typeof optionsToMerge[key] === 'undefined' ? base[key] : optionsToMerge[key];
    }

    return options;
};

// keys
var Key = {
    ESC: 27,
    RETURN: 13
};

// pointer events
var Events = {
    DOWN: ['touchstart', 'pointerdown', 'mousedown'],
    MOVE: ['touchmove', 'pointermove', 'mousemove'],
    UP: ['touchend', 'touchcancel', 'pointerup', 'mouseup']
};

var MimeTypes = {
    jpeg: 'image/jpeg',
    jpg: 'image/jpeg',
    jpe: 'image/jpeg',
    png: 'image/png',
    gif: 'image/gif',
    bmp: 'image/bmp'
};

var ImageExtensionsRegex = /(\.png|\.bmp|\.gif|\.jpg|\.jpe|\.jpg|\.jpeg)$/;

var CanvasExportExtensions = /(jpe|jpg|jpeg|png)/;

// shortcuts
var create = function create(name, className) {
    var node = document.createElement(name);
    if (className) {
        node.className = className;
    }
    return node;
};

// events
var addEvents = function addEvents(obj, events, scope) {
    events.forEach(function (event) {
        obj.addEventListener(event, scope, false);
    });
};

var removeEvents = function removeEvents(obj, events, scope) {
    events.forEach(function (event) {
        obj.removeEventListener(event, scope, false);
    });
};

var getEventOffset = function getEventOffset(e) {
    var event = e.changedTouches ? e.changedTouches[0] : e;

    // no event found, quit!
    if (!event) {
        return;
    }

    // get offset from events
    return {
        x: event.pageX,
        y: event.pageY
    };
};

var rotate = function rotate(rect, angle) {
    var cx = 0.5;
    var cy = 0.5;

    var radians = Math.PI / 180 * angle;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var x1 = rect.x;
    var y1 = rect.y;
    var x2 = rect.x + rect.width;
    var y2 = rect.y + rect.height;

    var rx1 = cos * (x1 - cx) + sin * (y1 - cy) + cx;
    var ry1 = cos * (y1 - cy) - sin * (x1 - cx) + cy;

    var rx2 = cos * (x2 - cx) + sin * (y2 - cy) + cx;
    var ry2 = cos * (y2 - cy) - sin * (x2 - cx) + cy;

    if (rx1 <= rx2) {
        rect.x = rx1;
        rect.width = rx2 - rx1;
    } else {
        rect.x = rx2;
        rect.width = rx1 - rx2;
    }

    if (ry1 <= ry2) {
        rect.y = ry1;
        rect.height = ry2 - ry1;
    } else {
        rect.y = ry2;
        rect.height = ry1 - ry2;
    }
};

var getEventOffsetScroll = function getEventOffsetScroll(e) {
    var offset = getEventOffset(e);
    offset.x -= window.pageXOffset || document.documentElement.scrollLeft;
    offset.y -= window.pageYOffset || document.documentElement.scrollTop;
    return offset;
};

var lowercaseFirstLetter = function lowercaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
};

var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};

var last = function last(array) {
    return array[array.length - 1];
};

var limit = function limit(value, min, max) {
    return Math.max(min, Math.min(max, value));
};

var inArray = function inArray(needle, arr) {
    // is for loop so we can use this method on older browsers to render fallback message
    if (!arr) {
        return false;
    }
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === needle) {
            return true;
        }
    }
    return false;
};

var send = function send(url) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'POST';
    var data = arguments[2];
    var requestDecorator = arguments[3];
    var progress = arguments[4];
    var success = arguments[5];
    var err = arguments[6];

    var xhr = new XMLHttpRequest();

    // if progress callback defined handle progress events
    if (progress) {
        xhr.upload.addEventListener('progress', function (e) {
            progress(e.loaded, e.total);
        });
    }

    // open the request
    xhr.open(method, url, true);

    // if request decorator defined pass XMLHttpRequest instance to decorator
    if (requestDecorator) {
        requestDecorator(xhr, data);
    }

    // handle state changes
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
            var text = xhr.responseText;

            // if no data returned from server assume success
            if (!text.length) {
                success();
                return;
            }

            // catch possible PHP content length problem
            if (text.indexOf('Content-Length') !== -1) {
                err('file-too-big');
                return;
            }

            // if data returned it should be in suggested JSON format
            var obj = void 0;
            try {
                obj = JSON.parse(xhr.responseText);
            } catch (e) {}

            // if is failure response
            if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.status === 'failure') {
                err(obj.message);
                return;
            }

            success(obj || text);
        } else if (xhr.readyState === 4) {
            var _obj = void 0;
            try {
                _obj = JSON.parse(xhr.responseText);
            } catch (e) {}

            // if is clean failure response
            if ((typeof _obj === 'undefined' ? 'undefined' : _typeof(_obj)) === 'object' && _obj.status === 'failure') {
                err(_obj.message);
                return;
            }

            err('fail');
        }
    };

    // do request
    xhr.send(data);
};

var resetTransforms = function resetTransforms(element) {
    if (!element) {
        return;
    }
    element.style.webkitTransform = '';
    element.style.transform = '';
};

var bytesToMegaBytes = function bytesToMegaBytes(b) {
    return b / 1000000;
};

var megaBytesToBytes = function megaBytesToBytes(mb) {
    return mb * 1000000;
};

var getCommonMimeTypes = function getCommonMimeTypes() {
    var types = [];
    var type = void 0;
    var mimeType = void 0;
    for (type in MimeTypes) {
        if (!MimeTypes.hasOwnProperty(type)) {
            continue;
        }
        mimeType = MimeTypes[type];
        if (types.indexOf(mimeType) == -1) {
            types.push(mimeType);
        }
    }
    return types;
};

var isJPEGMimeType = function isJPEGMimeType(type) {
    return type === 'image/jpeg';
};

var getExtensionByMimeType = function getExtensionByMimeType(mimetype) {
    var type = void 0;
    for (type in MimeTypes) {
        if (!MimeTypes.hasOwnProperty(type)) {
            continue;
        }
        if (MimeTypes[type] === mimetype) {
            return type;
        }
    }
    return mimetype;
};

var getMimeTypeFromResponseType = function getMimeTypeFromResponseType(responseType) {
    var type = void 0;
    for (type in MimeTypes) {
        if (!MimeTypes.hasOwnProperty(type)) {
            continue;
        }
        if (responseType.indexOf(MimeTypes[type]) !== -1) {
            return MimeTypes[type];
        }
    }
    return null;
};

var getFileName = function getFileName(path) {
    return path.split('/').pop().split('?').shift();
};

var leftPad = function leftPad(value) {
    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return (padding + value).slice(-padding.length);
};

var getDateString = function getDateString(date) {
    return date.getFullYear() + '-' + leftPad(date.getMonth() + 1, '00') + '-' + leftPad(date.getDate(), '00') + '_' + leftPad(date.getHours(), '00') + '-' + leftPad(date.getMinutes(), '00') + '-' + leftPad(date.getSeconds(), '00');
};

var getFileNameByFile = function getFileNameByFile(file) {
    if (typeof file.name === 'undefined') {
        return getDateString(new Date()) + '.' + getExtensionByMimeType(getFileTypeByFile(file));
    }
    return file.name;
};

var getFileTypeByFile = function getFileTypeByFile(file) {
    return file.type || 'image/jpeg';
};

var getFileNameWithoutExtension = function getFileNameWithoutExtension(path) {
    if (typeof path !== 'string') {
        return getDateString(new Date());
    }
    var name = getFileName(path);
    return name.split('.').shift();
};

var blobToFile = function blobToFile(blob, name) {

    try {
        var file = new File([blob], name, {
            type: blob.type, lastModified: Date.now()
        });
        if (file.size > 0) {
            return file;
        }
    } catch (e) {}

    blob.lastModifiedDate = new Date();
    blob.lastModified = new Date();
    blob.name = name;
    return blob;
};

var resourceIsFetchURL = function resourceIsFetchURL(resource) {
    return (/^fetch\//.test(resource)
    );
};

var resourceIsBase64Data = function resourceIsBase64Data(resource) {
    return (/^data:image/.test(resource)
    );
};

var loadRemoteURL = function loadRemoteURL(fetcher, fetchRequestDecorator, loadRequestDecorator, url, err, cb) {
    fetcher = '' + fetcher + (fetcher.indexOf('?') !== -1 ? '&' : '?') + 'url=' + url;

    var xhr = new XMLHttpRequest();
    xhr.open('GET', fetcher, true);
    fetchRequestDecorator(xhr);
    xhr.responseType = 'json';
    xhr.onload = function () {
        if (this.response.status === 'failure') {
            err(this.response.message);
            return;
        }

        loadURL(this.response.body, loadRequestDecorator, cb);
    };

    xhr.send();
};

var loadURL = function loadURL(url, requestDecorator, cb, err) {

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    requestDecorator(xhr);
    xhr.responseType = 'blob';
    xhr.onload = function (e) {

        if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 0 && this.response instanceof Blob) {

            // continue
            var name = getFileName(url);
            var type = getMimeTypeFromResponseType(this.response.type);

            if (!ImageExtensionsRegex.test(name)) {
                name += '.' + getExtensionByMimeType(type);
            }

            // get as file
            var file = blobToFile(this.response, name);

            // need to set correct type
            cb(cloneFile(file, type));
        } else {
            err(xhr.status + ': ' + xhr.statusText);
        }
    };
    xhr.onerror = function () {
        err();
    };

    xhr.send();
};

var base64ToByteString = function base64ToByteString(dataURI) {
    // get data part of string (remove data:image/jpeg...,)
    var dataPart = dataURI.split(',')[1];

    // remove any whitespace as that causes InvalidCharacterError in IE
    var dataPartCleaned = dataPart.replace(/\s/g, '');

    // to bytestring
    return atob(dataPartCleaned);
};

var base64ToArrayBuffer = function base64ToArrayBuffer(dataURI) {
    var byteString = base64ToByteString(dataURI);
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);

    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return ab;
};

var base64ToBlob = function base64ToBlob(dataURI, filename) {
    var byteString = base64ToByteString(dataURI);
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);

    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    var mimeType = getMimeTypeFromDataURI(dataURI);

    if (typeof filename === 'undefined') {
        filename = getDateString(new Date()) + '.' + getExtensionByMimeType(mimeType);
    }

    return blobToFile(createBlob(ab, mimeType), filename);
};

var createBlob = function createBlob(data, mimeType) {
    var BB = window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

    if (BB) {
        var bb = new BB();
        bb.append(data);
        return bb.getBlob(mimeType);
    }

    return new Blob([data], {
        type: mimeType
    });
};

var arrayBufferConcat = function arrayBufferConcat(buffers) {
    var length = 0;
    var buffer = null;

    for (var i in buffers) {
        if (!_arguments.hasOwnProperty(i)) {
            continue;
        }
        buffer = buffers[i];
        length += buffer.byteLength;
    }

    var joined = new Uint8Array(length);
    var offset = 0;

    for (var _i in buffers) {
        if (!_arguments.hasOwnProperty(_i)) {
            continue;
        }
        buffer = buffers[_i];
        joined.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    }

    return joined.buffer;
};

var getImageAsCanvas = function getImageAsCanvas(src, size, callback) {
    // only cross origin when it's not base64 data, to prevent errors in Safari
    // http://stackoverflow.com/questions/31643096/why-does-safari-throw-cors-error-when-setting-base64-data-on-a-crossorigin-an
    var crossOrigin = typeof src === 'string' ? src.indexOf('data:image') !== 0 : true;

    loadImage.parseMetaData(src, function (meta) {
        var options = {
            canvas: true,
            crossOrigin: crossOrigin
        };

        if (size) {
            options.maxWidth = size.width;
            options.maxHeight = size.height;
        }

        if (meta.exif) {
            options.orientation = meta.exif.get('Orientation');
        }

        loadImage(src, function (res) {
            if (res.type === 'error') {
                callback();
                return;
            }

            callback(res, meta);
        }, options);
    });
};

var getAutoCropRect = function getAutoCropRect(width, height, ratioOut) {
    var x,
        y,
        w,
        h,
        ratioIn = height / width;

    // if input is portrait and required is landscape
    // width is portrait width, height is width times outputRatio
    if (ratioIn < ratioOut) {
        h = height;
        w = h / ratioOut;
        x = (width - w) * 0.5;
        y = 0;
    } else {
        // if input is landscape and required is portrait
        // height is landscape height, width is height divided by outputRatio
        w = width;
        h = w * ratioOut;
        x = 0;
        y = (height - h) * 0.5;
    }

    return {
        x: x,
        y: y,
        height: h,
        width: w
    };
};

var transformCanvas = function transformCanvas(canvas) {
    var transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cb = arguments[2];

    var result = create('canvas');

    var rotation = transforms.rotation,
        crop = transforms.crop,
        size = transforms.size,
        filters = transforms.filters,
        minSize = transforms.minSize;

    // do crop transforms

    if (crop) {
        // do crop
        var isTilted = rotation % 180 !== 0;
        var space = {
            width: isTilted ? canvas.height : canvas.width,
            height: isTilted ? canvas.width : canvas.height
        };

        // limit crop to size of canvas else safari might return transparent image
        if (crop.x < 0) {
            crop.x = 0;
        }

        if (crop.y < 0) {
            crop.y = 0;
        }

        if (crop.width > space.width) {
            crop.width = space.width;
        }

        if (crop.height > space.height) {
            crop.height = space.height;
        }

        if (crop.y + crop.height > space.height) {
            crop.y = Math.max(0, space.height - crop.height);
        }

        if (crop.x + crop.width > space.width) {
            crop.x = Math.max(0, space.width - crop.width);
        }

        // crop offsets in percentages
        var px = crop.x / space.width;
        var py = crop.y / space.height;
        var pw = crop.width / space.width;
        var ph = crop.height / space.height;

        // resize canvas to the final crop result size
        result.width = Math.round(crop.width);
        result.height = Math.round(crop.height);

        // draw the crop
        var ctx = result.getContext('2d');

        if (rotation === 90) {
            ctx.translate(result.width * 0.5, result.height * 0.5);
            ctx.rotate(-90 * Math.PI / 180);
            ctx.drawImage(canvas,

            // source rectangle (crop area)
            (1 - py) * canvas.width - canvas.width * ph, crop.x, crop.height, crop.width,

            // target area (cover)
            -result.height * 0.5, -result.width * 0.5, result.height, result.width);
        } else if (rotation === 180) {
            ctx.translate(result.width * 0.5, result.height * 0.5);
            ctx.rotate(-180 * Math.PI / 180);
            ctx.drawImage(canvas,

            // source rectangle (crop area)
            (1 - (px + pw)) * space.width, (1 - (py + ph)) * space.height, pw * space.width, ph * space.height,

            // target area (cover)
            -result.width * 0.5, -result.height * 0.5, result.width, result.height);
        } else if (rotation === 270) {
            ctx.translate(result.width * 0.5, result.height * 0.5);
            ctx.rotate(-270 * Math.PI / 180);
            ctx.drawImage(canvas,

            // source rectangle (crop area)
            crop.y, (1 - px) * canvas.height - canvas.height * pw, crop.height, crop.width,

            // target area (cover)
            -result.height * 0.5, -result.width * 0.5, result.height, result.width);
        } else {
            ctx.drawImage(canvas,

            // source rectangle (crop area)
            crop.x, crop.y, crop.width, crop.height,

            // target area (cover)
            0, 0, result.width, result.height);
        }
    }

    // do size transforms
    if (size) {
        var scalarX = size.width / result.width;
        var scalarY = size.height / result.height;

        var scalar = Math.min(scalarX, scalarY);

        scaleCanvas(result, scalar, size, minSize);

        // sharpen result
        if (filters.sharpen > 0) {
            filter(result, sharpen(filters.sharpen));
        }
    }

    cb(result);
};

function scaleCanvas(canvas, scalar, bounds, min) {

    // if not scaling down, bail out
    if (scalar >= 1) {
        return;
    }

    var w = canvas.width;
    var h = canvas.height;

    // calculate min target width and height
    var targetWidth = Math.max(min.width, Math.min(bounds.width, Math.round(canvas.width * scalar)));
    var targetHeight = Math.max(min.height, Math.min(bounds.height, Math.round(canvas.height * scalar)));

    var tmp = canvas;
    var ctx = null;

    while (w > targetWidth && h > targetHeight) {

        var c = document.createElement('canvas');
        w = Math.round(tmp.width * .5);
        h = Math.round(tmp.height * .5);

        if (w < targetWidth) {
            w = targetWidth;
        }

        if (h < targetHeight) {
            h = targetHeight;
        }

        c.width = w;
        c.height = h;

        ctx = c.getContext('2d');
        ctx.drawImage(tmp, 0, 0, w, h);

        tmp = c;
        c = null;
    }

    canvas.width = targetWidth;
    canvas.height = targetHeight;

    ctx = canvas.getContext('2d');
    ctx.drawImage(tmp, 0, 0, targetWidth, targetHeight);
}

var getPixels = function getPixels(canvas) {
    var ctx = canvas.getContext('2d');
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
};

var filter = function filter(canvas, _filter) {
    var ctx = canvas.getContext('2d');
    ctx.putImageData(_filter(getPixels(canvas), canvas.width, canvas.height), 0, 0);
};

var createImageData = function createImageData(w, h, pixels) {
    var c = document.createElement('canvas');
    c.width = w;
    c.height = h;
    var ctx = c.getContext('2d');
    var data = ctx.createImageData(c.width, c.height);
    if (pixels) {
        data.set(pixels.data);
    }
    return data;
};

var sharpen = function sharpen(mix) {
    return function (pixels, w, h) {
        var weights = [0, -1, 0, -1, 5, -1, 0, -1, 0],
            katet = Math.round(Math.sqrt(weights.length)),
            half = katet * 0.5 | 0,
            dstData = createImageData(w, h),
            dstBuff = dstData.data,
            srcBuff = pixels.data,
            y = h,
            x = void 0;

        while (y--) {
            x = w;

            while (x--) {
                var sy = y,
                    sx = x,
                    dstOff = (y * w + x) * 4,
                    r = 0,
                    g = 0,
                    b = 0,
                    a = 0;

                for (var cy = 0; cy < katet; cy++) {
                    for (var cx = 0; cx < katet; cx++) {
                        var scy = sy + cy - half;
                        var scx = sx + cx - half;

                        if (scy >= 0 && scy < h && scx >= 0 && scx < w) {
                            var srcOff = (scy * w + scx) * 4;
                            var wt = weights[cy * katet + cx];

                            r += srcBuff[srcOff] * wt;
                            g += srcBuff[srcOff + 1] * wt;
                            b += srcBuff[srcOff + 2] * wt;
                            a += srcBuff[srcOff + 3] * wt;
                        }
                    }
                }

                dstBuff[dstOff] = r * mix + srcBuff[dstOff] * (1 - mix);
                dstBuff[dstOff + 1] = g * mix + srcBuff[dstOff + 1] * (1 - mix);
                dstBuff[dstOff + 2] = b * mix + srcBuff[dstOff + 2] * (1 - mix);
                dstBuff[dstOff + 3] = srcBuff[dstOff + 3];
            }
        }

        return dstData;
    };
};

var sizeDist = function sizeDist(rect, canvas) {
    var dx = Math.abs(rect.width - canvas.width);
    var dy = Math.abs(rect.height - canvas.height);

    return Math.max(dx, dy);
};

var cloneCanvas = function cloneCanvas(original) {
    if (!original) {
        return null;
    }
    var duplicate = document.createElement('canvas');
    var ctx = duplicate.getContext('2d');
    duplicate.width = original.width;
    duplicate.height = original.height;
    ctx.drawImage(original, 0, 0);
    return duplicate;
};

var cloneCanvasScaled = function cloneCanvasScaled(original, scalar) {
    if (!original) {
        return null;
    }

    var duplicate = document.createElement('canvas');
    var ctx = duplicate.getContext('2d');
    duplicate.width = original.width;
    duplicate.height = original.height;
    ctx.drawImage(original, 0, 0);
    if (scalar > 0 && scalar !== 1) {
        scaleCanvas(duplicate, scalar, {
            width: Math.round(original.width * scalar),
            height: Math.round(original.height * scalar)
        }, {
            width: 0,
            height: 0
        });
    }

    return duplicate;
};

var canvasHasDimensions = function canvasHasDimensions(canvas) {
    return canvas.width && canvas.height;
};

var copyCanvas = function copyCanvas(original, destination) {
    var ctx = destination.getContext('2d');
    if (canvasHasDimensions(destination)) {
        ctx.drawImage(original, 0, 0, destination.width, destination.height);
    } else {
        destination.width = original.width;
        destination.height = original.height;
        ctx.drawImage(original, 0, 0);
    }
};

var clearCanvas = function clearCanvas(canvas) {
    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
};

var blurCanvas = function blurCanvas(canvas) {
    stackBlur(canvas, 0, 0, canvas.width, canvas.height, 3);
};

var covers = function covers(image, rect) {
    return parseInt(image.width, 10) >= rect.width && parseInt(image.height, 10) >= rect.height;
};

var scaleRect = function scaleRect(rect, w, h) {
    return {
        x: rect.x * w,
        y: rect.y * h,
        width: rect.width * w,
        height: rect.height * h
    };
};

var divideRect = function divideRect(rect, w, h) {
    return {
        x: rect.x / w,
        y: rect.y / h,
        width: rect.width / w,
        height: rect.height / h
    };
};

var resetFileInput = function resetFileInput(input) {
    // no value, no need to reset
    if (!input || input.value === '') {
        return;
    }

    try {
        // for modern browsers
        input.value = '';
    } catch (err) {}

    // for IE10
    if (input.value) {
        // quickly append input to temp form and reset form
        var form = document.createElement('form');
        var parentNode = input.parentNode;
        var ref = input.nextSibling;
        form.appendChild(input);
        form.reset();

        // re-inject input where it originally was
        if (ref) {
            parentNode.insertBefore(input, ref);
        } else {
            parentNode.appendChild(input);
        }
    }
};

var clone = function clone(obj) {
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {
        return JSON.parse(JSON.stringify(obj));
    }
    return obj;
};

var cloneFile = function cloneFile(file) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (!file) {
        return null;
    }
    var dupe = file.slice(0, file.size, type || file.type);
    dupe.name = file.name;
    dupe.lastModified = new Date(file.lastModified);
    return dupe;
};

var cloneData = function cloneData(obj) {
    var dupe = clone(obj);
    dupe.input.file = cloneFile(obj.input.file);
    dupe.output.image = obj.output.image; ////cloneCanvas(obj.output.image);
    return dupe;
};

/**
 * @param image
 * @param type
 * @param jpegCompression - value between 0 and 100 or undefined/null to use default compression
 * @returns {*}
 */
var toDataURL = function toDataURL(image, type, jpegCompression) {
    if (!image || !type) {
        return null;
    }
    var canvas = image;
    if (image.nodeName === 'IMG') {
        canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        canvas.getContext('2d').drawImage(image, 0, 0);
    }
    return canvas.toDataURL(type, isJPEGMimeType(type) && typeof jpegCompression === 'number' ? jpegCompression / 100 : undefined);
};

var getMimeTypeFromDataURI = function getMimeTypeFromDataURI(dataUri) {
    if (!dataUri) {
        return null;
    }
    var matches = dataUri.substr(0, 16).match(/^.+;/);
    if (matches.length) {
        return matches[0].substring(5, matches[0].length - 1);
    }
    return null;
};

var flattenData = function flattenData(obj) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var jpegCompression = arguments[2];
    var forcedType = arguments[3];
    var async = arguments[4];

    var data = {
        server: clone(obj.server),
        meta: clone(obj.meta),
        input: {
            name: obj.input.name,
            type: obj.input.type,
            size: obj.input.size,
            width: obj.input.width,
            height: obj.input.height,
            field: obj.input.field
        }
    };

    if (inArray('input', props) && !async) {
        data.input.image = toDataURL(obj.input.image, obj.input.type);
    }

    if (inArray('output', props)) {
        data.output = {
            name: forcedType ? getFileNameWithoutExtension(obj.input.name) + '.' + forcedType : obj.input.name,
            type: MimeTypes[forcedType] || obj.input.type,
            width: obj.output.width,
            height: obj.output.height
        };

        data.output.image = toDataURL(obj.output.image, data.output.type, jpegCompression);
        data.output.type = getMimeTypeFromDataURI(data.output.image);

        // browser problem:
        // if output is of type png and input was of type jpeg we need to fix extension of filename
        // so instead of testing the above situation we just always fix extension when handling PNGs
        if (data.output.type === 'image/png') {
            data.output.name = getFileNameWithoutExtension(data.input.name) + '.png';
        }
    }

    if (inArray('actions', props)) {
        data.actions = clone(obj.actions);
    }

    return data;
};

var downloadCanvas = function downloadCanvas(data, jpegCompression, forcedType) {
    var canvas = data.output.image;
    var filename = forcedType ? getFileNameWithoutExtension(data.input.name) + '.' + forcedType : data.input.name;
    var type = MimeTypes[forcedType] || data.input.type;

    // browser problem:
    // if output is of type png and input was of type jpeg we need to fix extension of filename
    // so instead of testing the above situation we just always fix extension when handling PNGs
    if (type === 'image/png') {
        filename = getFileNameWithoutExtension(data.input.name) + '.png';
    }

    canvas.toBlob(function (blob) {
        if ('msSaveBlob' in window.navigator) {
            window.navigator.msSaveBlob(blob, filename);
            return;
        }

        var url = (window.URL || window.webkitURL).createObjectURL(blob);

        // setup hidden link
        var link = create('a');
        link.style.display = 'none';
        link.download = filename;
        link.href = url;

        // attach to DOM otherwise this does not work in Firefox
        document.body.appendChild(link);

        // fire click
        link.click();

        // delay on remove otherwise does not work in Firefox
        setTimeout(function () {
            document.body.removeChild(link);
            (window.URL || window.webkitURL).revokeObjectURL(url);
        }, 0);
    }, type, typeof jpegCompression === 'number' ? jpegCompression / 100 : undefined);
};

var toggleDisplayBySelector = function toggleDisplayBySelector(selector, enabled, root) {
    var node = root.querySelector(selector);
    if (!node) {
        return;
    }
    node.style.display = enabled ? '' : 'none';
};

var nodeListToArray = function nodeListToArray(nl) {
    return Array.prototype.slice.call(nl);
};

var removeElement = function removeElement(el) {
    el.parentNode.removeChild(el);
};

var wrap = function wrap(element) {
    var wrapper = create('div');
    if (element.parentNode) {
        if (element.nextSibling) {
            element.parentNode.insertBefore(wrapper, element.nextSibling);
        } else {
            element.parentNode.appendChild(wrapper);
        }
    }
    wrapper.appendChild(element);
    return wrapper;
};

var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
    };
};

var describeArc = function describeArc(x, y, radius, startAngle, endAngle) {
    var start = polarToCartesian(x, y, radius, endAngle);
    var end = polarToCartesian(x, y, radius, startAngle);

    var arcSweep = endAngle - startAngle <= 180 ? '0' : '1';

    var d = ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');

    return d;
};

var percentageArc = function percentageArc(x, y, radius, p) {
    return describeArc(x, y, radius, 0, p * 360);
};

var CropArea = function () {
    var resizers = {
        n: function n(rect, offset, space, ratio) {
            var t, r, b, l, w, h, p, d;

            // bottom is fixed
            b = rect.y + rect.height;

            // intended top
            t = limit(offset.y, 0, b);

            // if is too small vertically
            if (b - t < space.min.height) {
                t = b - space.min.height;
            }

            // if should scale by ratio, pick width by ratio of new height
            w = ratio ? (b - t) / ratio : rect.width;

            // check if has fallen below min width or height
            if (w < space.min.width) {
                w = space.min.width;
                t = b - w * ratio;
            }

            // add half to left and half to right edge
            p = (w - rect.width) * 0.5;
            l = rect.x - p;
            r = rect.x + rect.width + p;

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (l < 0 || Math.round(r) > Math.round(space.width)) {
                // smallest distance to edge of space
                d = Math.min(rect.x, space.width - (rect.x + rect.width));

                // new left and right offsets
                l = rect.x - d;
                r = rect.x + rect.width + d;

                // resulting width
                w = r - l;

                // resulting height based on ratio
                h = w * ratio;

                // new top position
                t = b - h;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        s: function s(rect, offset, space, ratio) {
            var t, r, b, l, w, h, p, d;

            // top is fixed
            t = rect.y;

            // intended bottom
            b = limit(offset.y, t, space.height);

            // if is too small vertically
            if (b - t < space.min.height) {
                b = t + space.min.height;
            }

            // if should scale by ratio, pick width by ratio of new height
            w = ratio ? (b - t) / ratio : rect.width;

            // check if has fallen below min width or height
            if (w < space.min.width) {
                w = space.min.width;
                b = t + w * ratio;
            }

            // add half to left and half to right edge
            p = (w - rect.width) * 0.5;
            l = rect.x - p;
            r = rect.x + rect.width + p;

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (l < 0 || Math.round(r) > Math.round(space.width)) {
                // smallest distance to edge of space
                d = Math.min(rect.x, space.width - (rect.x + rect.width));

                // new left and right offsets
                l = rect.x - d;
                r = rect.x + rect.width + d;

                // resulting width
                w = r - l;

                // resulting height based on ratio
                h = w * ratio;

                // new bottom position
                b = t + h;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        e: function e(rect, offset, space, ratio) {
            var t, r, b, l, w, h, p, d;

            // left is fixed
            l = rect.x;

            // intended right edge
            r = limit(offset.x, l, space.width);

            // if is too small vertically
            if (r - l < space.min.width) {
                r = l + space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : rect.height;

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                r = l + h / ratio;
            }

            // add half to top and bottom
            p = (h - rect.height) * 0.5;
            t = rect.y - p;
            b = rect.y + rect.height + p;

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new top and bottom offsets
                t = rect.y - d;
                b = rect.y + rect.height + d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new right position
                r = l + w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        w: function w(rect, offset, space, ratio) {
            var t, r, b, l, w, h, p, d;

            // right is fixed
            r = rect.x + rect.width;

            // intended left edge
            l = limit(offset.x, 0, r);

            // if is too small vertically
            if (r - l < space.min.width) {
                l = r - space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : rect.height;

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                l = r - h / ratio;
            }

            // add half to top and bottom
            p = (h - rect.height) * 0.5;
            t = rect.y - p;
            b = rect.y + rect.height + p;

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new top and bottom offsets
                t = rect.y - d;
                b = rect.y + rect.height + d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new right position
                l = r - w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        ne: function ne(rect, offset, space, ratio) {
            var t, r, b, l, w, h, d;

            // left and bottom are fixed
            l = rect.x;
            b = rect.y + rect.height;

            // intended right edge
            r = limit(offset.x, l, space.width);

            // if is too small vertically
            if (r - l < space.min.width) {
                r = l + space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : limit(b - offset.y, space.min.height, b);

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                r = l + h / ratio;
            }

            // add height difference with original height to top
            t = rect.y - (h - rect.height);

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new top and bottom offsets
                t = rect.y - d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new right position
                r = l + w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        se: function se(rect, offset, space, ratio) {
            var t, r, b, l, w, h, d;

            // left and top are fixed
            l = rect.x;
            t = rect.y;

            // intended right edge
            r = limit(offset.x, l, space.width);

            // if is too small vertically
            if (r - l < space.min.width) {
                r = l + space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : limit(offset.y - rect.y, space.min.height, space.height - t);

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                r = l + h / ratio;
            }

            // add height difference with original height to bottom
            b = rect.y + rect.height + (h - rect.height);

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new bottom offset
                b = rect.y + rect.height + d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new right position
                r = l + w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        sw: function sw(rect, offset, space, ratio) {
            var t, r, b, l, w, h, d;

            // right and top are fixed
            r = rect.x + rect.width;
            t = rect.y;

            // intended left edge
            l = limit(offset.x, 0, r);

            // if is too small vertically
            if (r - l < space.min.width) {
                l = r - space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : limit(offset.y - rect.y, space.min.height, space.height - t);

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                l = r - h / ratio;
            }

            // add height difference with original height to bottom
            b = rect.y + rect.height + (h - rect.height);

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new bottom offset
                b = rect.y + rect.height + d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new left position
                l = r - w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        },
        nw: function nw(rect, offset, space, ratio) {
            var t, r, b, l, w, h, d;

            // right and bottom are fixed
            r = rect.x + rect.width;
            b = rect.y + rect.height;

            // intended left edge
            l = limit(offset.x, 0, r);

            // if is too small vertically
            if (r - l < space.min.width) {
                l = r - space.min.width;
            }

            // if should scale by ratio, pick height by ratio of new width
            h = ratio ? (r - l) * ratio : limit(b - offset.y, space.min.height, b);

            // check if has fallen below min width or height
            if (h < space.min.height) {
                h = space.min.height;
                l = r - h / ratio;
            }

            // add height difference with original height to bottom
            t = rect.y - (h - rect.height);

            // check if any of the edges has moved out of the available space, if so,
            // set max size of rectangle from original position
            if (t < 0 || Math.round(b) > Math.round(space.height)) {
                // smallest distance to edge of space
                d = Math.min(rect.y, space.height - (rect.y + rect.height));

                // new bottom offset
                t = rect.y - d;

                // resulting height
                h = b - t;

                // resulting width based on ratio
                w = h / ratio;

                // new left position
                l = r - w;
            }

            return {
                x: l,
                y: t,
                width: r - l,
                height: b - t
            };
        }
    };

    /**
     * CropArea
     */
    return function () {
        function CropArea() {
            var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.createElement('div');

            _classCallCheck(this, CropArea);

            this._element = element;

            this._interaction = null;

            this._minWidth = 1;
            this._minHeight = 1;

            this._ratio = null;

            this._rect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };

            this._space = {
                width: 0,
                height: 0
            };

            this._rectChanged = false;

            this._init();
        }

        _createClass(CropArea, [{
            key: '_init',
            value: function _init() {
                this._element.className = 'slim-crop-area';

                // lines
                var lines = create('div', 'grid');
                this._element.appendChild(lines);

                // corner & edge resize buttons
                for (var handler in resizers) {
                    if (!resizers.hasOwnProperty(handler)) {
                        continue;
                    }
                    var _btn = create('button', handler);
                    this._element.appendChild(_btn);
                }
                var btn = create('button', 'c');
                this._element.appendChild(btn);

                addEvents(document, Events.DOWN, this);
            }
        }, {
            key: 'reset',
            value: function reset() {
                this._interaction = null;

                this._rect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };

                this._rectChanged = true;

                this._redraw();

                this._element.dispatchEvent(new CustomEvent('change'));
            }
        }, {
            key: 'rescale',
            value: function rescale(scale) {
                // no rescale
                if (scale === 1) {
                    return;
                }

                this._interaction = null;

                this._rectChanged = true;

                this._rect.x *= scale;
                this._rect.y *= scale;
                this._rect.width *= scale;
                this._rect.height *= scale;

                this._redraw();

                this._element.dispatchEvent(new CustomEvent('change'));
            }
        }, {
            key: 'limit',
            value: function limit(width, height) {
                this._space.width = width;
                this._space.height = height;
            }
        }, {
            key: 'offset',
            value: function offset(x, y) {
                this._space.x = x;
                this._space.y = y;
            }
        }, {
            key: 'resize',
            value: function resize(x, y, width, height) {
                this._interaction = null;

                this._rect = {
                    x: limit(x, 0, this._space.width - this._minWidth),
                    y: limit(y, 0, this._space.height - this._minHeight),
                    width: limit(width, this._minWidth, this._space.width),
                    height: limit(height, this._minHeight, this._space.height)
                };

                this._rectChanged = true;

                this._redraw();

                this._element.dispatchEvent(new CustomEvent('change'));
            }
        }, {
            key: 'handleEvent',
            value: function handleEvent(e) {
                switch (e.type) {
                    case 'touchstart':
                    case 'pointerdown':
                    case 'mousedown':
                        {
                            this._onStartDrag(e);
                        }
                        break;
                    case 'touchmove':
                    case 'pointermove':
                    case 'mousemove':
                        {
                            this._onDrag(e);
                        }
                        break;
                    case 'touchend':
                    case 'touchcancel':
                    case 'pointerup':
                    case 'mouseup':
                        {
                            this._onStopDrag(e);
                        }
                }
            }
        }, {
            key: '_onStartDrag',
            value: function _onStartDrag(e) {
                // is not my event?
                if (!this._element.contains(e.target)) {
                    return;
                }

                e.preventDefault();

                // listen to drag related events
                addEvents(document, Events.MOVE, this);
                addEvents(document, Events.UP, this);

                this._interaction = {
                    type: e.target.className,
                    offset: getEventOffsetScroll(e)
                };

                this._interaction.offset.x -= this._rect.x;
                this._interaction.offset.y -= this._rect.y;

                // now dragging
                this._element.setAttribute('data-dragging', 'true');

                // start the redraw update loop
                this._redraw();
            }
        }, {
            key: '_onDrag',
            value: function _onDrag(e) {
                e.preventDefault();

                // get local offset for this event
                var offset = getEventOffsetScroll(e);
                var type = this._interaction.type;

                // drag
                if (type === 'c') {
                    this._rect.x = limit(offset.x - this._interaction.offset.x, 0, this._space.width - this._rect.width);
                    this._rect.y = limit(offset.y - this._interaction.offset.y, 0, this._space.height - this._rect.height);
                } else if (resizers[type]) {
                    // resize
                    this._rect = resizers[type](this._rect, {
                        x: offset.x - this._space.x,
                        y: offset.y - this._space.y
                    }, {
                        x: 0,
                        y: 0,
                        width: this._space.width,
                        height: this._space.height,
                        min: {
                            width: this._minWidth,
                            height: this._minHeight
                        }
                    }, this._ratio);
                }

                this._rectChanged = true;

                // dispatch
                this._element.dispatchEvent(new CustomEvent('input'));
            }
        }, {
            key: '_onStopDrag',
            value: function _onStopDrag(e) {
                e.preventDefault();

                // stop listening to drag related events
                removeEvents(document, Events.MOVE, this);
                removeEvents(document, Events.UP, this);

                // no longer interacting, so no need to redraw
                this._interaction = null;

                // now dragging
                this._element.setAttribute('data-dragging', 'false');

                // fire change event
                this._element.dispatchEvent(new CustomEvent('change'));
            }
        }, {
            key: '_redraw',
            value: function _redraw() {
                var _this = this;

                if (this._rectChanged) {
                    var transform = 'translate(' + this._rect.x + 'px,' + this._rect.y + 'px);';
                    this._element.style.cssText = '\n\t\t\t\t\t-webkit-transform: ' + transform + ';\n\t\t\t\t\ttransform: ' + transform + ';\n\t\t\t\t\twidth:' + this._rect.width + 'px;\n\t\t\t\t\theight:' + this._rect.height + 'px;\n\t\t\t\t';

                    this._rectChanged = false;
                }

                // if no longer interacting with crop area stop here
                if (!this._interaction) {
                    return;
                }

                // redraw
                requestAnimationFrame(function () {
                    return _this._redraw();
                });
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this._interaction = false;
                this._rectChanged = false;

                removeEvents(document, Events.DOWN, this);
                removeEvents(document, Events.MOVE, this);
                removeEvents(document, Events.UP, this);

                removeElement(this._element);
            }
        }, {
            key: 'element',
            get: function get() {
                return this._element;
            }
        }, {
            key: 'space',
            get: function get() {
                return this._space;
            }
        }, {
            key: 'area',
            get: function get() {
                var x = this._rect.x / this._space.width;
                var y = this._rect.y / this._space.height;
                var width = this._rect.width / this._space.width;
                var height = this._rect.height / this._space.height;

                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                };
            }
        }, {
            key: 'dirty',
            get: function get() {
                return this._rect.x !== 0 || this._rect.y !== 0 || this._rect.width !== 0 || this._rect.height !== 0;
            }
        }, {
            key: 'minWidth',
            set: function set(value) {
                this._minWidth = Math.max(value, 1);
            }
        }, {
            key: 'minHeight',
            set: function set(value) {
                this._minHeight = Math.max(value, 1);
            }
        }, {
            key: 'ratio',
            set: function set(value) {
                this._ratio = value;
            }
        }]);

        return CropArea;
    }();
}();

var ImageEditor = function () {
    /**
     * ImageEditor
     * @param element
     * @param options
     * @constructor
     */

    var CropAreaEvents = ['input', 'change'];

    var ImageEditor = function () {
        function ImageEditor() {
            var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.createElement('div');
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            _classCallCheck(this, ImageEditor);

            this._element = element;
            this._options = mergeOptions(ImageEditor.options(), options);

            this._ratio = null;
            this._output = null;
            this._rotating = false;

            this._input = null;

            this._preview = null;
            this._previewBlurred = null;

            this._blurredPreview = false;

            this._cropper = null;
            this._straightCrop = null;
            this._previewWrapper = null;
            this._currentWindowSize = {};

            this._btnGroup = null;
            this._maskFrame = null;

            this._dirty = false;

            this._wrapperRotation = 0;
            this._wrapperScale = 1.0;

            this._init();
        }

        _createClass(ImageEditor, [{
            key: '_init',
            value: function _init() {
                var _this2 = this;

                this._element.className = 'slim-image-editor';

                // container
                this._container = create('div', 'slim-container');

                // wrapper
                this._wrapper = create('div', 'slim-wrapper');

                // photo crop mark container
                this._stage = create('div', 'slim-stage');
                this._container.appendChild(this._stage);

                // create crop marks
                this._cropper = new CropArea();
                CropAreaEvents.forEach(function (e) {
                    _this2._cropper.element.addEventListener(e, _this2);
                });
                this._stage.appendChild(this._cropper.element);

                // canvas ghost
                this._previewWrapper = create('div', 'slim-image-editor-preview slim-crop-preview');
                this._previewBlurred = create('canvas', 'slim-crop-blur');
                this._previewWrapper.appendChild(this._previewBlurred);
                this._wrapper.appendChild(this._previewWrapper);

                this._previewMask = create('div', 'slim-crop-mask');
                this._preview = create('img');
                this._previewMask.appendChild(this._preview);
                this._cropper.element.appendChild(this._previewMask);

                // buttons
                this._btnGroup = create('div', 'slim-editor-btn-group');
                ImageEditor.Buttons.forEach(function (c) {
                    var prop = capitalizeFirstLetter(c);
                    var label = _this2._options['button' + prop + 'Label'];
                    var title = _this2._options['button' + prop + 'Title'];
                    var className = _this2._options['button' + prop + 'ClassName'];
                    var btn = create('button', 'slim-editor-btn slim-btn-' + c + (className ? ' ' + className : ''));
                    btn.innerHTML = label;
                    btn.title = title || label;
                    btn.type = 'button';
                    btn.setAttribute('data-action', c);
                    btn.addEventListener('click', _this2);
                    _this2._btnGroup.appendChild(btn);
                });

                // utils
                this._utilsGroup = create('div', 'slim-editor-utils-group');

                // create rotation button
                var btn = create('button', 'slim-editor-utils-btn slim-btn-rotate' + (this._options.buttonRotateClassName ? ' ' + this._options.buttonRotateClassName : ''));
                btn.setAttribute('data-action', 'rotate');
                btn.addEventListener('click', this);
                btn.title = this._options.buttonRotateTitle;
                this._utilsGroup.appendChild(btn);

                this._container.appendChild(this._wrapper);

                this._element.appendChild(this._container);
                this._element.appendChild(this._utilsGroup);
                this._element.appendChild(this._btnGroup);
            }
        }, {
            key: 'dirty',
            value: function dirty() {
                this._dirty = true;
            }
        }, {
            key: 'handleEvent',
            value: function handleEvent(e) {
                switch (e.type) {
                    case 'click':
                        this._onClick(e);
                        break;
                    case 'change':
                        this._onGridChange(e);
                        break;
                    case 'input':
                        this._onGridInput(e);
                        break;
                    case 'keydown':
                        this._onKeyDown(e);
                        break;
                    case 'resize':
                        this._onResize(e);
                        break;
                }
            }
        }, {
            key: '_onKeyDown',
            value: function _onKeyDown(e) {
                switch (e.keyCode) {
                    case Key.RETURN:
                        {
                            this._confirm();
                            break;
                        }
                    case Key.ESC:
                        {
                            this._cancel();
                            break;
                        }
                }
            }
        }, {
            key: '_onClick',
            value: function _onClick(e) {
                if (e.target.classList.contains('slim-btn-cancel')) {
                    this._cancel();
                }

                if (e.target.classList.contains('slim-btn-confirm')) {
                    this._confirm();
                }

                if (e.target.classList.contains('slim-btn-rotate')) {
                    this._rotate();
                }
            }
        }, {
            key: '_onResize',
            value: function _onResize() {
                // remember window size
                this._currentWindowSize = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };

                // redraw the image editor based on new dimensions
                this._redraw();

                this._redrawCropper(this._cropper.area);

                this._updateWrapperScale();

                // apply rotation and scale
                this._redrawWrapper();
            }
        }, {
            key: '_redrawWrapper',
            value: function _redrawWrapper() {
                var matrix = snabbt.createMatrix();
                matrix.scale(this._wrapperScale, this._wrapperScale);
                matrix.rotateZ(this._wrapperRotation * (Math.PI / 180));
                snabbt.setElementTransform(this._previewWrapper, matrix);
            }
        }, {
            key: '_onGridInput',
            value: function _onGridInput() {
                this._redrawCropMask();
            }
        }, {
            key: '_onGridChange',
            value: function _onGridChange() {
                this._redrawCropMask();
            }
        }, {
            key: '_updateWrapperRotation',
            value: function _updateWrapperRotation() {
                if (this._options.minSize.width > this._input.height || this._options.minSize.height > this._input.width) {
                    this._wrapperRotation += 180;
                } else {
                    this._wrapperRotation += 90;
                }
            }
        }, {
            key: '_updateWrapperScale',
            value: function _updateWrapperScale() {
                // test if is tilted
                var isTilted = this._wrapperRotation % 180 !== 0;

                // if tilted determine correct scale factor
                if (isTilted) {
                    // maximum size
                    var maxWidth = this._container.offsetWidth;
                    var maxHeight = this._container.offsetHeight;

                    // get wrapper size
                    var wrapperWidth = this._wrapper.offsetHeight;
                    var wrapperHeight = this._wrapper.offsetWidth;

                    var scalar = maxWidth / wrapperWidth;
                    if (scalar * wrapperHeight > maxHeight) {
                        scalar = maxHeight / wrapperHeight;
                    }

                    this._wrapperScale = scalar;
                } else {
                    this._wrapperScale = 1.0;
                }
            }

            /**
             * Action handlers
             */

        }, {
            key: '_cancel',
            value: function _cancel() {
                if (this._rotating) {
                    return;
                }

                this._element.dispatchEvent(new CustomEvent('cancel'));
            }
        }, {
            key: '_confirm',
            value: function _confirm() {
                if (this._rotating) {
                    return;
                }

                var isTilted = this._wrapperRotation % 180 !== 0;
                var area = this._cropper.area;

                var result = scaleRect(area, isTilted ? this._input.height : this._input.width, isTilted ? this._input.width : this._input.height);

                this._element.dispatchEvent(new CustomEvent('confirm', {
                    detail: {
                        rotation: this._wrapperRotation % 360,
                        crop: result
                    }
                }));
            }
        }, {
            key: '_rotate',
            value: function _rotate() {
                var _this3 = this;

                if (this._rotating) {
                    return;
                }

                this._rotating = true;

                // rotate!
                this._updateWrapperRotation();

                // only pass current rect if is 1:1 or free
                var rect = this.ratio === 1 || this._ratio === null ? this._cropper.area : null;
                if (rect) {
                    rotate(rect, 90);
                }

                // wrapper might also need to be scaled
                this._updateWrapperScale();

                // hide the cropper
                this._hideCropper();

                // rotation effect
                snabbt(this._previewWrapper, {
                    rotation: [0, 0, this._wrapperRotation * (Math.PI / 180)],
                    scale: [this._wrapperScale, this._wrapperScale],
                    easing: 'spring',
                    springConstant: 0.8,
                    springDeceleration: 0.65,
                    complete: function complete() {
                        // redraws auto cropper
                        _this3._redrawCropper(rect);

                        // shows the cropper
                        _this3._showCropper();

                        // done rotating
                        _this3._rotating = false;
                    }
                });
            }
        }, {
            key: '_showCropper',
            value: function _showCropper() {
                snabbt(this._stage, {
                    easing: 'ease',
                    duration: 250,
                    fromOpacity: 0,
                    opacity: 1.0
                });
            }
        }, {
            key: '_hideCropper',
            value: function _hideCropper() {
                snabbt(this._stage, {
                    duration: 0,
                    fromOpacity: 0,
                    opacity: 0
                });
            }
        }, {
            key: '_redrawCropMask',
            value: function _redrawCropMask() {
                var _this4 = this;

                // get rotation
                var rotation = this._wrapperRotation % 360;

                // get scale
                var scale = this._wrapperScale;

                // get image size
                var canvas = {
                    width: this._wrapper.offsetWidth,
                    height: this._wrapper.offsetHeight
                };

                // get default mask cropper area
                var mask = this._cropper.area;
                var preview = {
                    x: 0,
                    y: 0
                };

                if (rotation === 0) {
                    preview.x = -mask.x;
                    preview.y = -mask.y;
                } else if (rotation === 90) {
                    preview.x = -(1 - mask.y);
                    preview.y = -mask.x;
                } else if (rotation === 180) {
                    preview.x = -(1 - mask.x);
                    preview.y = -(1 - mask.y);
                } else if (rotation === 270) {
                    preview.x = -mask.y;
                    preview.y = -(1 - mask.x);
                }

                // scale rect to fit canvas
                preview.x *= canvas.width;
                preview.y *= canvas.height;

                // update on next frame (so it's in sync with crop area redraw)
                cancelAnimationFrame(this._maskFrame);
                this._maskFrame = requestAnimationFrame(function () {
                    var transform = 'scale(' + scale + ') rotate(' + -rotation + 'deg) translate(' + preview.x + 'px, ' + preview.y + 'px);';
                    _this4._preview.style.cssText = '\n\t\t\t\t\twidth: ' + _this4._previewSize.width + 'px;\n\t\t\t\t\theight: ' + _this4._previewSize.height + 'px;\n\t\t\t\t\t-webkit-transform: ' + transform + ';\n\t\t\t\t\ttransform: ' + transform + ';\n\t\t\t\t';
                });
            }
        }, {
            key: 'open',
            value: function open(image, ratio, crop, rotation, complete) {
                var _this5 = this;

                // test if is same image and same rotation
                if (this._input && !this._dirty && this._ratio === ratio && this._wrapperRotation === rotation) {
                    complete();
                    return;
                }

                // remember current window size
                this._currentWindowSize = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };

                // reset dirty value
                this._dirty = false;

                // reset rotation
                this._wrapperRotation = rotation || 0;

                // we'll always have to blur the preview of a newly opened image
                this._blurredPreview = false;

                // set ratio
                this._ratio = ratio;

                // reset preview size
                this._previewSize = null;

                // hide editor
                this._element.style.opacity = '0';

                // set as new input image
                this._input = image;

                // calculate crop
                var tilted = this._wrapperRotation % 180 !== 0;
                var relativeCrop = divideRect(crop, tilted ? image.height : image.width, tilted ? image.width : image.height);

                // preview has now loaded
                this._preview.onload = function () {
                    // reset onload listener
                    _this5._preview.onload = null;

                    // setup cropper
                    _this5._cropper.ratio = _this5.ratio;

                    // redraw view (for first time)
                    _this5._redraw();

                    // redraw cropper
                    _this5._redrawCropper(relativeCrop);

                    // done
                    complete();

                    // fade in
                    _this5._element.style.opacity = '';
                };

                // load lower resolution preview image
                this._preview.src = '';
                this._preview.src = cloneCanvasScaled(this._input, Math.min(this._container.offsetWidth / this._input.width, this._container.offsetHeight / this._input.height) * this._options.devicePixelRatio).toDataURL();
            }
        }, {
            key: '_redrawCropper',
            value: function _redrawCropper(rect) {
                var isTilted = this._wrapperRotation % 180 !== 0;

                // image ratio
                var imageRatio = isTilted ? this._input.height / this._input.width : this._input.width / this._input.height;

                // get dimensions of image wrapper
                var width = this._wrapper.offsetWidth;
                var height = this._wrapper.offsetHeight;

                // get space
                var maxWidth = this._container.offsetWidth;
                var maxHeight = this._container.offsetHeight;

                // rescale wrapper
                this._updateWrapperScale();

                // position cropper container to fit wrapper
                var sw = this._wrapperScale * (isTilted ? height : width);
                var sh = this._wrapperScale * (isTilted ? width : height);
                var sx = isTilted ? (maxWidth - sw) * 0.5 : this._wrapper.offsetLeft;
                var sy = isTilted ? (maxHeight - sh) * 0.5 : this._wrapper.offsetTop;

                this._stage.style.cssText = '\n\t\t\t\tleft:' + sx + 'px;\n\t\t\t\ttop:' + sy + 'px;\n\t\t\t\twidth:' + sw + 'px;\n\t\t\t\theight:' + sh + 'px;\n\t\t\t';

                // set new size limit for crops
                // use image ratio so we have exact amount of pixels
                this._cropper.limit(sw, sw / imageRatio);
                this._cropper.offset(sx + this._element.offsetLeft, sy + this._element.offsetTop);

                // set min and max height of cropper
                this._cropper.minWidth = this._wrapperScale * this._options.minSize.width * this.scalar;
                this._cropper.minHeight = this._wrapperScale * this._options.minSize.height * this.scalar;

                // set crop rect
                var crop = null;
                if (rect) {
                    crop = {
                        x: rect.x * sw,
                        y: rect.y * sh,
                        width: rect.width * sw,
                        height: rect.height * sh
                    };
                } else {
                    crop = getAutoCropRect(sw, sh, this._ratio || sh / sw);
                }

                this._cropper.resize(crop.x, crop.y, crop.width, crop.height);
            }
        }, {
            key: '_redraw',
            value: function _redraw() {
                // image ratio
                var ratio = this._input.height / this._input.width;

                // determine rounded size
                var maxWidth = this._container.clientWidth;
                var maxHeight = this._container.clientHeight;

                var width = maxWidth;
                var height = width * ratio;

                if (height > maxHeight) {
                    height = maxHeight;
                    width = height / ratio;
                }

                width = Math.round(width);
                height = Math.round(height);

                // rescale and recenter wrapper
                var x = (maxWidth - width) / 2;
                var y = (maxHeight - height) / 2;

                this._wrapper.style.cssText = '\n\t\t\t\tleft:' + x + 'px;\n\t\t\t\ttop:' + y + 'px;\n\t\t\t\twidth:' + width + 'px;\n\t\t\t\theight:' + height + 'px;\n\t\t\t';

                // set image size based on container dimensions
                this._previewBlurred.style.cssText = '\n\t\t\t\twidth:' + width + 'px;\n\t\t\t\theight:' + height + 'px;\n\t\t\t';

                this._preview.style.cssText = '\n\t\t\t\twidth:' + width + 'px;\n\t\t\t\theight:' + height + 'px;\n\t\t\t';

                this._previewSize = {
                    width: width,
                    height: height
                };

                // scale and blur the blurry preview
                if (!this._blurredPreview) {
                    this._previewBlurred.width = 300;
                    this._previewBlurred.height = this._previewBlurred.width * ratio;

                    copyCanvas(this._input, this._previewBlurred);

                    blurCanvas(this._previewBlurred, 3);

                    this._blurredPreview = true;
                }
            }
        }, {
            key: 'show',
            value: function show() {
                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

                // test if window size has changed since previous showing
                if (this._currentWindowSize.width !== window.innerWidth || this._currentWindowSize.height !== window.innerHeight) {
                    // if so, reposition elements
                    this._redraw();

                    // redraw cropper position
                    this._redrawCropper(this._cropper.area);
                }

                // listen to keydown so we can close or confirm with RETURN / ESC
                document.addEventListener('keydown', this);

                // when window is scaled we want to resize the editor
                window.addEventListener('resize', this);

                // fade in preview
                var rotation = this._wrapperRotation * (Math.PI / 180);
                snabbt(this._previewWrapper, {
                    fromRotation: [0, 0, rotation],
                    rotation: [0, 0, rotation],
                    fromPosition: [0, 0, 0],
                    position: [0, 0, 0],
                    fromOpacity: 0,
                    opacity: 1,
                    fromScale: [this._wrapperScale - 0.02, this._wrapperScale - 0.02],
                    scale: [this._wrapperScale, this._wrapperScale],
                    easing: 'spring',
                    springConstant: 0.3,
                    springDeceleration: 0.85,
                    delay: 450,
                    complete: function complete() {
                        // don't reset transforms because we need rotation to stick
                    }
                });

                if (this._cropper.dirty) {
                    // now show cropper
                    snabbt(this._stage, {
                        fromPosition: [0, 0, 0],
                        position: [0, 0, 0],
                        fromOpacity: 0,
                        opacity: 1,
                        duration: 250,
                        delay: 850,
                        complete: function complete() {
                            resetTransforms(this);
                            callback();
                        }
                    });
                } else {
                    // now show cropper
                    snabbt(this._stage, {
                        fromPosition: [0, 0, 0],
                        position: [0, 0, 0],
                        fromOpacity: 0,
                        opacity: 1,
                        duration: 250,
                        delay: 1000,
                        complete: function complete() {
                            resetTransforms(this);
                        }
                    });
                }

                // now show buttons
                snabbt(this._btnGroup.childNodes, {
                    fromScale: [0.9, 0.9],
                    scale: [1, 1],
                    fromOpacity: 0,
                    opacity: 1,
                    delay: function delay(i) {
                        return 1000 + i * 100;
                    },
                    easing: 'spring',
                    springConstant: 0.3,
                    springDeceleration: 0.85,
                    complete: function complete() {
                        resetTransforms(this);
                    }
                });

                snabbt(this._utilsGroup.childNodes, {
                    fromScale: [0.9, 0.9],
                    scale: [1, 1],
                    fromOpacity: 0,
                    opacity: 1,
                    easing: 'spring',
                    springConstant: 0.3,
                    springDeceleration: 0.85,
                    delay: 1250,
                    complete: function complete() {
                        resetTransforms(this);
                    }
                });
            }
        }, {
            key: 'hide',
            value: function hide() {
                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

                // no more need to listen to keydown
                document.removeEventListener('keydown', this);

                // no more need to resize editor when window is scaled
                window.removeEventListener('resize', this);

                // fade out buttons
                snabbt(this._utilsGroup.childNodes, {
                    fromOpacity: 1,
                    opacity: 0,
                    duration: 250
                });

                snabbt(this._btnGroup.childNodes, {
                    fromOpacity: 1,
                    opacity: 0,
                    delay: 200,
                    duration: 350
                });

                snabbt([this._stage, this._previewWrapper], {
                    fromPosition: [0, 0, 0],
                    position: [0, -250, 0],
                    fromOpacity: 1,
                    opacity: 0,
                    easing: 'spring',
                    springConstant: 0.3,
                    springDeceleration: 0.75,
                    delay: 250,
                    allDone: function allDone() {
                        callback();
                    }
                });
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                var _this6 = this;

                nodeListToArray(this._btnGroup.children).forEach(function (btn) {
                    btn.removeEventListener('click', _this6);
                });

                CropAreaEvents.forEach(function (e) {
                    _this6._cropper.element.removeEventListener(e, _this6);
                });

                this._cropper.destroy();

                // if still attached to DOM, detach
                if (this._element.parentNode) {
                    removeElement(this._element);
                }
            }
        }, {
            key: 'showRotateButton',
            set: function set(enabled) {
                if (enabled) {
                    this._element.classList.remove('slim-rotation-disabled');
                } else {
                    this._element.classList.add('slim-rotation-disabled');
                }
            }
        }, {
            key: 'element',
            get: function get() {
                return this._element;
            }
        }, {
            key: 'ratio',
            get: function get() {
                if (this._ratio === 'input') {
                    return this._input.height / this._input.width;
                }
                return this._ratio;
            }
        }, {
            key: 'offset',
            get: function get() {
                return this._element.getBoundingClientRect();
            }
        }, {
            key: 'original',
            get: function get() {
                return this._input;
            }
        }, {
            key: 'scalar',
            get: function get() {
                return this._previewSize.width / this._input.width;
            }
        }], [{
            key: 'options',
            value: function options() {
                return {
                    buttonCancelClassName: null,
                    buttonConfirmClassName: null,
                    buttonCancelLabel: 'Cancel',
                    buttonConfirmLabel: 'Confirm',
                    buttonCancelTitle: null,
                    buttonConfirmTitle: null,

                    buttonRotateTitle: 'Rotate',
                    buttonRotateClassName: null,

                    devicePixelRatio: null,

                    minSize: {
                        width: 0,
                        height: 0
                    }
                };
            }
        }]);

        return ImageEditor;
    }();

    ImageEditor.Buttons = ['cancel', 'confirm'];

    return ImageEditor;
}(CropArea);

var FileHopper = function () {
    /**
     * FileHopper
     * @param element
     * @param options
     * @constructor
     */
    var DragDropEvents = ['dragenter', 'dragover', 'dragleave', 'drop'];

    return function () {
        function FileHopper() {
            var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.createElement('div');

            _classCallCheck(this, FileHopper);

            this._element = element;
            this._accept = [];
            this._allowURLs = false;

            this._dragPath = null;

            this._init();
        }

        // public properties


        _createClass(FileHopper, [{
            key: 'isValidDataTransfer',
            value: function isValidDataTransfer(dataTransfer) {
                if (dataTransfer.files && dataTransfer.files.length) {
                    return this.areValidDataTransferFiles(dataTransfer.files);
                }

                if (dataTransfer.items && dataTransfer.items.length) {
                    return this.areValidDataTransferItems(dataTransfer.items);
                }

                return null;
            }
        }, {
            key: 'areValidDataTransferFiles',
            value: function areValidDataTransferFiles(files) {
                if (this._accept.length && files) {
                    return this._accept.indexOf(files[0].type) !== -1;
                }
                return true;
            }
        }, {
            key: 'areValidDataTransferItems',
            value: function areValidDataTransferItems(items) {
                if (this._accept.length && items) {
                    // is possibly dropping url
                    if (this._allowURLs && items[0].kind === 'string') {
                        return null;
                    }

                    // is http website so firefox will not return file type
                    if (items[0].type && items[0].type.indexOf('application') === 0) {
                        return null;
                    }

                    return this._accept.indexOf(items[0].type) !== -1;
                }

                return true;
            }

            // public methods

        }, {
            key: 'reset',
            value: function reset() {
                this._element.files = null;
            }

            // private

        }, {
            key: '_init',
            value: function _init() {
                var _this7 = this;

                this._element.className = 'slim-file-hopper';

                DragDropEvents.forEach(function (e) {
                    _this7._element.addEventListener(e, _this7);
                });
            }

            // the input has changed

        }, {
            key: 'handleEvent',
            value: function handleEvent(e) {
                switch (e.type) {
                    case 'dragenter':
                    case 'dragover':
                        this._onDragOver(e);
                        break;
                    case 'dragleave':
                        this._onDragLeave(e);
                        break;
                    case 'drop':
                        this._onDrop(e);
                        break;
                }
            }
        }, {
            key: '_onDrop',
            value: function _onDrop(e) {
                // prevents browser from opening image
                e.preventDefault();

                // test if a url was dropped
                var remote = null;

                if (this._allowURLs) {
                    var url = void 0;
                    var meta = void 0;
                    try {
                        url = e.dataTransfer.getData('url');
                        meta = e.dataTransfer.getData('text/html');
                    } catch (e) {
                        // nope nope nope (ie11 trouble)
                    }

                    if (meta && meta.length) {
                        var parsed = meta.match(/src\s*=\s*"(.+?)"/);
                        if (parsed) {
                            remote = parsed[1];
                        }
                    } else if (url && url.length) {
                        remote = url;
                    }
                }

                if (remote) {
                    this._element.files = [{ remote: remote }];
                } else {
                    // nope, must have been a file
                    // test type in older browsers
                    var filesValidity = this.isValidDataTransfer(e.dataTransfer);
                    if (!filesValidity) {
                        // invalid files, stop here
                        this._element.dispatchEvent(new CustomEvent('file-invalid-drop'));

                        // no longer hovering
                        this._dragPath = null;
                        return;
                    }

                    // store dropped files on element files property, so can be accessed by same function as file input handler
                    this._element.files = e.dataTransfer.files;
                }

                // file has been dropped
                this._element.dispatchEvent(new CustomEvent('file-drop', {
                    detail: getOffsetByEvent(e)
                }));

                // file list has changed, let's notify others
                this._element.dispatchEvent(new CustomEvent('change'));

                // no longer hovering
                this._dragPath = null;
            }
        }, {
            key: '_onDragOver',
            value: function _onDragOver(e) {
                // prevents browser from opening image
                e.preventDefault();

                // set drop effect
                e.dataTransfer.dropEffect = 'copy';

                // determin if is valid data
                var dataValidity = this.isValidDataTransfer(e.dataTransfer);
                // if validity is null is undetermined
                if (dataValidity !== null && !dataValidity) {
                    // indicate drop mode to user
                    e.dataTransfer.dropEffect = 'none';

                    // invalid files, stop here
                    this._element.dispatchEvent(new CustomEvent('file-invalid'));
                    return;
                }

                // now hovering file over the area
                if (!this._dragPath) {
                    this._dragPath = [];
                }

                // push location
                this._dragPath.push(getOffsetByEvent(e));

                // file is hovering over element
                this._element.dispatchEvent(new CustomEvent('file-over', {
                    detail: {
                        x: last(this._dragPath).x,
                        y: last(this._dragPath).y
                    }
                }));
            }
        }, {
            key: '_onDragLeave',
            value: function _onDragLeave(e) {
                // user has dragged file out of element area
                this._element.dispatchEvent(new CustomEvent('file-out', {
                    detail: getOffsetByEvent(e)
                }));

                // now longer hovering file
                this._dragPath = null;
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                var _this8 = this;

                DragDropEvents.forEach(function (e) {
                    _this8._element.removeEventListener(e, _this8);
                });

                removeElement(this._element);

                this._element = null;
                this._dragPath = null;
                this._accept = null;
            }
        }, {
            key: 'element',
            get: function get() {
                return this._element;
            }
        }, {
            key: 'dragPath',
            get: function get() {
                return this._dragPath;
            }
        }, {
            key: 'enabled',
            get: function get() {
                return this._element.style.display === '';
            },
            set: function set(value) {
                this._element.style.display = value ? '' : 'none';
            }
        }, {
            key: 'allowURLs',
            set: function set(value) {
                this._allowURLs = value;
            }
        }, {
            key: 'accept',
            set: function set(mimetypes) {
                this._accept = mimetypes;
            },
            get: function get() {
                return this._accept;
            }
        }]);

        return FileHopper;
    }();
}();

var Popover = function () {
    /**
     * Popover
     */
    return function () {
        function Popover() {
            _classCallCheck(this, Popover);

            this._element = null;
            this._inner = null;

            this._init();
        }

        _createClass(Popover, [{
            key: '_init',
            value: function _init() {
                this._element = create('div', 'slim-popover');
                this._element.setAttribute('data-state', 'off');
                document.body.appendChild(this._element);

                // prevent body scrolling on iOS 11.3
                this._element.addEventListener('touchmove', function (e) {
                    e.preventDefault();
                }, true);
            }
        }, {
            key: 'show',
            value: function show() {
                var _this9 = this;

                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

                // turn on
                this._element.setAttribute('data-state', 'on');

                // show and animate in
                snabbt(this._element, {
                    fromOpacity: 0,
                    opacity: 1,
                    duration: 350,
                    complete: function complete() {
                        // clean up transforms
                        resetTransforms(_this9._element);

                        // ready!
                        callback();
                    }
                });
            }
        }, {
            key: 'hide',
            value: function hide() {
                var _this10 = this;

                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

                // animate out and hide
                snabbt(this._element, {
                    fromOpacity: 1,
                    opacity: 0,
                    duration: 500,
                    complete: function complete() {
                        // clean up transforms
                        resetTransforms(_this10._element);

                        // hide the editor
                        _this10._element.setAttribute('data-state', 'off');

                        // ready!
                        callback();
                    }
                });
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                if (!this._element.parentNode) {
                    return;
                }
                this._element.parentNode.removeChild(this._element);
                this._element = null;
                this._inner = null;
            }
        }, {
            key: 'inner',
            set: function set(element) {
                this._inner = element;
                if (this._element.firstChild) {
                    this._element.removeChild(this._element.firstChild);
                }
                this._element.appendChild(this._inner);
            }
        }, {
            key: 'className',
            set: function set(value) {
                this._element.className = 'slim-popover' + (value === null ? '' : ' ' + value);
            }
        }]);

        return Popover;
    }();
}();

var intSplit = function intSplit(v, c) {
    return v.split(c).map(function (v) {
        return parseInt(v, 10);
    });
};

var isWrapper = function isWrapper(element) {
    return element.nodeName === 'DIV' || element.nodeName === 'SPAN';
};

var CropType = {
    AUTO: 'auto',
    INITIAL: 'initial',
    MANUAL: 'manual'
};

var Rect = ['x', 'y', 'width', 'height'];

var HopperEvents = ['file-invalid-drop', 'file-invalid', 'file-drop', 'file-over', 'file-out', 'click'];

var ImageEditorEvents = ['cancel', 'confirm'];

var SlimButtons = ['remove', 'edit', 'download', 'upload'];

var SlimPopover = null;
var SlimCount = 0;

var SlimLoaderHTML = '\n<div class="slim-loader">\n\t<svg>\n\t\t<path class="slim-loader-background" fill="none" stroke-width="3" />\n\t\t<path class="slim-loader-foreground" fill="none" stroke-width="3" />\n\t</svg>\n</div>\n';

var SlimUploadStatusHTML = '\n<div class="slim-upload-status"></div>\n';

var stringToSize = function stringToSize(str) {
    var size = str.split(',');
    return {
        width: parseInt(size[0], 10),
        height: parseInt(size[1], 10)
    };
};

var removeTimer = function removeTimer(timers, timer) {
    var i = timers.indexOf(timer);
    timers.splice(i, 1);
};

var Slim = function () {
    function Slim(element) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Slim);

        // create popover element if not already created
        if (!SlimPopover) {
            SlimPopover = new Popover();
        }

        // we create a new counter, we use this counter to determine if we need to clean up the popover
        this._uid = SlimCount++;

        // the options to use
        this._options = mergeOptions(Slim.options(), options);

        // test options correctness
        if (this._options.forceSize) {
            if (typeof this._options.forceSize === 'string') {
                this._options.forceSize = stringToSize(this._options.forceSize);
            }
            this._options.ratio = this._options.forceSize.width + ':' + this._options.forceSize.height;
            this._options.size = clone(this._options.forceSize);
        }

        // test for size set as string
        if (typeof this._options.size === 'string') {
            this._options.size = stringToSize(this._options.size);
        }

        // test for size set as string
        if (typeof this._options.minSize === 'string') {
            this._options.minSize = stringToSize(this._options.minSize);
        }

        // fix post formatting if is supplied as string
        if (typeof this._options.post === 'string') {
            this._options.post = this._options.post.split(',').map(function (part) {
                return part.trim();
            });
        }

        // reference to original element so we can restore original situation
        this._originalElement = element;
        this._originalElementInner = element.innerHTML;
        this._originalElementAttributes = getElementAttributes(element);

        // should be file input, image or slim wrapper, if not wrapper, wrap
        if (!isWrapper(element)) {
            this._element = wrap(element);
            this._element.className = element.className;
            element.className = '';

            // ratio is used for CSS so let's set default attribute
            this._element.setAttribute('data-ratio', this._options.ratio);
        } else {
            this._element = element;
        }
        this._element.classList.add('slim');
        this._element.setAttribute('data-state', 'init');

        // editor state
        this._state = [];

        // internal timer array for async processes
        this._timers = [];

        // the source element (can either be an input or an img)
        this._input = null;

        // the source element unique name if is input type file
        this._inputReference = null;

        // the output element (hidden input that contains the resulting json object)
        this._output = null;

        // current image ratio
        this._ratio = null;

        // was required field
        this._isRequired = false;

        // components
        this._imageHopper = null;
        this._imageEditor = null;

        // progress path
        this._progressEnabled = true;

        // resulting data
        this._data = {};
        this._resetData();

        // the circle below the mouse hover point
        this._drip = null;

        // had initial image
        this._hasInitialImage = false;

        // initial crop
        this._initialCrop = this._options.crop;

        // initial rotation
        this._initialRotation = this._options.rotation && this._options.rotation % 90 === 0 ? this._options.rotation : null;

        // set to true when destroy method is called, used to halt any timeouts or async processes
        this._isBeingDestroyed = false;

        // stop here if not supported
        if (!Slim.supported) {
            this._fallback();
        } else {
            // let's go!
            this._init();
        }
    }

    _createClass(Slim, [{
        key: 'setRotation',
        value: function setRotation(rotation, callback) {
            if (typeof rotation !== 'number' && rotation % 90 !== 0) {
                return;
            }

            this._data.actions.rotation = rotation;
            var isTilted = this._data.actions.rotation % 180 !== 0;

            if (this._data.input.image) {
                var w = isTilted ? this._data.input.image.height : this._data.input.image.width;
                var h = isTilted ? this._data.input.image.width : this._data.input.image.height;
                this._data.actions.crop = getAutoCropRect(w, h, this._ratio);
                this._data.actions.crop.type = CropType.AUTO;
            }

            if (this._data.input.image && callback) {
                this._manualTransform(callback);
            }
        }
    }, {
        key: 'setSize',
        value: function setSize(dimensions, callback) {
            if (typeof dimensions === 'string') {
                dimensions = stringToSize(dimensions);
            }

            if (!dimensions || !dimensions.width || !dimensions.height) {
                return;
            }

            this._options.size = clone(dimensions);
            this._data.actions.size = clone(dimensions);

            // if a crop area is set do re-crop to conform to size
            if (this._data.input.image && callback) {
                this._manualTransform(callback);
            }
        }
    }, {
        key: 'setForceSize',
        value: function setForceSize(dimensions, callback) {
            if (typeof dimensions === 'string') {
                dimensions = stringToSize(dimensions);
            }

            if (!dimensions || !dimensions.width || !dimensions.height) {
                return;
            }

            this._options.size = clone(dimensions);
            this._options.forceSize = clone(dimensions);
            this._data.actions.size = clone(dimensions);

            this.setRatio(this._options.forceSize.width + ':' + this._options.forceSize.height, callback);
        }
    }, {
        key: 'setRatio',
        value: function setRatio(ratio, callback) {
            var _this11 = this;

            if (!ratio || typeof ratio !== 'string') {
                return;
            }

            this._options.ratio = ratio;

            if (this._isFixedRatio()) {

                var parts = intSplit(this._options.ratio, ':');
                this._ratio = parts[1] / parts[0];

                if (this._data.input.image && callback) {
                    this._cropAuto(function (data) {
                        _this11._scaleDropArea(_this11._ratio);
                        if (callback) {
                            callback(data);
                        }
                    });
                } else {
                    if (this._data.input.image) {
                        this._data.actions.crop = getAutoCropRect(this._data.input.image.width, this._data.input.image.height, this._ratio);
                        this._data.actions.crop.type = CropType.AUTO;
                    }

                    this._scaleDropArea(this._ratio);

                    if (callback) {
                        callback(null);
                    }
                }
            }
        }

        // methods
        // Test if this Slim object has been bound to the given element

    }, {
        key: 'isAttachedTo',
        value: function isAttachedTo(element) {
            return this._element === element || this._originalElement === element;
        }
    }, {
        key: 'isDetached',
        value: function isDetached() {
            return this._element.parentNode === null;
        }
    }, {
        key: 'load',
        value: function load(src) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var callback = arguments[2];

            if (typeof options === 'function') {
                callback = options;
            } else {
                // store in options
                this._options.crop = options.crop;

                // set rotation
                this._options.rotation = options.rotation;

                // initial rotation
                this._initialRotation = options.rotation && options.rotation % 90 === 0 ? options.rotation : null;

                // set initial crop
                this._initialCrop = this._options.crop;
            }

            this._load(src, callback, { blockPush: options.blockPush });
        }
    }, {
        key: 'upload',
        value: function upload(callback) {
            this._doUpload(callback);
        }
    }, {
        key: 'download',
        value: function download() {
            this._doDownload();
        }
    }, {
        key: 'remove',
        value: function remove() {
            return this._doRemove();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this._doDestroy();
        }
    }, {
        key: 'edit',
        value: function edit() {
            this._doEdit();
        }
    }, {
        key: 'crop',
        value: function crop(rect, callback) {
            this._crop(rect.x, rect.y, rect.width, rect.height, callback);
        }
    }, {
        key: 'containsImage',
        value: function containsImage() {
            return this._data.input.name !== null;
        }

        /**
         * State Related
         */

    }, {
        key: '_canInstantEdit',
        value: function _canInstantEdit() {
            return this._options.instantEdit && !this._isInitialising;
        }
    }, {
        key: '_getFileInput',
        value: function _getFileInput() {
            return this._element.querySelector('input[type=file]');
        }
    }, {
        key: '_getInitialImage',
        value: function _getInitialImage() {
            return this._element.querySelector('img');
        }
    }, {
        key: '_getInputElement',
        value: function _getInputElement() {
            return this._getFileInput() || this._getInitialImage();
        }
    }, {
        key: '_getRatioSpacerElement',
        value: function _getRatioSpacerElement() {
            return this._element.children[0];
        }
    }, {
        key: '_isImageOnly',
        value: function _isImageOnly() {
            return this._input.nodeName !== 'INPUT';
        }
    }, {
        key: '_isFixedRatio',
        value: function _isFixedRatio() {
            return this._options.ratio.indexOf(':') !== -1;
        }
    }, {
        key: '_isAutoCrop',
        value: function _isAutoCrop() {
            return this._data.actions.crop.type === CropType.AUTO;
        }
    }, {
        key: '_toggleButton',
        value: function _toggleButton(action, state) {
            toggleDisplayBySelector('.slim-btn[data-action="' + action + '"]', state, this._element);
        }
    }, {
        key: '_clearState',
        value: function _clearState() {
            this._state = [];
            this._updateState();
        }
    }, {
        key: '_removeState',
        value: function _removeState(state) {
            this._state = this._state.filter(function (item) {
                return item !== state;
            });
            this._updateState();
        }
    }, {
        key: '_addState',
        value: function _addState(state) {
            if (inArray(state, this._state)) {
                return;
            }
            this._state.push(state);
            this._updateState();
        }
    }, {
        key: '_updateState',
        value: function _updateState() {
            if (!this._element) {
                return;
            }
            this._element.setAttribute('data-state', this._state.join(','));
        }
    }, {
        key: '_resetData',
        value: function _resetData() {
            // resets data object
            this._data = {
                server: null,
                meta: clone(this._options.meta),
                input: {
                    field: this._inputReference,
                    name: null,
                    type: null,
                    width: 0,
                    height: 0,
                    file: null
                },
                output: {
                    image: null,
                    width: 0,
                    height: 0
                },
                actions: {
                    rotation: null,
                    crop: null,
                    size: null
                }
            };

            // resets hidden input clone (has not yet been created when reset call in constructor, hence the check)
            if (this._output) {
                this._output.value = '';
            }

            // should reset file input
            resetFileInput(this._getFileInput());
        }

        /**
         * Initialisation
         */

    }, {
        key: '_init',
        value: function _init() {
            var _this12 = this;

            // busy initialising
            this._isInitialising = true;

            // cropper root is not file input
            this._addState('empty');

            // define input reference field name
            if (inArray('input', this._options.post)) {
                this._inputReference = 'slim_input_' + this._uid;
            }

            // get input element
            this._input = this._getInputElement();

            // if no input supplied we'll automatically create one
            if (!this._input) {
                this._input = create('input');
                this._input.type = 'file';
                this._element.appendChild(this._input);
            }

            // get required state of input element
            this._isRequired = this._input.required === true;

            // set or create output field
            this._output = this._element.querySelector('input[type=hidden]');

            // if no output element defined we'll create one automagically
            if (!this._output) {
                this._output = create('input');
                this._output.type = 'hidden';
                this._output.name = this._input.name || this._options.defaultInputName;
                this._element.appendChild(this._output);
            } else {
                var initialData = null;
                try {
                    initialData = JSON.parse(this._output.value);
                } catch (e) {}
                if (initialData) {
                    var img = new Image();
                    img.src = initialData.output.image;
                    img.setAttribute('data-filename', initialData.output.name);
                    this._element.insertBefore(img, this._element.firstChild);
                }
            }

            // prevent the original file input field from posting (value will be duplicated to output field)
            this._input.removeAttribute('name');

            // create drop area
            var area = create('div', 'slim-area');

            // test if contains initial image
            var initialImage = this._getInitialImage();
            var initialImageSrc = (initialImage || {}).src;
            var initialImageName = initialImage ? initialImage.getAttribute('data-filename') : null;

            if (initialImageSrc) {
                this._hasInitialImage = true;
            } else {
                this._initialCrop = null;
                this._initialRotation = null;
            }

            var resultHTML = '\n\t\t<div class="slim-result">\n\t\t\t<img class="in" style="opacity:0" ' + (initialImageSrc ? 'src="' + initialImageSrc + '"' : '') + '><img><img style="opacity:0">\n\t\t</div>';

            // add drop overlay
            if (this._isImageOnly()) {
                area.innerHTML = '\n\t\t\t\t' + SlimLoaderHTML + '\n\t\t\t\t' + SlimUploadStatusHTML + '\n\t\t\t\t' + resultHTML + '\n\t\t\t\t<div class="slim-status"><div class="slim-label-loading">' + (this._options.labelLoading || '') + '</div></div>\n\t\t\t';
            } else {
                // if should post input data
                if (inArray('input', this._options.post)) {
                    this._data.input.field = this._inputReference;

                    // if is sync post
                    // and should post input data
                    if (!this._options.service) {
                        this._input.name = this._inputReference;
                    }
                }

                // set common image mime type to the accept attribute
                var mimetypes = void 0;
                if (!this._input.hasAttribute('accept') || this._input.getAttribute('accept') === 'image/*') {
                    mimetypes = getCommonMimeTypes();
                    this._input.setAttribute('accept', mimetypes.join(','));
                } else {
                    mimetypes = this._input.accept.split(',').map(function (mimetype) {
                        return mimetype.trim();
                    }).filter(function (mimetype) {
                        return mimetype.length > 0;
                    });
                }

                // setup hopper
                this._imageHopper = new FileHopper();
                this._imageHopper.accept = mimetypes;
                this._imageHopper.allowURLs = typeof this._options.fetcher === 'string';
                this._element.appendChild(this._imageHopper.element);
                HopperEvents.forEach(function (e) {
                    _this12._imageHopper.element.addEventListener(e, _this12);
                });

                // render area
                area.innerHTML = '\n\t\t\t\t' + SlimLoaderHTML + '\n\t\t\t\t' + SlimUploadStatusHTML + '\n\t\t\t\t<div class="slim-drip"><span><span></span></span></div>\n\t\t\t\t<div class="slim-status"><div class="slim-label">' + (this._options.label || '') + '</div><div class="slim-label-loading">' + (this._options.labelLoading || '') + '</div></div>\n\t\t\t\t' + resultHTML + '\n\t\t\t';

                // start listening for events so we can load image on file input change
                this._input.addEventListener('change', this);
            }

            // add area node
            this._element.appendChild(area);

            // add button group
            this._btnGroup = create('div', 'slim-btn-group');
            this._btnGroup.style.display = 'none';
            this._element.appendChild(this._btnGroup);
            SlimButtons.filter(function (c) {
                return _this12._isButtonAllowed(c);
            }).forEach(function (c) {
                var prop = capitalizeFirstLetter(c);
                var label = _this12._options['button' + prop + 'Label'];
                var title = _this12._options['button' + prop + 'Title'] || label;
                var className = _this12._options['button' + prop + 'ClassName'];
                var btn = create('button', 'slim-btn slim-btn-' + c + (className ? ' ' + className : ''));
                btn.innerHTML = label;
                btn.title = title;
                btn.type = 'button';
                btn.addEventListener('click', _this12);
                btn.setAttribute('data-action', c);
                _this12._btnGroup.appendChild(btn);
            });

            // add ratio padding
            if (this._isFixedRatio()) {
                var parts = intSplit(this._options.ratio, ':');
                this._ratio = parts[1] / parts[0];
                this._scaleDropArea(this._ratio);
            }

            // setup loader
            this._updateProgress(0.5);

            // preload source
            if (initialImageSrc) {
                this._load(initialImageSrc, function () {
                    _this12._onInit();
                }, { name: initialImageName });
            } else {
                this._onInit();
            }
        }
    }, {
        key: '_onInit',
        value: function _onInit() {
            var _this13 = this;

            // we're done initialising
            this._isInitialising = false;

            // done initialising now, else is only called after image load
            var done = function done() {
                // we call this async so the constructor of Slim has returned before the onInit is called, allowing clean immidiate destroy
                var timer = setTimeout(function () {
                    removeTimer(_this13._timers, timer);
                    _this13._options.didInit.apply(_this13, [_this13.data, _this13]);
                }, 0);
                _this13._timers.push(timer);
            };

            // save initial image
            if (this._options.saveInitialImage && this.containsImage()) {
                if (!this._options.service) {
                    this._save(function () {
                        done();
                    }, false);
                }
            } else {
                // by default upload button is disabled for existing images
                if (this._options.service && this.containsImage()) {
                    this._toggleButton('upload', false);
                }

                done();
            }
        }
    }, {
        key: '_updateProgress',
        value: function _updateProgress(progress) {
            progress = Math.min(0.99999, progress);

            if (!this._element) {
                return;
            }

            if (!this._progressEnabled) {
                return;
            }

            var loader = this._element.querySelector('.slim-loader');
            if (!loader) {
                return;
            }

            var size = loader.offsetWidth;
            var paths = loader.querySelectorAll('path');
            var ringWidth = parseInt(paths[0].getAttribute('stroke-width'), 10);

            // loader is not visible yet
            if (size * .5 < ringWidth) {
                return;
            }

            paths[0].setAttribute('d', percentageArc(size * 0.5, size * 0.5, size * 0.5 - ringWidth, 0.9999));

            paths[1].setAttribute('d', percentageArc(size * 0.5, size * 0.5, size * 0.5 - ringWidth, progress));
        }
    }, {
        key: '_startProgress',
        value: function _startProgress(cb) {
            var _this14 = this;

            if (!this._element) {
                return;
            }

            this._progressEnabled = false;

            var loader = this._element.querySelector('.slim-loader');
            if (!loader) {
                return;
            }
            var ring = loader.children[0];

            this._stopProgressLoop(function () {
                loader.removeAttribute('style');
                ring.removeAttribute('style');

                _this14._progressEnabled = true;

                _this14._updateProgress(0);

                _this14._progressEnabled = false;

                snabbt(ring, {
                    fromOpacity: 0,
                    opacity: 1,
                    duration: 250,
                    complete: function complete() {
                        _this14._progressEnabled = true;
                        if (cb) {
                            cb();
                        }
                    }
                });
            });
        }
    }, {
        key: '_stopProgress',
        value: function _stopProgress() {
            var _this15 = this;

            if (!this._element) {
                return;
            }

            var loader = this._element.querySelector('.slim-loader');
            if (!loader) {
                return;
            }
            var ring = loader.children[0];

            this._updateProgress(1);

            snabbt(ring, {
                fromOpacity: 1,
                opacity: 0,
                duration: 250,
                complete: function complete() {
                    loader.removeAttribute('style');
                    ring.removeAttribute('style');

                    _this15._updateProgress(0.5);

                    _this15._progressEnabled = false;
                }
            });
        }
    }, {
        key: '_startProgressLoop',
        value: function _startProgressLoop() {
            if (!this._element) {
                return;
            }

            // start loading animation
            var loader = this._element.querySelector('.slim-loader');
            if (!loader) {
                return;
            }

            var ring = loader.children[0];
            loader.removeAttribute('style');
            ring.removeAttribute('style');

            // set infinite load state
            this._updateProgress(0.5);

            // repeat!
            var repeat = 1000;

            snabbt(loader, 'stop');

            snabbt(loader, {
                rotation: [0, 0, -(Math.PI * 2) * repeat],
                easing: 'linear',
                duration: repeat * 1000
            });

            snabbt(ring, {
                fromOpacity: 0,
                opacity: 1,
                duration: 250
            });
        }
    }, {
        key: '_stopProgressLoop',
        value: function _stopProgressLoop(callback) {
            if (!this._element) {
                return;
            }

            var loader = this._element.querySelector('.slim-loader');
            if (!loader) {
                return;
            }

            var ring = loader.children[0];

            snabbt(ring, {
                fromOpacity: parseFloat(ring.style.opacity),
                opacity: 0,
                duration: 250,
                complete: function complete() {
                    snabbt(loader, 'stop');

                    loader.removeAttribute('style');
                    ring.removeAttribute('style');

                    if (callback) {
                        callback();
                    }
                }
            });
        }
    }, {
        key: '_isButtonAllowed',
        value: function _isButtonAllowed(button) {
            if (button === 'edit') {
                return this._options.edit;
            }

            if (button === 'download') {
                return this._options.download;
            }

            if (button === 'upload') {
                // if no service defined upload button makes no sense
                if (!this._options.service) {
                    return false;
                }

                // if push mode is set, no need for upload button
                if (this._options.push) {
                    return false;
                }

                // set upload button
                return true;
            }

            if (button === 'remove') {
                return !this._isImageOnly();
            }

            return true;
        }
    }, {
        key: '_fallback',
        value: function _fallback() {
            // create status area
            var area = create('div', 'slim-area');
            area.innerHTML = '\n\t\t\t<div class="slim-status"><div class="slim-label">' + (this._options.label || '') + '</div></div>\n\t\t';
            this._element.appendChild(area);

            this._throwError(this._options.statusNoSupport);
        }

        /**
         * Event routing
         */

    }, {
        key: 'handleEvent',
        value: function handleEvent(e) {
            switch (e.type) {
                case 'click':
                    this._onClick(e);
                    break;
                case 'change':
                    this._onChange(e);
                    break;
                case 'cancel':
                    this._onCancel(e);
                    break;
                case 'confirm':
                    this._onConfirm(e);
                    break;
                case 'file-over':
                    this._onFileOver(e);
                    break;
                case 'file-out':
                    this._onFileOut(e);
                    break;
                case 'file-drop':
                    this._onDropFile(e);
                    break;
                case 'file-invalid':
                    this._onInvalidFile(e);
                    break;
                case 'file-invalid-drop':
                    this._onInvalidFileDrop(e);
                    break;
            }
        }
    }, {
        key: '_getIntro',
        value: function _getIntro() {
            return this._element.querySelector('.slim-result .in');
        }
    }, {
        key: '_getOutro',
        value: function _getOutro() {
            return this._element.querySelector('.slim-result .out');
        }
    }, {
        key: '_getInOut',
        value: function _getInOut() {
            return this._element.querySelectorAll('.slim-result img');
        }
    }, {
        key: '_getDrip',
        value: function _getDrip() {
            if (!this._drip) {
                this._drip = this._element.querySelector('.slim-drip > span');
            }
            return this._drip;
        }

        // errors

    }, {
        key: '_throwError',
        value: function _throwError(error) {
            this._addState('error');

            this._element.querySelector('.slim-label').style.display = 'none';

            var node = this._element.querySelector('.slim-error');
            if (!node) {
                node = create('div', 'slim-error');
                this._element.querySelector('.slim-status').appendChild(node);
            }

            node.innerHTML = error;

            this._options.didThrowError.apply(this, [error]);
        }
    }, {
        key: '_removeError',
        value: function _removeError() {
            this._removeState('error');
            this._element.querySelector('.slim-label').style.display = '';

            var error = this._element.querySelector('.slim-error');
            if (error) {
                error.parentNode.removeChild(error);
            }
        }
    }, {
        key: '_openFileDialog',
        value: function _openFileDialog() {
            this._removeError();
            this._input.click();
        }

        // drop area clicked

    }, {
        key: '_onClick',
        value: function _onClick(e) {
            var _this16 = this;

            var list = e.target.classList;
            var target = e.target;

            // no preview, so possible to drop file
            if (list.contains('slim-file-hopper')) {
                e.preventDefault();
                this._openFileDialog();
                return;
            }

            // decide what button was clicked
            switch (target.getAttribute('data-action')) {
                case 'remove':
                    this._options.willRemove.apply(this, [this.data, function () {
                        _this16._doRemove();
                    }]);
                    break;
                case 'edit':
                    this._doEdit();
                    break;
                case 'download':
                    this._doDownload();
                    break;
                case 'upload':
                    this._doUpload();
                    break;
            }
        }
    }, {
        key: '_onInvalidFileDrop',
        value: function _onInvalidFileDrop() {
            this._onInvalidFile();

            this._removeState('file-over');

            // animate out drip
            var drip = this._getDrip();
            snabbt(drip.firstChild, {
                fromScale: [0.5, 0.5],
                scale: [0, 0],
                fromOpacity: 0.5,
                opacity: 0,
                duration: 150,
                complete: function complete() {
                    // clean up transforms
                    resetTransforms(drip.firstChild);
                }
            });
        }
    }, {
        key: '_onInvalidFile',
        value: function _onInvalidFile() {
            var types = this._imageHopper.accept.map(getExtensionByMimeType);
            var error = this._options.statusFileType.replace('$0', types.join(', '));
            this._throwError(error);
        }
    }, {
        key: '_onImageTooSmall',
        value: function _onImageTooSmall() {
            var error = this._options.statusImageTooSmall.replace('$0', this._options.minSize.width + ' \xD7 ' + this._options.minSize.height);
            this._throwError(error);
        }
    }, {
        key: '_onOverWeightFile',
        value: function _onOverWeightFile() {
            var error = this._options.statusFileSize.replace('$0', this._options.maxFileSize);
            this._throwError(error);
        }
    }, {
        key: '_onLocalURLProblem',
        value: function _onLocalURLProblem(error) {
            this._throwError(this._options.statusLocalUrlProblem || error);
        }
    }, {
        key: '_onRemoteURLProblem',
        value: function _onRemoteURLProblem(error) {
            this._throwError(error);
        }
    }, {
        key: '_onFileOver',
        value: function _onFileOver(e) {
            this._addState('file-over');
            this._removeError();

            // animations
            var drip = this._getDrip();

            // move around drip
            var matrix = snabbt.createMatrix();
            matrix.translate(e.detail.x, e.detail.y, 0);
            snabbt.setElementTransform(drip, matrix);

            // on first entry fade in blob
            if (this._imageHopper.dragPath.length == 1) {
                // show
                drip.style.opacity = 1;

                // animate in
                snabbt(drip.firstChild, {
                    fromOpacity: 0,
                    opacity: 0.5,
                    fromScale: [0, 0],
                    scale: [0.5, 0.5],
                    duration: 150
                });
            }
        }
    }, {
        key: '_onFileOut',
        value: function _onFileOut(e) {
            this._removeState('file-over');
            this._removeState('file-invalid');
            this._removeError();

            // move to last position
            var drip = this._getDrip();
            var matrix = snabbt.createMatrix();
            matrix.translate(e.detail.x, e.detail.y, 0);
            snabbt.setElementTransform(drip, matrix);

            // animate out
            snabbt(drip.firstChild, {
                fromScale: [0.5, 0.5],
                scale: [0, 0],
                fromOpacity: 0.5,
                opacity: 0,
                duration: 150,
                complete: function complete() {
                    // clean up transforms
                    resetTransforms(drip.firstChild);
                }
            });
        }

        /**
         * When a file was literally dropped on the drop area
         * @param e
         * @private
         */

    }, {
        key: '_onDropFile',
        value: function _onDropFile(e) {
            var _this17 = this;

            this._removeState('file-over');

            // get drip node reference and set to last position
            var drip = this._getDrip();
            var matrix = snabbt.createMatrix();
            matrix.translate(e.detail.x, e.detail.y, 0);
            snabbt.setElementTransform(drip, matrix);

            // get element minimum 10 entries distant from the last entry so we can calculate velocity of movement
            var l = this._imageHopper.dragPath.length;
            var jump = this._imageHopper.dragPath[l - Math.min(10, l)];

            // velocity
            var dx = e.detail.x - jump.x;
            var dy = e.detail.y - jump.y;

            snabbt(drip, {
                fromPosition: [e.detail.x, e.detail.y, 0],
                position: [e.detail.x + dx, e.detail.y + dy, 0],
                duration: 200
            });

            // animate out drip
            snabbt(drip.firstChild, {
                fromScale: [0.5, 0.5],
                scale: [2, 2],
                fromOpacity: 1,
                opacity: 0,
                duration: 200,

                complete: function complete() {
                    // clean up transforms
                    resetTransforms(drip.firstChild);

                    // load dropped resource
                    _this17._load(e.target.files[0]);
                }
            });
        }

        /**
         * When a file has been selected after a click on the drop area
         * @param e
         * @private
         */

    }, {
        key: '_onChange',
        value: function _onChange(e) {
            if (e.target.files.length) {
                this._load(e.target.files[0]);
            }
        }

        /**
         * Loads a resource (blocking operation)
         * @param resource
         * @param callback(err)
         * @param options
         * @private
         */

    }, {
        key: '_load',
        value: function _load(resource, callback) {
            var _this18 = this;

            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            // stop here
            if (this._isBeingDestroyed) {
                return;
            }

            // if currently contains image, remove it
            if (this.containsImage()) {
                clearTimeout(this._replaceTimeout);

                this._doRemove(function () {
                    _this18._replaceTimeout = setTimeout(function () {
                        _this18._load(resource, callback, options);
                    }, 100);
                });

                return;
            }

            // no longer empty
            this._removeState('empty');
            this._addState('busy');

            // start loading indicator
            this._startProgressLoop();

            // can't drop any other image while loading
            if (this._imageHopper) {
                this._imageHopper.enabled = false;
            }

            clearTimeout(this._loadTimeout);
            var load = function load() {
                clearTimeout(_this18._loadTimeout);
                _this18._loadTimeout = setTimeout(function () {
                    if (_this18._isBeingDestroyed) {
                        return;
                    }

                    _this18._addState('loading');

                    snabbt(_this18._element.querySelector('.slim-label-loading'), {
                        fromOpacity: 0,
                        opacity: 1,
                        duration: 250
                    });
                }, 500);
            };

            // early exit
            var exit = function exit() {
                if (_this18._imageHopper) {
                    _this18._imageHopper.enabled = true;
                }
                _this18._removeState('loading');
                _this18._removeState('busy');
                _this18._addState('empty');
                _this18._stopProgressLoop();
            };

            // turn string based resources (url / base64) into file objects
            if (typeof resource === 'string') {
                if (resourceIsBase64Data(resource)) {
                    // resource is base64 data, turn into file
                    this._load(base64ToBlob(resource), callback, options);
                } else {

                    // will take a while, show loading indicator
                    load();

                    // resource is url, load with XHR
                    loadURL(resource, this._options.willLoad, function (file) {

                        // continue with file object
                        _this18._load(file, callback, options);
                    }, function (error) {

                        setTimeout(function () {

                            exit();

                            _this18._onLocalURLProblem('<p>' + error + '</p>');

                            if (callback) {
                                callback.apply(_this18, ['local-url-problem']);
                            }
                        }, 500);
                    });
                }

                // don't continue, wait for load
                return;
            } else if (typeof resource.remote !== 'undefined') {
                // is dropped link
                // test if happens to be base64 data
                if (resourceIsBase64Data(resource.remote)) {
                    this._load(base64ToBlob(resource.remote), callback, options);
                    return;
                }

                if (this._options.fetcher) {
                    loadRemoteURL(this._options.fetcher, this._options.willFetch, this._options.willLoad, resource.remote, function (error) {
                        exit();

                        _this18._onRemoteURLProblem('<p>' + error + '</p>');

                        if (callback) {
                            callback.apply(_this18, ['remote-url-problem']);
                        }
                    }, function (file) {
                        // continue with file object
                        _this18._load(file, callback, options);
                    });
                }

                // don't continue wait for server fetch
                return;
            }

            // let's continue with file resource
            var file = resource;

            // re-test if is valid file type
            // in case of loading base64 data or url
            if (this._imageHopper && this._imageHopper.accept.indexOf(file.type) === -1) {
                exit();

                this._onInvalidFile();
                if (callback) {
                    callback.apply(this, ['file-invalid']);
                }
                return;
            }

            // test if too big
            if (file.size && this._options.maxFileSize && bytesToMegaBytes(file.size) > this._options.maxFileSize) {
                exit();

                this._onOverWeightFile();
                if (callback) {
                    callback.apply(this, ['file-too-big']);
                }
                return;
            }

            // if has loaded image editor set to dirty
            if (this._imageEditor) {
                this._imageEditor.dirty();
            }

            // continue
            this._data.input.name = options && options.name ? options.name : getFileNameByFile(file);
            this._data.input.type = getFileTypeByFile(file);
            this._data.input.size = file.size;
            this._data.input.file = file;

            // internal canvas size
            var internalCanvasSize = this._options.internalCanvasSize;
            if (isLowMemoryDevice()) {
                internalCanvasSize = this._options.internalCanvasSizeLowMemory;
            }

            // fetch resource
            getImageAsCanvas(file, internalCanvasSize, function (image, meta) {

                var rewind = function rewind() {

                    // rewind state
                    if (_this18._imageHopper) {
                        _this18._imageHopper.enabled = true;
                    }

                    _this18._removeState('loading');
                    _this18._removeState('busy');
                    _this18._addState('empty');
                    _this18._stopProgressLoop();
                    _this18._resetData();
                };

                // if no image, something went wrong
                if (!image) {
                    rewind();

                    if (callback) {
                        callback.apply(_this18, ['file-not-found']);
                    }

                    return;
                }

                // test if image is too small
                if (!covers(image, _this18._options.minSize)) {
                    rewind();

                    _this18._onImageTooSmall();

                    if (callback) {
                        callback.apply(_this18, ['image-too-small']);
                    }

                    return;
                }

                var status = _this18._options.didLoad.apply(_this18, [file, image, meta, _this18]);

                if (status !== true) {
                    rewind();

                    if (status !== false) {
                        _this18._throwError(status);
                    }

                    if (callback) {
                        callback.apply(_this18, [status]);
                    }

                    return;
                }

                // done loading file
                _this18._removeState('loading');

                var revealCanvas = function revealCanvas(done) {

                    // done, enable hopper
                    if (_this18._imageHopper && _this18._options.dropReplace) {
                        _this18._imageHopper.enabled = true;
                    }

                    // do intro stuff
                    var intro = _this18._getIntro();

                    // setup base animation
                    var animation = {
                        fromScale: [1.25, 1.25],
                        scale: [1, 1],
                        fromOpacity: 0,
                        opacity: 1,
                        complete: function complete() {
                            resetTransforms(intro);

                            intro.style.opacity = 1;

                            done();
                        }
                    };

                    // if not attached to DOM, don't animate
                    if (_this18.isDetached()) {
                        animation.duration = 1;
                    } else {
                        animation.easing = 'spring';
                        animation.springConstant = 0.3;
                        animation.springDeceleration = 0.7;
                    }

                    // if is instant edit mode don't zoom out but zoom in
                    if (_this18._canInstantEdit()) {
                        animation.delay = 500;
                        animation.duration = 1;

                        // instant edit mode just fire up the editor immidiately
                        _this18._doEdit();
                    }

                    // reveal loaded image
                    snabbt(intro, animation);
                };

                _this18._options.willLoadCanvas.apply(_this18, [image, function (imageOut) {

                    // load the image
                    _this18._loadCanvas(imageOut,

                    // done loading the canvas
                    function (isUploading) {
                        _this18._addState('preview');

                        revealCanvas(function () {
                            // don't show buttons when instant editing
                            // the buttons will be triggered by the closing of the popup
                            if (!_this18._canInstantEdit() && !isUploading) {
                                _this18._showButtons();
                            }

                            if (!isUploading) {
                                _this18._stopProgressLoop();
                                _this18._removeState('busy');
                            }

                            if (callback) {
                                callback.apply(_this18, [null, _this18.data]);
                            }
                        });
                    },

                    // done uploading
                    function () {
                        // don't show buttons when instant editing
                        if (!_this18._canInstantEdit()) {
                            _this18._showButtons();
                        }

                        _this18._removeState('busy');
                    },

                    // options for canvas load
                    {
                        blockPush: options.blockPush
                    });
                }, _this18]);
            });
        }
    }, {
        key: '_loadCanvas',
        value: function _loadCanvas(image, ready, complete, options) {
            var _this19 = this;

            // set default options object if not supplied
            if (!options) {
                options = {};
            }

            // halt here if cropper is currently being destroyed
            if (this._isBeingDestroyed) {
                return;
            }

            // store raw data
            if (isLowMemoryDevice()) {
                this._data.input.image = new Image();
                this._data.input.image.src = image.toDataURL();
            } else {
                this._data.input.image = image;
            }
            this._data.input.width = image.width;
            this._data.input.height = image.height;

            if (this._initialRotation) {
                this._data.actions.rotation = this._initialRotation;
                this._initialRotation = null;
            }

            var isTilted = this._data.actions.rotation % 180 !== 0;

            // scales the drop area
            // if is 'input' or 'free' parameter
            if (!this._isFixedRatio()) {
                if (this._initialCrop) {
                    this._ratio = this._initialCrop.height / this._initialCrop.width;
                } else {
                    this._ratio = isTilted ? image.width / image.height : image.height / image.width;
                }
                this._scaleDropArea(this._ratio);
            }

            var applyTransforms = function applyTransforms() {

                // if max size set
                if (_this19._options.size) {
                    _this19._data.actions.size = {
                        width: _this19._options.size.width,
                        height: _this19._options.size.height
                    };
                }

                // do initial auto transform
                _this19._applyTransforms(image, function (transformedImage) {
                    var intro = _this19._getIntro();
                    var scalar = intro.offsetWidth / transformedImage.width;

                    // store data, if has preview image this prevents initial load from pushing
                    var willUpload = false;

                    // can only do auto upload when service is defined and push is enabled...
                    if (_this19._options.service && _this19._options.push && !options.blockPush) {
                        // ...and is not transformation of initial image
                        // + is not instant edit mode
                        if (!_this19._hasInitialImage && !_this19._canInstantEdit()) {
                            willUpload = true;
                            _this19._stopProgressLoop(function () {
                                _this19._startProgress(function () {
                                    _this19._updateProgress(0.1);
                                });
                            });
                        }
                    }

                    // no service set, and instant edit
                    if (!_this19._canInstantEdit()) {
                        // store data (possibly)
                        _this19._save(function () {
                            if (_this19._isBeingDestroyed) {
                                return;
                            }
                            if (willUpload) {
                                _this19._stopProgress();
                                complete();
                            }
                        }, willUpload);
                    }

                    // scale ratio
                    var ratio = _this19._options.devicePixelRatio === 'auto' ? window.devicePixelRatio : _this19._options.devicePixelRatio;

                    // show intro animation
                    intro.src = '';
                    intro.src = cloneCanvasScaled(transformedImage, scalar * ratio).toDataURL();
                    intro.onload = function () {
                        intro.onload = null;

                        // bail out if we've been cleaned up
                        if (_this19._isBeingDestroyed) {
                            return;
                        }

                        if (ready) {
                            ready(willUpload);
                        }
                    };
                });
            };

            if (this._initialCrop) {

                // use initial supplied crop rectangle
                this._data.actions.crop = clone(this._initialCrop);
                this._data.actions.crop.type = CropType.INITIAL;

                // clear initial crop, it's no longer useful
                this._initialCrop = null;

                // go!
                applyTransforms();
            } else {

                this._options.willCropInitial.apply(this, [this.data, function (rect) {

                    if (rect) {

                        // apply custom crop rectangle
                        _this19._data.actions.crop = rect;
                        _this19._data.actions.crop.type = CropType.INITIAL;
                    } else {

                        // get automagical crop rectangle
                        _this19._data.actions.crop = getAutoCropRect(isTilted ? image.height : image.width, isTilted ? image.width : image.height, _this19._ratio);
                        _this19._data.actions.crop.type = CropType.AUTO;
                    }

                    applyTransforms();
                }, this]);
            }
        }
    }, {
        key: '_applyTransforms',
        value: function _applyTransforms(image, ready) {
            var _this20 = this;

            var actions = clone(this._data.actions);
            actions.filters = {
                sharpen: this._options.filterSharpen / 100
            };

            // if should force minimum size on output image
            if (this._options.forceMinSize) {
                actions.minSize = this._options.minSize;
            } else {
                actions.minSize = {
                    width: 0,
                    height: 0
                };
            }

            transformCanvas(image, actions, function (transformedImage) {
                var outputImage = transformedImage;

                // if should force/correct output size?
                // - is forced size set?
                // - is a discrepancy found between requested output size and transformed size
                if (_this20._options.forceSize || _this20._options.size && sizeDist(_this20._options.size, transformedImage) == 1) {
                    outputImage = create('canvas');
                    outputImage.width = _this20._options.size.width;
                    outputImage.height = _this20._options.size.height;
                    var ctx = outputImage.getContext('2d');
                    ctx.drawImage(transformedImage, 0, 0, _this20._options.size.width, _this20._options.size.height);
                }

                // make sure min size is respected when size is equal to min size
                if (_this20._options.forceMinSize && _this20._options.size && _this20._options.minSize.width === _this20._options.size.width && _this20._options.minSize.height === _this20._options.size.height && (outputImage.width < _this20._options.minSize.width || outputImage.height < _this20._options.minSize.height)) {
                    var w = Math.max(outputImage.width, _this20._options.minSize.width);
                    var h = Math.max(outputImage.height, _this20._options.minSize.height);
                    outputImage = create('canvas');
                    outputImage.width = w;
                    outputImage.height = h;
                    var _ctx = outputImage.getContext('2d');
                    _ctx.drawImage(transformedImage, 0, 0, w, h);
                }

                // prevent smaller square output image, this is a quick fix for square images, should be done a lot neater
                if (_this20._options.forceMinSize && _this20._ratio === 1 && (outputImage.width < _this20._options.minSize.width || outputImage.height < _this20._options.minSize.height)) {
                    outputImage = create('canvas');
                    outputImage.width = _this20._options.minSize.width;
                    outputImage.height = _this20._options.minSize.height;
                    var _ctx2 = outputImage.getContext('2d');
                    _ctx2.drawImage(transformedImage, 0, 0, outputImage.width, outputImage.height);
                }

                // store output
                _this20._data.output.width = outputImage.width;
                _this20._data.output.height = outputImage.height;
                _this20._data.output.image = outputImage;

                _this20._onTransformCanvas(function (transformedData) {
                    _this20._data = transformedData;
                    _this20._options.didTransform.apply(_this20, [_this20.data, _this20]);
                    ready(_this20._data.output.image);
                });
            });
        }
    }, {
        key: '_onTransformCanvas',
        value: function _onTransformCanvas(ready) {
            this._options.willTransform.apply(this, [this.data, ready, this]);
        }

        /**
         * Creates the editor nodes
         * @private
         */

    }, {
        key: '_appendEditor',
        value: function _appendEditor() {
            var _this21 = this;

            // we already have an editor
            if (this._imageEditor) {
                return;
            }

            // add editor
            this._imageEditor = new ImageEditor(create('div'), {
                minSize: this._options.minSize,
                devicePixelRatio: this._options.devicePixelRatio,

                buttonConfirmClassName: this._options.buttonConfirmClassName,
                buttonCancelClassName: this._options.buttonCancelClassName,
                buttonRotateClassName: this._options.buttonRotateClassName,

                buttonConfirmLabel: this._options.buttonConfirmLabel,
                buttonCancelLabel: this._options.buttonCancelLabel,
                buttonRotateLabel: this._options.buttonRotateLabel,

                buttonConfirmTitle: this._options.buttonConfirmTitle,
                buttonCancelTitle: this._options.buttonCancelTitle,
                buttonRotateTitle: this._options.buttonRotateTitle
            });

            // listen to events
            ImageEditorEvents.forEach(function (e) {
                _this21._imageEditor.element.addEventListener(e, _this21);
            });
        }
    }, {
        key: '_scaleDropArea',
        value: function _scaleDropArea(ratio) {
            var node = this._getRatioSpacerElement();
            if (!node || !this._element) {
                return;
            }
            node.style.marginBottom = ratio * 100 + '%';
            this._element.setAttribute('data-ratio', '1:' + ratio);
        }

        /**
         * Data Layer
         * @private
         */
        // image editor closed

    }, {
        key: '_onCancel',
        value: function _onCancel(e) {
            this._removeState('editor');

            this._options.didCancel.apply(this, [this]);

            this._showButtons();

            this._hideEditor();

            if (this._options.instantEdit && !this._hasInitialImage && this._isAutoCrop()) {
                this._doRemove();
            }
        }

        // user confirmed changes

    }, {
        key: '_onConfirm',
        value: function _onConfirm(e) {
            var _this22 = this;

            // if
            // - service set
            // - and we are pushing
            // - and we don't instant edit
            // we will upload
            var willUpload = this._options.service && this._options.push;
            if (willUpload) {
                this._startProgress(function () {
                    _this22._updateProgress(0.1);
                });
            } else {
                this._startProgressLoop();
            }

            this._removeState('editor');

            this._addState('busy');

            // clear data
            this._output.value = '';

            // apply new action object to this._data
            this._data.actions.rotation = e.detail.rotation;
            this._data.actions.crop = e.detail.crop;
            this._data.actions.crop.type = CropType.MANUAL;

            // do transforms
            this._applyTransforms(this._data.input.image, function (transformedImage) {

                // user confirmed the crop (and changes have been applied to data)
                _this22._options.didConfirm.apply(_this22, [_this22.data, _this22]);

                // set new image result
                var images = _this22._getInOut();
                var intro = images[0].className === 'out' ? images[0] : images[1];
                var outro = intro === images[0] ? images[1] : images[0];

                intro.className = 'in';
                intro.style.opacity = '0';
                intro.style.zIndex = '2';
                outro.className = 'out';
                outro.style.zIndex = '1';

                // scale ratio
                var ratio = _this22._options.devicePixelRatio === 'auto' ? window.devicePixelRatio : _this22._options.devicePixelRatio;

                // new image get's
                intro.src = '';
                intro.src = cloneCanvasScaled(transformedImage, intro.offsetWidth / transformedImage.width * ratio).toDataURL();
                intro.onload = function () {
                    intro.onload = null;

                    // scale the dropzone
                    if (_this22._options.ratio === 'free') {
                        _this22._ratio = intro.naturalHeight / intro.naturalWidth;
                        _this22._scaleDropArea(_this22._ratio);
                    }

                    // close the editor
                    _this22._hideEditor();

                    // wait a tiny bit so animations sync up nicely
                    var timer = setTimeout(function () {

                        removeTimer(_this22._timers, timer);

                        // show the preview
                        _this22._showPreview(intro, function () {
                            // save the data
                            _this22._save(function (err, data, res) {
                                // done!
                                _this22._toggleButton('upload', true);

                                if (willUpload) {
                                    _this22._stopProgress();
                                } else {
                                    _this22._stopProgressLoop();
                                }

                                _this22._removeState('busy');

                                _this22._showButtons();
                            }, willUpload);
                        });
                    }, 250);

                    _this22._timers.push(timer);
                };
            });
        }
    }, {
        key: '_cropAuto',
        value: function _cropAuto() {
            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (data) {};

            var isTilted = this._data.actions.rotation % 180 !== 0;

            var rect = getAutoCropRect(isTilted ? this._data.input.image.height : this._data.input.image.width, isTilted ? this._data.input.image.width : this._data.input.image.height, this._ratio);

            this._crop(rect.x, rect.y, rect.width, rect.height, callback, CropType.AUTO);
        }
    }, {
        key: '_crop',
        value: function _crop(x, y, width, height) {
            var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (data) {};
            var cropType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : CropType.MANUAL;


            // clear data
            this._output.value = '';

            // apply new action object to this._data
            this._data.actions.crop = {
                x: x,
                y: y,
                width: width,
                height: height
            };
            this._data.actions.crop.type = cropType;

            this._manualTransform(callback);
        }
    }, {
        key: '_manualTransform',
        value: function _manualTransform(callback) {
            var _this23 = this;

            this._startProgressLoop();
            this._addState('busy');

            // do transforms
            this._applyTransforms(this._data.input.image, function (transformedImage) {
                // set new image result
                var images = _this23._getInOut();
                var intro = images[0].className === 'out' ? images[0] : images[1];
                var outro = intro === images[0] ? images[1] : images[0];

                intro.className = 'in';
                intro.style.opacity = '1';
                intro.style.zIndex = '2';
                outro.className = 'out';
                outro.style.zIndex = '0';

                // scale ratio
                var pixelRatio = _this23._options.devicePixelRatio === 'auto' ? window.devicePixelRatio : _this23._options.devicePixelRatio;

                // new image
                intro.src = '';
                intro.src = cloneCanvasScaled(transformedImage, intro.offsetWidth / transformedImage.width * pixelRatio).toDataURL();
                intro.onload = function () {
                    intro.onload = null;

                    // scale the dropzone
                    if (_this23._options.ratio === 'free') {
                        _this23._ratio = intro.naturalHeight / intro.naturalWidth;
                        _this23._scaleDropArea(_this23._ratio);
                    }

                    // determine if will also upload
                    var willUpload = _this23._options.service && _this23._options.push;

                    var save = function save() {
                        // save the data
                        _this23._save(function (err, data, res) {
                            // stop loader
                            if (!willUpload) {
                                _this23._stopProgressLoop();
                            }

                            _this23._removeState('busy');

                            callback.apply(_this23, [_this23.data]);
                        }, willUpload);
                    };

                    if (willUpload) {
                        _this23._startProgress(save);
                    } else {
                        save();
                    }
                };
            });
        }
    }, {
        key: '_save',
        value: function _save() {
            var _this24 = this;

            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
            var allowUpload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            if (this._isBeingDestroyed) {
                return;
            }

            // flatten data also turns output canvas into data uri
            // removes input file object and image object
            var data = this.dataBase64;

            // decide if we need to
            // - A. Store the data in an output field
            // - B. Upload the data and store the response in output field

            // - we are not doing async uploading (in which case output is used for response)
            // - we are not initialising a replaceable image
            if (!this._options.service && !(this._isInitialising && !this._isImageOnly())) {
                this._options.willSave.apply(this, [data, function (data) {
                    _this24._store(data);

                    _this24._options.didSave.apply(_this24, [data, _this24]);
                }, this]);
            }

            if (this._isBeingDestroyed) {
                return;
            }

            // is remote service defined upload async
            if (this._options.service && allowUpload) {
                // allow user to modify the data
                this._options.willSave.apply(this, [data, function (data) {
                    _this24._addState('upload');

                    if (_this24._imageHopper && _this24._options.dropReplace) {
                        _this24._imageHopper.enabled = false;
                    }

                    // do the actual uploading
                    _this24._upload(data, function (err, res) {
                        if (_this24._imageHopper && _this24._options.dropReplace) {
                            _this24._imageHopper.enabled = true;
                        }

                        // store response
                        if (!err) {
                            _this24._storeServerResponse(res);
                        }

                        // we did upload data
                        _this24._options.didUpload.apply(_this24, [err, data, res, _this24]);

                        _this24._removeState('upload');

                        // done!
                        callback(err, data, res);
                    });
                }, this]);
            }

            // if no service, we're done here
            if (!this._options.service || !allowUpload) {
                callback();
            }
        }

        // stores active file information in hidden output field

    }, {
        key: '_storeServerResponse',
        value: function _storeServerResponse(data) {
            // remove required flag
            if (this._isRequired) {
                this._input.required = false;
            }

            // store data returned from server
            this._data.server = data;

            // sync with output value
            this._output.value = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? JSON.stringify(this._data.server) : data;
        }

        // stores data in output field

    }, {
        key: '_store',
        value: function _store(data) {
            if (this._isRequired) {
                this._input.required = false;
            }

            this._output.value = JSON.stringify(data);
        }

        // uploads given data to server

    }, {
        key: '_upload',
        value: function _upload(data, callback) {
            var // function(error) {} 			// error message (string),
            _this25 = this;

            this.requestOutput(function (fileData, formData) {
                var statusNode = _this25._element.querySelector('.slim-upload-status');

                var requestDecorator = _this25._options.willRequest;

                // callback methods
                var onProgress = function onProgress(loaded, total) {
                    _this25._updateProgress(Math.max(0.1, loaded / total));
                };

                var onSuccess = function onSuccess(obj) {
                    var timer = setTimeout(function () {

                        removeTimer(_this25._timers, timer);

                        // it's possible that Slim has been destroyed in the mean time.
                        if (_this25._isBeingDestroyed) {
                            return;
                        }

                        statusNode.innerHTML = _this25._options.statusUploadSuccess;
                        statusNode.setAttribute('data-state', 'success');
                        statusNode.style.opacity = 1;

                        // hide status update after 2 seconds
                        var timer = setTimeout(function () {
                            removeTimer(_this25._timers, timer);
                            statusNode.style.opacity = 0;
                        }, 2000);

                        _this25._timers.push(timer);
                    }, 250);

                    _this25._timers.push(timer);

                    callback(null, obj);
                };

                var onError = function onError(status) {
                    var html = '';
                    if (status === 'file-too-big') {
                        html = _this25._options.statusContentLength;
                    } else {
                        html = _this25._options.didReceiveServerError.apply(_this25, [status, _this25._options.statusUnknownResponse, _this25]);
                    }

                    // when an error occurs the status update is not automatically hidden
                    var timer = setTimeout(function () {

                        removeTimer(_this25._timers, timer);

                        statusNode.innerHTML = html;
                        statusNode.setAttribute('data-state', 'error');
                        statusNode.style.opacity = 1;
                    }, 250);

                    _this25._timers.push(timer);

                    callback(status);
                };

                // use default send method or custom implementation
                if (typeof _this25._options.service === 'string') {
                    send(_this25._options.service, _this25._options.uploadMethod, formData, requestDecorator, onProgress, onSuccess, onError);
                } else if (typeof _this25._options.service === 'function') {
                    _this25._options.service.apply(_this25, [_this25._options.serviceFormat === 'file' ? fileData : formData, onProgress, // function(loaded, total) {}   // loaded bytes (number), total bytes (number)
                    onSuccess, // function(response) {} 		// response (object or string)
                    onError, _this25]);
                }
            }, data);
        }
    }, {
        key: 'requestOutput',
        value: function requestOutput(cb, data) {
            var _this26 = this;

            if (!this._data.input.file) {
                cb(null, null);
                return;
            }

            if (!data) {
                data = this.dataBase64;
            }

            // copy the meta data of the original file to the output
            loadImage.parseMetaData(this._data.input.file,

            // receives image data from input file
            function (imageData) {
                var fileData = [];
                var formData = new FormData();

                // if input should be posted along, append data
                // to FormData object as file
                if (inArray('input', _this26._options.post)) {
                    // add to data array
                    fileData.push(_this26._data.input.file);

                    // add to formdata
                    formData.append(_this26._inputReference, _this26._data.input.file, _this26._data.input.file.name);
                }

                // if image data is defined, turn it into a file object (we can send files if we're uploading)
                if (inArray('output', _this26._options.post) && _this26._data.output.image !== null && _this26._options.uploadBase64 === false) {
                    var output = base64ToBlob(data.output.image, data.output.name);

                    // if image head available, inject in output
                    if (imageData.imageHead && _this26._options.copyImageHead) {

                        try {
                            output = new Blob([imageData.imageHead, loadImage.blobSlice.call(output, 20)], {
                                type: getMimeTypeFromDataURI(data.output.image)
                            });

                            output = blobToFile(output, data.output.name);
                        } catch (e) {}
                    }

                    // add to data array
                    fileData.push(output);

                    // add to formdata
                    var field = 'slim_output_' + _this26._uid;
                    data.output.image = null; // clear base64 data
                    data.output.field = field;
                    formData.append(field, output, data.output.name);
                }

                // output dataset
                formData.append(_this26._output.name, JSON.stringify(data));

                // done
                cb(fileData, formData);
            }, {
                maxMetaDataSize: 262144,
                disableImageHead: false
            });
        }
    }, {
        key: '_showEditor',
        value: function _showEditor() {
            SlimPopover.className = this._options.popoverClassName;

            SlimPopover.show();

            this._imageEditor.show();
        }
    }, {
        key: '_hideEditor',
        value: function _hideEditor() {
            var _this27 = this;

            this._imageEditor.hide();

            var timer = setTimeout(function () {
                removeTimer(_this27._timers, timer);
                SlimPopover.hide();
            }, 250);

            this._timers.push(timer);
        }

        /**
         * Animations
         */

    }, {
        key: '_showPreview',
        value: function _showPreview(intro, callback) {
            snabbt(intro, {
                fromPosition: [0, 50, 0],
                position: [0, 0, 0],

                fromScale: [1.5, 1.5],
                scale: [1, 1],

                fromOpacity: 0,
                opacity: 1,

                easing: 'spring',
                springConstant: 0.3,
                springDeceleration: 0.7,

                complete: function complete() {
                    resetTransforms(intro);

                    if (callback) {
                        callback();
                    }
                }
            });
        }
    }, {
        key: '_hideResult',
        value: function _hideResult(callback) {
            var intro = this._getIntro();
            if (!intro) {
                return;
            }

            snabbt(intro, {
                fromScale: [1, 1],
                scale: [0.5, 0.5],

                fromOpacity: 1,
                opacity: 0,

                easing: 'spring',
                springConstant: 0.3,
                springDeceleration: 0.75,

                complete: function complete() {
                    resetTransforms(intro);
                    if (callback) {
                        callback();
                    }
                }
            });
        }
    }, {
        key: '_showButtons',
        value: function _showButtons(callback) {
            if (!this._btnGroup) {
                return;
            }

            this._btnGroup.style.display = '';

            // setup animation
            var animation = {
                fromScale: [0.5, 0.5],
                scale: [1, 1],
                fromPosition: [0, 10, 0],
                position: [0, 0, 0],
                fromOpacity: 0,
                opacity: 1,
                complete: function complete() {
                    resetTransforms(this);
                },
                allDone: function allDone() {
                    if (callback) {
                        callback();
                    }
                }
            };

            // don't animate when detached
            if (this.isDetached()) {
                animation.duration = 1;
            } else {
                animation.delay = function (i) {
                    return 250 + i * 50;
                };
                animation.easing = 'spring';
                animation.springConstant = 0.3;
                animation.springDeceleration = 0.85;
            }

            snabbt(this._btnGroup.childNodes, animation);
        }
    }, {
        key: '_hideButtons',
        value: function _hideButtons(callback) {
            var _this28 = this;

            if (!this._btnGroup) {
                return;
            }

            var animation = {
                fromScale: [1, 1],
                scale: [0.85, 0.85],
                fromOpacity: 1,
                opacity: 0,
                allDone: function allDone() {
                    _this28._btnGroup.style.display = 'none';
                    if (callback) {
                        callback();
                    }
                }
            };

            // don't animate when detached
            if (this.isDetached()) {
                animation.duration = 1;
            } else {
                animation.easing = 'spring';
                animation.springConstant = 0.3;
                animation.springDeceleration = 0.75;
            }

            // go hide the buttons
            snabbt(this._btnGroup.childNodes, animation);
        }
    }, {
        key: '_hideStatus',
        value: function _hideStatus() {
            var statusNode = this._element.querySelector('.slim-upload-status');
            statusNode.style.opacity = 0;
        }
    }, {
        key: '_doEdit',
        value: function _doEdit() {
            var _this29 = this;

            // if no input data available, can't edit anything
            if (!this._data.input.image) {
                return;
            }

            // now in editor mode
            this._addState('editor');

            // create editor (if not already created)
            if (!this._imageEditor) {
                this._appendEditor();
            }

            // hide or show rotate button
            this._imageEditor.showRotateButton = this._options.rotateButton;

            // append to popover
            SlimPopover.inner = this._imageEditor.element;

            // read the data
            this._imageEditor.open(
            // send copy of canvas to the editor
            //cloneCanvas(this._data.input.image),
            this._data.input.image,

            // determine ratio
            this._options.ratio === 'free' ? null : this._ratio,

            // the initial crop to show
            this._data.actions.crop,

            // the initial rotation of the image
            this._data.actions.rotation,

            // handle editor load
            function () {
                _this29._showEditor();

                _this29._hideButtons();

                _this29._hideStatus();
            });
        }
    }, {
        key: '_doRemove',
        value: function _doRemove(done) {
            var _this30 = this;

            // cannot remove when is only one image
            if (this._isImageOnly()) {
                return;
            }

            this._clearState();
            this._addState('empty');

            this._hasInitialImage = false;
            if (this._imageHopper) {
                this._imageHopper.enabled = true;
            }

            if (this._isRequired) {
                this._input.required = true;
            }

            var out = this._getOutro();
            if (out) {
                out.style.opacity = '0';
            }

            // get public available clone of data
            var data = this.data;

            // now reset all data
            this._resetData();

            var timer = setTimeout(function () {
                removeTimer(_this30._timers, timer);
                if (_this30._isBeingDestroyed) {
                    return;
                }

                _this30._hideButtons(function () {
                    _this30._toggleButton('upload', true);
                });

                _this30._hideStatus();

                _this30._hideResult();

                _this30._options.didRemove.apply(_this30, [data, _this30]);

                if (done) {
                    done();
                }
            }, this.isDetached() ? 0 : 250);

            this._timers.push(timer);

            return data;
        }
    }, {
        key: '_doUpload',
        value: function _doUpload(callback) {
            var _this31 = this;

            // if no input data available, can't upload anything
            if (!this._data.input.image) {
                return;
            }

            this._addState('upload');
            this._startProgress();

            this._hideButtons(function () {
                // block upload button
                _this31._toggleButton('upload', false);

                _this31._save(function (err, data, res) {
                    _this31._removeState('upload');
                    _this31._stopProgress();

                    if (callback) {
                        callback.apply(_this31, [err, data, res]);
                    }

                    if (err) {
                        _this31._toggleButton('upload', true);
                    }

                    _this31._showButtons();
                });
            });
        }
    }, {
        key: '_doDownload',
        value: function _doDownload() {
            var image = this._data.output.image;
            if (!image) {
                return;
            }

            downloadCanvas(this._data, this._options.jpegCompression, this._options.forceType);
        }
    }, {
        key: '_doDestroy',
        value: function _doDestroy() {
            var _this32 = this;

            // set destroy flag to halt any running functionality
            this._isBeingDestroyed = true;

            // clear timers
            this._timers.forEach(function (timer) {
                clearTimeout(timer);
            });
            this._timers = [];

            // clean up snabbt animations
            snabbt(this._element, 'detach');

            // this removes the image hopper if it's attached
            if (this._imageHopper) {
                HopperEvents.forEach(function (e) {
                    _this32._imageHopper.element.removeEventListener(e, _this32);
                });
                this._imageHopper.destroy();
                this._imageHopper = null;
            }

            // this block removes the image editor
            if (this._imageEditor) {
                ImageEditorEvents.forEach(function (e) {
                    _this32._imageEditor.element.removeEventListener(e, _this32);
                });
                this._imageEditor.destroy();
                this._imageEditor = null;
            }

            // remove button event listeners
            nodeListToArray(this._btnGroup.children).forEach(function (btn) {
                btn.removeEventListener('click', _this32);
            });

            // stop listening to input
            this._input.removeEventListener('change', this);

            // detect if was wrapped, if so, remove wrapping (needs to have parent node)
            if (this._element !== this._originalElement && this._element.parentNode) {
                this._element.parentNode.replaceChild(this._originalElement, this._element);
            }

            // restore HTML of original element
            this._originalElement.innerHTML = this._originalElementInner;

            // get current attributes and remove all, then add original attributes
            function matchesAttributeInList(a, attributes) {
                return attributes.filter(function (attr) {
                    return a.name === attr.name && a.value === attr.value;
                }).length !== 0;
            }

            var attributes = getElementAttributes(this._originalElement);
            attributes.forEach(function (attribute) {
                // if attribute  is contained in original element attribute list and is the same, don't remove
                if (matchesAttributeInList(attribute, _this32._originalElementAttributes)) {
                    return;
                }

                // else remove
                _this32._originalElement.removeAttribute(attribute.name);
            });

            this._originalElementAttributes.forEach(function (attribute) {
                // attribute was never removed
                if (matchesAttributeInList(attribute, attributes)) {
                    return;
                }

                // add attribute
                _this32._originalElement.setAttribute(attribute.name, attribute.value);
            });

            // now destroyed this counter so the total Slim count can be lowered
            SlimCount = Math.max(0, SlimCount - 1);

            // if slim count has reached 0 it's time to clean up the popover
            if (SlimPopover && SlimCount === 0) {
                SlimPopover.destroy();
                SlimPopover = null;
            }

            this._originalElement = null;
            this._element = null;
            this._input = null;
            this._output = null;
            this._btnGroup = null;
            this._options = null;
        }
    }, {
        key: 'dataBase64',


        /**
         * Public API
         */
        // properties
        get: function get() {
            return flattenData(this._data, this._options.post, this._options.jpegCompression, this._options.forceType, this._options.service !== null);
        }
    }, {
        key: 'data',
        get: function get() {
            return cloneData(this._data);
        }
    }, {
        key: 'element',
        get: function get() {
            return this._element;
        }
    }, {
        key: 'service',
        set: function set(service) {
            this._options.service = service;
        }
    }, {
        key: 'size',
        set: function set(dimensions) {
            this.setSize(dimensions, null);
        }
    }, {
        key: 'rotation',
        set: function set(rotation) {
            this.setRotation(rotation, null);
        }
    }, {
        key: 'forceSize',
        set: function set(dimensions) {
            this.setForceSize(dimensions, null);
        }
    }, {
        key: 'ratio',
        set: function set(ratio) {
            this.setRatio(ratio, null);
        }
    }], [{
        key: 'options',
        value: function options() {
            var defaults = {
                // edit button is enabled by default
                edit: true,

                // immidiately summons editor on load
                instantEdit: false,

                // set to true to upload data as base64 string
                uploadBase64: false,

                // metadata values
                meta: {},

                // ratio of crop by default is the same as input image ratio
                ratio: 'free',

                // use fix value for device pixel ratio
                devicePixelRatio: 1, // set to 'auto' to use device ratio

                // dimensions to resize the resulting image to
                size: null,

                // set initial rotation
                rotation: null,

                // initial crop settings for example: {x:0, y:0, width:100, height:100}
                crop: null,

                // post these values
                post: ['output', 'actions'],

                // call this service to submit cropped data
                service: null,
                serviceFormat: null,

                // sharpen filter value, really low values might improve image output
                filterSharpen: 0,

                // when service is set, and this is set to true, Soon will auto upload all crops (also auto crops)
                push: false,

                // default fallback name for field
                defaultInputName: 'slim[]',

                // minimum size of cropped area object with width and height property
                minSize: {
                    width: 0,
                    height: 0
                },

                // maximum file size in MB to upload
                maxFileSize: null,

                // compression of JPEG (between 0 and 100)
                jpegCompression: null,

                // upload method of request
                uploadMethod: 'POST',

                // render download link
                download: false,

                // save initially loaded image
                saveInitialImage: false,

                // the type to force (jpe|jpg|jpeg or png)
                forceType: false,

                // the forced output size of the image
                forceSize: null,

                forceMinSize: true,

                // disable drop to replace
                dropReplace: true,

                // remote URL service
                fetcher: null,

                // set the internal canvas size
                internalCanvasSize: {
                    width: 4096,
                    height: 4096
                },

                // use these settings on low memory enviroment
                internalCanvasSizeLowMemory: {
                    width: 4096,
                    height: 4096
                },

                // copies the input image meta data to the output image
                copyImageHead: false,

                // enable or disable rotation
                rotateButton: true,

                // popover classname
                popoverClassName: null,

                // label HTML to show inside drop area
                label: '<p>Drop your image here</p>',
                labelLoading: '<p>Loading image...</p>',

                // error messages
                statusFileType: '<p>Invalid file type, expects: $0.</p>',
                statusFileSize: '<p>File is too big, maximum file size: $0 MB.</p>',
                statusNoSupport: '<p>Your browser does not support image cropping.</p>',
                statusImageTooSmall: '<p>Image is too small, minimum size is: $0 pixels.</p>',
                statusContentLength: '<span class="slim-upload-status-icon"></span> The file is probably too big',
                statusUnknownResponse: '<span class="slim-upload-status-icon"></span> An unknown error occurred',
                statusUploadSuccess: '<span class="slim-upload-status-icon"></span> Saved',
                statusLocalUrlProblem: null,

                // callback methods
                didInit: function didInit(data) {},
                didLoad: function didLoad(file, image, meta) {
                    return true;
                },
                didSave: function didSave(data) {},
                didUpload: function didUpload(err, data, res) {},
                didReceiveServerError: function didReceiveServerError(err, defaultError) {
                    return defaultError;
                },
                didRemove: function didRemove(data) {},
                didTransform: function didTransform(data) {},
                didConfirm: function didConfirm(data) {},
                didCancel: function didCancel() {},
                didThrowError: function didThrowError() {},
                willLoadCanvas: function willLoadCanvas(image, cb) {
                    cb(image);
                },
                willCropInitial: function willCropInitial(file, cb) {
                    cb(null);
                },
                willTransform: function willTransform(data, cb) {
                    cb(data);
                },
                willSave: function willSave(data, cb) {
                    cb(data);
                },
                willRemove: function willRemove(data, cb) {
                    cb();
                },
                willRequest: function willRequest(xhr, data) {},
                willFetch: function willFetch(xhr) {},
                willLoad: function willLoad(xhr) {}
            };

            // add default button labels
            SlimButtons.concat(ImageEditor.Buttons).concat('rotate').forEach(function (btn) {
                var capitalized = capitalizeFirstLetter(btn);
                defaults['button' + capitalized + 'ClassName'] = null;
                defaults['button' + capitalized + 'Label'] = capitalized;
                defaults['button' + capitalized + 'Title'] = capitalized;
            });

            return defaults;
        }
    }]);

    return Slim;
}();

/**
 * Slim Static Methods
 */


(function () {
    var instances = [];

    var indexOfElement = function indexOfElement(element) {
        var i = 0;
        var l = instances.length;
        for (; i < l; i++) {
            if (instances[i].isAttachedTo(element)) {
                return i;
            }
        }
        return -1;
    };

    function toLabel(v) {
        // if value set, use as label
        if (v) {
            return '<p>' + v + '</p>';
        }

        // else use default text
        return null;
    }

    function toFunctionReference(name) {
        var ref = window;
        var levels = name.split('.');
        levels.forEach(function (level, index) {
            if (!ref[levels[index]]) {
                return;
            }
            ref = ref[levels[index]];
        });
        return ref !== window ? ref : null;
    }

    var passThrough = function passThrough(v) {
        return v;
    };
    var defaultFalse = function defaultFalse(v) {
        return v === 'true';
    };
    var defaultTrue = function defaultTrue(v) {
        return v ? v === 'true' : true;
    };
    var defaultLabel = function defaultLabel(v) {
        return toLabel(v);
    };
    var defaultFunction = function defaultFunction(v) {
        return v ? toFunctionReference(v) : null;
    };
    var defaultSize = function defaultSize(v) {
        if (!v) {
            return null;
        }
        var parts = intSplit(v, ',');
        return {
            width: parts[0],
            height: parts[1]
        };
    };

    var toFloat = function toFloat(v) {
        if (!v) {
            return null;
        }
        return parseFloat(v);
    };

    var toInt = function toInt(v) {
        if (!v) {
            return null;
        }
        return parseInt(v, 10);
    };

    var toRect = function toRect(v) {
        if (!v) {
            return null;
        }
        var obj = {};
        v.split(',').map(function (p) {
            return parseInt(p, 10);
        }).forEach(function (v, i) {
            obj[Rect[i]] = v;
        });
        return obj;
    };

    var defaults = {
        // is user allowed to download the cropped image?
        download: defaultFalse,

        // is user allowed to edit the cropped image?
        edit: defaultTrue,

        // open editor immidiately on file drop
        instantEdit: defaultFalse,

        // minimum crop size in pixels of original image
        minSize: defaultSize,

        // the final bounding box of the output image
        size: defaultSize,

        // the forced output size of the image
        forceSize: defaultSize,

        forceMinSize: defaultTrue,

        // the internal data canvas size
        internalCanvasSize: defaultSize,
        internalCanvasSizeLowMemory: defaultSize,

        // url to post to
        service: function service(v) {
            if (typeof v === 'undefined') {
                return null;
            }
            var fn = toFunctionReference(v);
            if (fn) {
                return fn;
            }
            return v;
        },

        // format of service data
        serviceFormat: function serviceFormat(v) {
            return typeof v === 'undefined' ? null : v;
        },

        // url to fetch service
        fetcher: function fetcher(v) {
            return typeof v === 'undefined' ? null : v;
        },

        // set auto push mode
        push: defaultFalse,

        // initial rotation
        rotation: function rotation(v) {
            return typeof v === 'undefined' ? null : parseInt(v, 10);
        },

        // set crop rect
        crop: toRect,

        // what to post
        post: function post(v) {
            if (!v) {
                return null;
            }
            return v.split(',').map(function (item) {
                return item.trim();
            });
        },

        // default input name
        defaultInputName: passThrough,

        // the ratio of the crop
        ratio: function ratio(v) {
            if (!v) {
                return null;
            }
            return v;
        },

        // maximum file size
        maxFileSize: toFloat,

        // sharpen filter
        filterSharpen: toInt,

        // jpeg compression
        jpegCompression: toInt,

        // base64 data uploading
        uploadBase64: defaultFalse,

        // sets file type to force output to
        forceType: passThrough,

        // drop to replace
        dropReplace: defaultTrue,

        // bool determining if initial image should be saved
        saveInitialImage: defaultFalse,

        // copies input image head to output image
        copyImageHead: defaultFalse,

        // rotate button
        rotateButton: defaultTrue,

        // default labels
        label: defaultLabel,
        labelLoading: defaultLabel,

        // class name to put on popover element
        popoverClassName: passThrough,

        // the ratio for pixels
        devicePixelRatio: passThrough,

        // upload request method
        uploadMethod: passThrough
    };

    // labels
    ['FileSize', 'FileType', 'NoSupport', 'ImageTooSmall'].forEach(function (status) {
        defaults['status' + status] = defaultLabel;
    });

    // status
    ['ContentLength', 'UnknownResponse', 'UploadSuccess', 'localUrlProblem'].forEach(function (status) {
        defaults['status' + status] = passThrough;
    });

    // the did callbacks
    ['Init', 'Load', 'Save', 'Upload', 'Remove', 'Transform', 'ReceiveServerError', 'Confirm', 'Cancel', 'ThrowError'].forEach(function (cb) {
        defaults['did' + cb] = defaultFunction;
    });

    // the will callbacks
    ['LoadCanvas', 'CropInitial', 'Transform', 'Save', 'Remove', 'Request', 'Load', 'Fetch'].forEach(function (cb) {
        defaults['will' + cb] = defaultFunction;
    });

    // button defaults
    var buttonOptions = ['ClassName', 'Label', 'Title'];
    SlimButtons.concat(ImageEditor.Buttons).concat('rotate').forEach(function (btn) {
        var capitalized = capitalizeFirstLetter(btn);
        buttonOptions.forEach(function (opt) {
            defaults['button' + capitalized + opt] = passThrough;
        });
    });

    Slim.supported = function () {
        return !( // is opera mini
        Object.prototype.toString.call(window.operamini) === '[object OperaMini]' ||
        // no event listener support
        typeof window.addEventListener === 'undefined' ||
        // no file reader support
        typeof window.FileReader === 'undefined' ||
        // no blob slicing (can't dupe files)
        !('slice' in Blob.prototype) ||
        // no .createObjectURL support, used by download method but also convenient to exclude Android 4.3 and lower
        // Android 4.3 and lower don't support XHR2 responseType blob
        typeof window.URL === 'undefined' || typeof window.URL.createObjectURL === 'undefined');
    }();

    Slim.parse = function (context) {
        var elements;
        var element;
        var i;
        var croppers = [];

        // find all crop elements and bind Crop behavior
        elements = context.querySelectorAll('.slim:not([data-state])');
        i = elements.length;

        while (i--) {
            element = elements[i];
            croppers.push(Slim.create(element, Slim.getOptionsFromAttributes(element)));
        }

        return croppers;
    };

    Slim.getOptionsFromAttributes = function (element) {
        var dataset = getDataset(element);

        var options = {
            meta: {}
        };

        for (var prop in dataset) {
            var valueTransformer = defaults[prop];
            var _value = dataset[prop];

            if (valueTransformer) {
                _value = valueTransformer(_value);
                _value = _value === null ? clone(Slim.options()[prop]) : _value;
                options[prop] = _value;
            } else if (prop.indexOf('meta') === 0) {
                options['meta'][lowercaseFirstLetter(prop.substr(4))] = _value;
            }
        }

        return options;
    };

    Slim.find = function (element) {
        var result = instances.filter(function (instance) {
            return instance.isAttachedTo(element);
        });
        return result ? result[0] : null;
    };

    Slim.create = function (element, options) {
        // if already in array, can't create another slim
        if (Slim.find(element)) {
            return;
        }

        // if no options supplied, try to get the options from the element
        if (!options) {
            options = Slim.getOptionsFromAttributes(element);
        }

        // instance
        var slim = new Slim(element, options);

        // add new slim
        instances.push(slim);

        // return the slim instance
        return slim;
    };

    Slim.destroy = function (element) {
        var index = indexOfElement(element);

        if (index < 0) {
            return false;
        }

        instances[index].destroy();
        instances.splice(index, 1);

        return true;
    };
})();
    return Slim;
}());

	// helpers
	function argsToArray(args) {
		return Array.prototype.slice.call(args);
	}

	function isConstructor(parameters) {
		return typeof parameters[0] === 'object' || parameters.length === 0;
	}

	function isGetter(slim, method, parameters) {
		var descriptor = Object.getOwnPropertyDescriptor(Slim.prototype, method);
		return descriptor ? typeof descriptor.get !== 'undefined' : false;
	}

	function isSetter(slim, method, parameters) {
		var descriptor = Object.getOwnPropertyDescriptor(Slim.prototype, method);
		return descriptor ? typeof descriptor.set !== 'undefined' : false;
	}

	function isMethod(slim, method) {
		return typeof slim[method] === 'function';
	}

	// plugin
	$.fn['slim'] = function() {

		// get arguments as array
		var parameters = argsToArray(arguments);

		// is method
		if (isConstructor(parameters)) {
			return this.each(function(){
				Slim.create(this, parameters[0]);
			});
		}
		else {
			var method = parameters.shift();
			switch (method) {
				case 'supported':
					return Slim.supported;
				case 'destroy':
					return this.each(function(){
						Slim.destroy(this);
					});
				case 'parse':
					return this.each(function(){
						Slim.parse(this);
					});
				default:
					var results = [];
					this.each(function(){

						var slim = Slim.find(this);
						if (!slim) {
							return;
						}

						if (isMethod(slim, method)) {
							results.push(slim[method].apply(slim, parameters));
						}

						else if (isGetter(slim, method)) {
							results.push(slim[method]);
						}

						else if (isSetter(slim, method)) {
							results.push(slim[method] = parameters[0]);
						}

					});
					return results;
			}
		}

	};

}(window.jQuery));